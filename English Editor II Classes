<project wind-frame="22.000000,54.000000,233.000000,575.000000">
<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Docs
</name>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Change Log 1999.08"

1999.8.31	Added System::PostNewsMessage().

			Made MessageFileSource know its director (via AttachedToDirector()).

			Added MessageFileSource::Post() and made FunctionCall() call it.
			It seems to work but my message hasn't shown up yet...there it is! (A)

1999.8.30	Added DocumentSource::MakeMenuDocSource() virtual method.  Made
			WindowDirector::ShowMenu() use it.

			Restored the old DOMEditStylesheet, since there wasn't any speed
			difference and the old version will eventually allow more flexibility
			(such as <content/> specifications).  (A)

			Made DocumentSource a StyleScriptable.

			Made DisplayDirector::FunctionCall() pass "actionAllowed" calls
			on to the docSource when appropriate.

			Added MessageFileSource::FunctionCall().  Not yet complete.

			Added DisplayDirector::GetScriptProperty().

			Changed CompositeDisplayNode::LayoutInlineChildren() so it incorporates
			the LeftSpace() when calc'ing "maxLineWidth".  (B)

			Changed MessageFileSource::MakeMenuDocSource() to handle incoming and
			outgoing mail and news.

			Created MessageFileSource::Reply() and CloneNode().

			Added System::DocumentsDirectory(), OutgoingMailDirectory(), and
			OutgoingNewsDirectory().

			Made MessageFileSource::Save() set up "filePath" if it hasn't been
			set up yet.

			Made MessageFileSource::FunctionCall() handle "EmailReply" and
			"PostReply".

			Changed LiveXMLNodeFactory so the methods take DOMStrings instead
			of string_slices, corresponding to changes to XMLNodeFactory.  Also
			changed ctors for BasicLiveElement, BasicLiveAttr, and
			BasicLiveEntityReference.

			Made MessageFileSource::FunctionCall() return true for "actionAllowed"
			of "Send" or "Post".  (C)

			Fixed System::DocumentsDirector(), etc. to use "boot/home/" instead
			of "~/".

			Added System::SetFileMimeType().

			Made MessageFileSource::Save() set the MIME type of files it creates.

			-- Project file crashed and had to be rebuilt. --

			Added AttachedToDirector() virtual method to DocumentSource and
			MessageFileSource, and made DisplayDirector::SetupDisplayNodes()
			call it.

			Changed WindowDirector ctor so it sets up the controls before calling
			SetupDisplayNodes().

			Changed MessageFileSource::GetWindowTitle() so the window title is
			"Reply" if there is no file.  (1999.8.31.A)

1999.8.29	Rewrote DOMEditStylesheet so the dictionary maps
			{ propName, tagName } => attrValue, instead of mapping tagName => Element
			and then searching the element.  This made no difference in the time
			to open Constitution.  (Project crashed during backup, but was apparently
			not corrupted.)  (A)

1999.8.28	Made DisplayDirector::FunctionCall handle undo, redo, and save.

			Changed WindowDirector::DoDocAction() so it evaluates the action
			using the StyleParser.  (A)

			Created TextFileWriter.

			Created MessageFileWriter.

			Wrote MessageFileSource::Save().

			Fixed MessageParser::Parse(), which wasn't finding the "Newsgroups:"
			header (it was checking "headerTag" instead of "headerName").  (B)

			Changed ElementDisplayNode::Load() to check if the "display" property
			is "none" for a child element before creating a DisplayNode for it.
			Constitution now takes 3.8 seconds to open (although it seems the same
			if I comment that bit out).

			Changed DOMEditStylesheet::PropertyForElement() to use map::find()
			instead of map::operator[].  In a bit of C++ stupidity, operator[]
			actually inserts a new element into the tree.  Oddly, this had no
			effect on the time to open Constitution.  While I was in there, I
			cleaned it up some, using Element::GetAttribute() now that that
			exists (and returns the whole attribute value, not just the first
			Text).  (C)

1999.8.27	Rewrote MessageParser::FillBlock() to automatically create <a> and
			<i> elements where appropriate.  Unfortunately, the email address
			handling broke the stripping of common boring garbage from
			attributions.

			Changed MessageParser::StripAttribution() around so it gets rid
			of the common boring garbage before building the attribution
			element, not after.  (D)

			Fixed MessageParser::StripAttribution() so it recognizes '\n' and
			'\r' when trimming the trailing whitespace.

			Made MessageParser::FillBlock() recognize "ftp:" URLs in addition
			to the ones it already handled.  (E)

1999.8.26	Created MessageParser, adapting most of the code from EE1's
			TextDocumentBuilder.  Also added QuoterDict, adapting it from EE1.
			Not yet tested.  (A)

			Created MessageFileSource.

			Made EnglishEditorApp::OpenFile() handle message files.

			Changed FileTypes.rsrc to allow "text/x-email", "text/x-news", and
			"message/news".

			Debugging of MessageParser.  (1999.8.27.A)

			Made MessageParser::StripAttribution() get rid of the "common boring
			garbage" in the attribution.  Also made it ignore the "quoter" of
			otherwise blank lines, which fixes the glitch you sometimes see where
			two consecutive paragraphs from the same guy will end up as two quotes.

			Fixed MessageParser::Parse() so an unknown attribution ("Sombody wrote:")
			is generated as an "attribution" element, not a "p".  (1999.8.27.B)

			Added EnglishEditorWind::RequestClose().

			Added CanCloseOnSpacebar() virtual method to DocumentSource and
			MessageSource.

			Made WindowDirector know its EnglishEditorWind, and made KeyDown()
			close the window on the spacebar when appropriate.

			-- Project file crashed and had to be rebuilt. --
			(1999.8.27.C)

1999.8.25	Created StyleScriptable.

			Added StyleParser::NextArg(), ParseInt(), and Eval().

			Made ElementDisplayNode a StyleScriptable.

			Made DisplayDirector a StyleScriptable.

			Added MenuDirector::GetScriptProperty(), making it handle the
			"window-director" property.  (A)

			Made ElementDisplayNode::GetHotspot() evaluate the "action" style.  (B)

			Changed ElementHotspot (and subclasses) to keep the ElementDisplayNode
			instead of the Element.

			Made ElementHotspot::Clicked() evaluate the "action" style.  The menu
			now works completely!

			Disabled Hotspot::FadeDocument().  (C)

1999.8.24	Changes to MenuDirector ctor to relayout at the real width (so the
			hotspots don't go off the screen).  (A)

1999.8.20	Added DoDocAction() virtual method to DisplayDirector, WindowDirector,
			and MenuDirector.

			Made MenuDirector and WindowDirector delete their DocumentSources.

			Added WindowDirector::ShowMenu() and HideMenu() methods, with support
			in dtor, Draw(), MouseMoved().

			Made MenuControl::MouseDown() cause the menu to come up.

			Added MenuDirector::Bounds().

			Changes to ElementDisplayNode::GetHotspot() and ElementHotspot::Clicked()
			to support "attr()" notation, and made the Clicked() pass the action
			to the director.  The menu now works, but needs work.  (C)

			Added WindowDirector::MenuIsVisible().

			Made MenuControl::MouseDown() hide the menu if it's visible.  This
			didn't work, because WindowDirector::Draw() has hidden the menu
			automatically by that point.  But this made me realize the need for
			a redesign, so the menu is one UI object (not two: menu & control).
			It'll have a hidden form that animates opening to the expanded form.

			Tweex to MenuDirector.

			Made WindowDirector::MouseDown() let the MenuControl take care of
			hiding the menu.  (1999.8.21.A)

			Changed MenuControl to raise its bottom, and to hide when the menu
			is visible.  (1999.8.21.B)

			Made WindowDirector::MouseDown() let the MenuControl take care of
			hiding the menu.  (1999.8.21.A)

			Changed MenuControl to raise its bottom, and to hide when the menu
			is visible.  (1999.8.21.B)

			-- CY Project file crashed AGAIN!!!! --

			Added StrokeEllipse() and FillEllipse() methods to View.

			Changed MenuControl to draw a little circle instead of an asterisk.
			(1999.8.21.C)

			Added Hotspot::FadeDocument() and made Draw() methods of
			InlineElementHotspot and BlockElementHotspot call it.  (1999.8.21.D)

			Changed MenuDirector::Draw() to draw the border last (so the hotspot
			doesn't grey it out).  (1999.8.21.D)

1999.8.19	Created BlockElementHotspot.

			Made ElementDisplayNode::GetHotspot() return a BlockElementHotspot when
			appropriate.  (C)

			Created MenuDirector.  Not yet tested.  (1999.8.20.A)

			Created MenuControl.

			-- CY Project crashed and had to be rebuild.  This is getting bad... --

			Installed the MenuControl in the WindowDirector.  (1999.8.20.B)

1999.8.18	Created Hotspot and ElementHotspot.

			Created InlineElementHotspot.

			Added "color" default argument to GlyphsHilite ctor, with corresponding
			ivar and changes to Draw() to use it.  (A)

			-- CY Project crashed and had to be rebuilt. --

			Added BlockFindHotspot() virtual method to BlockableDisplayNode and
			CompositeDisplayNode.

			Added CompositeDisplayNode::FindHotspotInChildBlocks() and
			FindHotspotInInlineChildren().

			Created FindHotspotContext.

			Added InlineFindHotspot() virtual method to InlineableDisplayNode,
			TextDisplayNode, and CompositeDisplayNode.

			Added GetHotspot() virtual method to DisplayNode.  (B)

			Added ElementDisplayNode::GetHotspot().

			Made CompositeDisplayNode::BlockFindHotspot() and InlineFindHotspot() check
			if the node has its own hotspot.

			Changed DisplayDirector::MouseDown() method to handle hotspots.

			Added DisplayDirector::UpdateHotspot() and made WindowDirector::MouseMoved()
			call it.

			Made WindowDirector::Draw() draw the hotspot.

			Added "director" argument to GetHotspot() method of DisplayName and
			ElementDisplayNode.

			Added "director" to FindHotspotContext.

			Basic hotspot handling now works.  (1999.8.19.A)

			Added System::OpenURL() and made ElementHotspot::Clicked() call it.
			(1999.8.19.B)

1999.8.16	Added PointSelection::SelectPastText() and SelectBeforeText(), factoring
			the code out of BetweenGlyphsSelection::SelectForward/Backward().

			Changed AcceptKey() methods of CharacterSelection, BetweenWordsSelection,
			and BetweenGlyphsSelection to handle option-arrow keys.  Included
			adding PointSelection::SelectPastWord() and SelectBeforeWord() helper
			methods.

			Changed the EnglishEditorWind ctor to go back to the normal Be
			window style (with the title tab).  (1999.8.17.A)

1999.8.15	Fixed InlineLayoutContext so it handles the text-indent correctly
			(it was backwards before).  (A)

			Changed EnglishEditorWind ctor so the window has B_MODAL_WINDOW_LOOK.
			We'll see how this works out.

			Added DisplayNode::DescendsFrom().

1999.8.14	Changed Point() methods of CharacterSelection, BetweenGlyphsSelection,
			and BetweenWordsSelection to use TextDisplayNode::CurFont() instead of
			GetFont().  Also did the same to the PointSelection ctor.  This should
			be significantly faster, as well as plugging a memory leak, since none
			of these deleted the font.  (B)

			Added StartSelection() virtual method to DisplayNode, CompositeDisplayNode,
			and TextDisplayNode.

			Made AcceptKey() methods of BetweenWordsSelection, CharacterSelection,
			and BetweenGlyphsSelection handle the left and right arrow keys.
			Included adding BetweenGlyphsSelection::SelectForward() and
			SelectBackward().

			Added SelectionIntoFront() and SelectionIntoBack() virtual methods to
			Glyph, Word, Space, SmartMDash, and SmartQuote.  (C)

			Rewrote BetweenGlyphsSelection::SelectForward() and SelectBackward()
			to use Glyph::SelectionIntoFront/Back().

			Added DocToDisplayOffset() and DisplayToDocOffset() virtual methods
			to Word and SmartenedWord.

			Changed name of GetWord() virtual method in Word and SmartenedWord
			to GetDisplayWord().  Changed callers: and CharacterSelection::Point()
			TextDisplayNode::InlineFindSelection(), making them use the new
			DocToDisplayOffset() and DisplayToDocOffset() methods.

			Added UTF8Utils::BytesForNChars().  (D)

			Made AcceptKey() methods of InlineElementSelection, GlyphsSelection, 
			EmptyPlaceholderSelection, BlocksSelection, BlockElementSelection, and
			BetweenBlocksSelection handle left- and right-arrow keys.

			Made all the AcceptKey() methods scroll to the selection when handling
			left- and right- arrow keys if they weren't already.

			Added PlaceholderTextDisplayNode::StartSelection().

			Added DisplayNode::PrevNodeInDoc() and NextNodeInDoc().

			Rewrote BetweenGlyphsSelection::SelectForward() and SelectBackward()
			to use DisplayNode::PrevNodeInDoc() and NextNodeInDoc().

			Made BetweenGlyphsSelection::SelectForward() and SelectBackward()
			select between blocks when appropriate.  (E)

1999.8.13	Made WindowDirector::KeyDown() treat Command-Z and Command-Shift-Z as
			Undo and Redo, respectively.

			Made StyleParser::ParseColor() handle "rgba(...)" syntax.

			Created Tweex.

			Made Selection::selectionColor use Tweex, then restored it so it doesn't
			again.  I don't want to have to include Tweex.xml with the distribution,
			so I'm only going to use it for development until I figure out a way
			to compile it in.  (A)

			The CY project file crashed (during a backup!) and had to be rebuilt.

			Added ScrollToSelection() virtual method to DisplayDirector and
			WindowDirector.  Made DisplayDirector::DoAction(), Undo() and Redo()
			call it.  (1999.8.14.A)

1999.8.10	Created StyleParser.

			Changes to TextDisplayNode to support colors.  Changes to
			UpdateProperties() and InlineDraw().  (B)

			Created PlaceholderTextDisplayNode.

			Made ElementDisplayNode::Load() add a placeholder text if appropriate.

			Fixed BlockElementSelection::AcceptKey() so it doesn't crash when
			trying to type-to-replace an empty element.

			(Temporary?) changes to NewElementAction so it doesn't put an empty
			Text into the new element, thus allowing the placeholder text mechanism
			to kick in.  But this causes display weirdness when creating a new
			block element with no placeholder text, and a crash when creating an
			inline element with no placeholder text.  I'll have to figure out what to
			do about this--I think I always want a PlaceholderTextDisplayNode, with
			a new PointSelection to handle the empty-placeholder case.  THIS BACKUP
			WILL CRASH as noted.  (C)

			Made InlineElementSelection::TagNameChanged() call HideTag(), to
			prevent a crash in TagEditDone() (attempting to get Bounds()) after
			the selection is no longer valid).

			Added PlaceholderTextDisplayNode::InlineLayout(), which calls
			UpdateProperties() if the properties haven't been set up yet (the
			inherited one just throws an exception).  I might wanna consider
			having TextDisplayNode's version do this instead of throwing the
			exception; there doesn't seem to be any reason not to.  (D)

			Created EmptyPlaceholderSelection and RestoreEmptyPlaceholderSelection.

			Made PlaceholderTextDisplayNode::EndSelection() return an
			EmptyPlaceholderSelection when appropriate.

			Changed NewElementAction::Do() to use ElementDisplayNode::EndSelection().
			(This will need more work when new elements can get automatic contents
			from the stylesheet or validator.)

			Changed ElementDisplayNode::Load() to always have a placeholder text
			(even an empty one) in an empty element.

			Made TagSelection::HideTag() kick out if there's no tag.  In some
			circumstances (eg. EmptyPlaceholderSelection), even calling Bounds()
			once the selection is invalid can cause a problem.

			Changed ElementDisplayNode::GetSelection() to return an
			EmptyPlaceholderSelection when appropriate.

			Changed NewElement::Do() to use Element::GetSelection().

			Added PlaceholderTextDisplayNode::IsEmpty().

			I think all the placeholder stuff works now...phew.  (E)

			Added EmptyPlaceholderSelection::Draw(), so the tag always shows.
			Also fixed AcceptKey() to check if the tag is selected rt if it
			exists when deciding whether to pass the key to it.

			Created SelectBetweenBlocksAction.  Enabled the existing
			commented-out code in the AcceptKey() methods of BlockElementSelection
			and BlocksSelection to use it.

			Added BetweenBlocksSelection::AcceptKey(), making it insert an
			element on typing.

			Added NewElementAction::GetNewElement().  (1999.8.11.A)

			Added TextDisplayNode::FirstGlyph().

			Rewrote PlaceholderTextDisplayNode::InlineFindSelection(), which
			was always returning the element selection, even if the mouse
			click was after the text.  (1999.8.11.B)

1999.8.9	Removed Clear() methods from Selection and subclasses--it's never used.

			Added FirstNode() and LastNode() virtual methods to BlockableDisplayNode,
			ElementDisplayNode, GeneratedLeafBlock, and DocumentDisplayNode.

			Created BetweenBlocksSelection and RestoreBetweenBlocksSelectionAction.

			Made CompositeDisplayNode::FindSelectionInChildBlocks() return a
			BetweenBlocksSelection when appropriate.  (C)

			Changed WindowDirector::Draw() so it doesn't clip the top of a selection
			when scrolled to the top, or the bottom of a selection when scrolled
			to the bottom.

			Fixed ScrollerControl::Draw() so the centerline doesn't get drawn
			through the thumb.

			Changed TagEditor::Draw() to draw the outline in a different color
			when selected, but currently that "different" color is the same
			color it always was, since I haven't found another one I like yet.

			Fixed TextDisplayNode dtor, which was doing "delete glyphs;" twice
			instead of "ClearGlyphs(); delete glyphs;".  (1999.8.10.A)

1999.8.8	Unified the GlyphsHilite::Draw() methods by making "tagBounds" a default
			argument.

			Fixed GlyphsHilite::TagSpecRect() to work correctly on multi-line
			selections.  (A)

			Added HandleSpecialKey() virtual method to Selection and made
			WindowDirector::KeyDown() call it.

			Made TagSelection::TagIsSelected() check if there really is a tagEditor.

			Added InlineElementSelection::HandleSpecialKey().

			Fixed TagSelection::AcceptKey() to call TagEditDone() instead of
			TagChanged() when leaving the tag.

			Added TagDocumentSource::SetTagName() and TagEditor::SetTagName().

			Changed TagSelection::AcceptKey() to restore the tag name on leaving
			a tag edit where the tag is left empty.

			Added DOMChangeClient::DataSet() virtual method.

			Added BasicLiveText::SetData().

			Added TextDisplayNode::DataSet().

			Added TagSelection::RestoreTag() and changed TagSelection::AcceptKey()
			to use it.

			Made InlineElementSelection::HandleSpecialKey() use
			TagSelection::RestoreTag() instead of the quick and dirty method it
			was using before.

			Moved HandleSpecialKey() method from InlineElementSelection() to
			TagSelection(), since it's common behavior for all TagSelections.
			(Made a couple changes as well.)  Now esc-out-of-tag-edit fully
			works.  (B)

			Fixed InlineElementSelection::ExtendTo() so it finds next and previous
			glyphs correctly (it was starting its searches the element's first and
			last TextDisplayNodes, rt the ElementDisplayNode); and so it correctly
			promotes selections that are of a whole element.  Tried to get this
			promotion happening above one level, but gave up--maybe someday I'll
			do universal glyph-extending code that'll handle this.  (C)

			Created GlyphsSelection::SelectionFromTo(), moving the code from
			the end of InlineElementSelection::ExtendTo().  Changed ExtendTo()
			methods of InlineElementSelection and GlyphsSelection to use it.  Also
			made CharacterSelection::Promote() use it.  (D)

			Created BlockElementSelection and RestoreBlockElementSelectionAction.
			Made ElementDisplayNode::GetSelection() return a BlockElementSelection
			when appropriate.

			Made TagSelection::DeselectTag() check if there really is a TagEditor.

			Made BlocksSelection::Draw() use the alpha drawing mode.  (E)

			Changed CompositeDisplayNode::FindDestinationInChildBlocks() to
			work when the source is a BlockElementSelection.

			Made BetweenBlocksDestination::MakeMoveAction() deal with
			BlockElementSelection.

			Changed SelectionBlockElementsAction::Do() to use a
			BlockElementSelection when appropriate.  (1999.8.9.A)

			Changed GlyphsSelection::SelectFromTo() to have the Element supply
			the new selection when selecting an element.  That way, block
			elements get selected correctly.  (1999.8.9.B)

1999.8.7	Changed TagEditor::Draw() to draw the outline to the edge of Bounds()
			(using a fudge factor to get it there--it seems lineSpill isn't quite
			calc'ed correctly).  Removed fudge factors from Draw() methods of
			PointSelection and GlyphsHilite.  Adjusted various tweex.  (E)

			The CY project file got corrupted and had to be rebuilt.

			Added GlyphsHilite::TagSpecRect(), moving the code and associated
			tweex from InlineElementSelection, which now just calls GlyphHilite's
			method.

			Made GlyphsSelection a TagSelection.  TagNameChanged isn't yet written,
			though.  (F)

			Created EncloseTextAction.

			Made GlyphsSelection::TagNameChanged() work, except if there's an
			embedded element.  (G)

1999.8.6	Changed Selection::selectionColor alpha to 128.

			Created TagSelection.  Not finished yet.

			Added TagEditor::Select().  (1999.8.7.A)

			Added TagEditor::Deselect() and IsSelected().

			More work on TagSelection.  (1999.8.7.B)

			Made InlineElementSelection a subclass of TagSelection, and made it
			keep the tag showing all the time.

			Changed TagEditor ctor so it doesn't try to select itself.

			Tweaking of TagEditor tweex.

			Changed TagEditor::Bounds() to use an "emptyWidth" tweek instead of
			a "minWidth" tweek.

			InlineElementSelection tags are now working great, but PointSelection
			tags are broken.  (1999.8.7.C)

			Made PointSelection a subclass of TagSelection, and tweeked it a bit.
			(1999.8.7.D)

1999.8.5	Added GlyphsHilite::Draw(..., tagBounds) method.  Currently it's using
			a fudge factor, though.  I think this means TagEditor::Bounds() is not
			correct.

			Changes to InlineElementSelection to support a TagEditor.

			Created ChangeElementTagNameAction.

			Wrote InlineElementSelection::ChangeTagName().

			Added ElementDisplayNode::ChildReplaced().

			Changed ElementDisplayNode::ChildRemoved() and ChildInsertedBefore() to
			work correctly if the Element isn't in a displayed Document (because it
			once was, but was removed).

			Changing the tag of an inline element now works, but it was done a bit
			half-assed: a TagEditableSelection class should factor out the
			handling of the TagEditor, since there's so much in common between
			PointSelection and InlineElementSelection; and that fudge factor in
			GlyphsHilite::Draw(..., tagBounds) needs to be hunted down and
			eliminated.  And Draw(..., tagBounds) shouldn't even be a separate
			method, try using a default arg.  (C)

			Made InlineElementSelection::ChangeTagName() check if the new tag name
			has really changed (or if it's empty).  (1999.8.6.A)

1999.8.4	Added TagEditor::Bounds(), which turned out to be surprisingly easy.

			Changes to PointSelection and BetweenWordsSelection to support element
			insertion.

			Debugging of TagEditor.

			Fixed WindowDirector::DocRect().  (A)

			Made TagEditor ctor select the tag name.

			Made AcceptKey() methods of CharacterSelection and BetweenGlyphsSelection
			call the inherited method to handle keys for the tag editor.  (B)

			Added TagEditor::TagName().

			Added InsertTag() virtual method to PointSelection and made
			PointSelection::AcceptKey() call it.

			Created NewElementAction.

			Added DeleteSelection() and ClearDeletedSelections() to DisplayDirector
			(basically copying them from EE1), and made DisplayDirector and
			WindowDirector call them as appropriate.

			Added AddCharsAction::GetText(), AtChar(), and Length().

			Added NewElementAction::CanIncorporateNext() and IncorporateNext(),
			to incorporate AddCharsAction.

			Made SplitTextAction::Undo() clear the selection, since the selection
			might be in the new text.

			Element insertion is now working from BetweenWordsSelection!  Except
			that, after inserting the element, the selection isn't displaying
			in the correct place (although it *is* in the correct place), because
			BetweenGlyphsSelection::Point() doesn't work correctly when both
			"firstGlyph" and "secondGlyph" are NULL.  (1999.8.5.A)

			Added LastGlyph() virtual method to InlineableDisplayNode,
			CompositeDisplayNode, and TextDisplayNode.

			Fixed BetweenGlyphsSelection::Point() to work correctly when both
			"firstGlyph" and "secondGlyph" are NULL.

			Added InsertTag() methods to CharacterSelection and
			BetweenGlyphsSelection.  (1999.8.5.B)

1999.8.3	Changes  to InlineLayoutContext and CompositeDisplayNode to keep the
			maximum line width.

			Added MaxLineWidth() virtual method to BlockableDisplayNode and
			CompositeDisplayNode.  The MaxLineWidth stuff is not yet tested.  (A)

			Added View::FillShape().

			Created TagEditor.  Mostly done except for the crucial Bounds() method.

			Created TagDocumentSource.  (B)

1999.8.2	Split DisplayDirector into DisplayDirector and WindowDirector classes.
			Changes to EnglishEditorWind, EnglishEditorView, ScrollerControl,
			FrameRateControl, and StatusControl, all of which needed to know about
			WindowDirector.  (A)
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Change Log 1999.07"

1999.7.31	Removed all statics from DisplayDirector, since it was all stylesheet
			stuff that's no longer used since CompositeStylesheet came in.

1999.7.30	Renamed SmartDoubleQuote to SmartQuote, adding new DisplayString() virtual
			method and calling it where appropriate.  Created new SmartDoubleQuote,
			which is a simple subclass of SmartQuote.

			Created SmartSingleQuote.

			Changes to TextDisplayNode::CreateGlyphs() and AddGlyph() to smarten
			single quotes and words with apostrophes (although the latter isn't
			enabled yet pending a SmartenedWord class).

			Created SmartenedWord, subclassing it from Word.

			Changed TextDisplayNode::AddGlyph() to handle SmartenedWords.  All
			smartening is done!  (A)

1999.7.29	Added Glyph::ShouldDraw() helper method.

			Created SmartDoubleQuote.

			Changed TextDisplayNode::CreateGlyphs() to smarten double-quotes.  (B)

1999.7.28	Made System::AppDirectory() static, like it should have been all along.

			Created CompositeStylesheet.

			Changes to DisplayDirector to keep its own CompositeStylesheet.

			Changed DisplayNode::GetInheritedProperty() to check "#default" if
			the property wasn't otherwise found.  Now multiple stylesheets are
			working.  Constitution now takes 3.5 seconds to open.

			Moved the "#default" handling from DisplayNode::GetInheritedProperty()
			to new DocumentDisplayNode::GetProperty().  It's a little cleaner that
			way, but unfortunately it didn't improve the Constitution open time.
			(1999.7.29.A)

1999.7.27	Created System class to hold general platform-specific stuff, and added
			AppDirectory() static method.

1999.7.25	Changed EnglishEditorApp::OpenFile (and FileTypes.rsrc) so it'll accept
			files of type "text/xhtml".

1999.7.23	Started writing BlocksSelection::AcceptKey(), making it handle backspace
			and delete keys.

			Made BlocksSelection::AcceptKey() handle replace-by-typing.  (C)

			Added Confirmer.

			Wrote DisplayDirector::CloseRequested().  (1999.7.24.A)

1999.7.22	Added BlockableDisplayNode::Bottom().

			Created BetweenBlocksDestination.

			Made CompositeDisplayNode::FindDestinationInChildBlocks() return a
			BetweenBlocksDestination when appropriate.  (A)

			Created SelectBlockElementsAction.

			Added FirstNode() and LastNode() methods to BlocksSelection.

			Wrote BetweenBlocksDestination::GetMoveAction().

			Added "create" default argument to DisplayDirector::DisplayNodeFor().

			Changed ElementDisplayNode::ChildInsertedBefore() so it doesn't create
			a new DisplayNode for the child (as "childDisplayNode") if one didn't
			exist.  Specifically, that was a problem for ignorable-white-space
			Text nodes.  (1999.7.23.A)

			Added BetweenBlocksDestination::MakeMoveAction() private method,
			moving most of the code there from GetMoveAction().  Made GetMoveAction()
			and GetCopyAction() call it.  (1999.7.23.B)

1999.7.21	Created BlocksSelection.  Still needs AcceptKey().

			Made ElementDisplayNode::GetSelection() return a BlocksSelection when
			appropriate.

			Fixed GlyphsSelection::Promote() to check if the InlineableDisplayNode
			really is inline in the "get out of the selection" section.

			Created RestoreBlocksSelectionAction, although it only works when
			the first and last DisplayNodes of the selection are
			ElementDisplayNodes.  (A)

1999.7.14	Added LeftArrowKey and RightArrowKey to Keys.

			Wrote InlineElementSelection::AcceptKey().

			Made MoveNodesAction::Do() and Undo() clear the selection.  This is
			sort of a kludge to get around a bug when undoing replacing the text
			of an InlineElementSelection--the AddCharsAction sets the selection
			on undo (and we want to retain that behavior for backward-compatibility)
			but that selection becomes invalid when the Text node is removed.  (A)

1999.7.13	Fixed ElementDisplayNode::ChildInsertedBefore() and ChildRemoved() to
			call GetDisplayNode() rt DisplayNode(), which turns out just to be
			the DisplayNode ctor.

			Created InlineElementSelection and RestoreInlineElementSelectionAction.

			Changed ElementDisplayNode::GetSelection() to return an
			InlineElementSelection if its inline.

			Changed TextDisplayNode::InlineFindDestination() to allow
			InlineElementSelections.

			Changed SpaceDestination::GetMoveAction() to handle InlineElementSelections.
			This is not really correct, though; we need GlyphsMover to handle
			single-element selections, so the outer elements in directly-nested
			elements can be moved.  Umm, and also so it moves the element, not
			its contents

			Changed GlyphsMover::MakeAction() to use a RestoreSelectionAction
			instead of a RestoreGlyphsSelectionAction.  (A)

			Factored out much of the GlyphsMover ctor into new ConfigureDest()
			private method.  (B)

			Added GlyphsMover(ElementDisplayNode*, ...) ctor.

			Changed GetMoveAction() and GetCopyAction() methods of SpaceDestination
			and BetweenGlyphsDestination to handle InlineElementSelections correctly.
			Included adding MakeMoveAction() private methods.  (1999.7.14.A)

1999.7.12	Added FirstChild() and LastChild() virtual methods to DisplayNode and
			TextDisplayNode (CompositeDisplayNode and children already had it).

			Added VerticalMarginsChanged() method to BlockableDisplayNode, and
			CalcVerticalMargins() virtual method to BlockableDisplayNode and
			CompositeDisplayNode.  Changed CompositeDisplayNode::UpdateProperties()
			to use CalcVerticalMargins().

			Changed ElementDisplayNode::ChildInsertedBefore() and ChildRemoved()
			to use the new VerticalMarginsChanged() mechanism.  By eliminating
			unnecessary UpdateProperties() calls, inserting a new paragraph has
			now lost the remaining sluggishness.  (A)

			Added Selectable() virtual method to DisplayNode, ElementDisplayNode,
			TextDisplayNode, DocumentDisplayNode, and GeneratedLeafBlock.

			Added GetSelection() virtual method to DisplayNode and
			ElementDisplayNode.  ElementDisplayNode's version is only a first cut;
			someday there'll be an InlineElementSelection which it will use
			in place of GlyphsSelection, and a BlockElementSelection which
			it'll use in place of nothing.

			Added GlyphRef::operator==() and operator!=().

			Wrote GlyphsSelection::Promote(). (B)

			Removed the Selectable() virtual method from DisplayNode and subclasses
			(see above), since a display node needs only to return NULL from
			GetSelection() to indicate nonselectability.

1999.7.11	Changed LiveXMLNodeFactory::MakeText() to take a DOMString instead of
			a string_slice, conforming to changes in the DOM classes.

			Changed XMLWriter::WriteText() to check for characters that need to
			be quoted with standard entities.  Actually, it does 'em all now,
			which is sorta okay--it's safe for attributes as well as text.  (A)

1999.7.10	Project got corrupted; had to restore from backup.

			Changed call to auto_ptr ctor in DisplayNode::GetPropertyInPixels(),
			since in R4.5 CW no longer allows the initialization syntax (that ctor
			has been made "explicit", conforming with the C++ book...stupid C++...).

			(New para in Constitution takes 3 seconds.)

			Added "needsLoad" ivar and NeedsLoad() method to DisplayNode, and changed
			Load() to clear it.  Changed Load() method of DocumentDisplayNode,
			ElementDisplayNode, and TextDisplayNode to call their inherited methods.

			Changed CompositeDisplayNode::LoadChildren() to check each child's
			NeedsLoad() before loading it.

			(No effect on time for new para in Constitution.)

			Changed ElementDisplayNode::ChildInsertedBefore() so UpdateProperties()
			only gets called on the child.  This is not really correct and didn't
			even save much time, so I changed it back.

			Added "needsLayout" ivar and NeedsLayout() method to DisplayNode, and
			made Load() set it.

			Added "force" argument to BlockLayout() method of BlockableDisplayNode
			and subclasses.

			Added "force" argument to CompositeDisplayNode::LayoutChildBlocks(),
			and made it check that and the child block's NeedsLayout() before
			calling BlockLayout() on the child block.

			Made CompositeDisplayNode::BlockLayout() method clear "needsLayout".

			(That did it.  It's still a bit sluggish but not nearly so bad.) (A)

]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Change Log thru 1999.06"

1999.6.26	Added GetRestoreAction() virtual method to Selection and subclasses.

			Created RestorePointSelectionAction and RestoreBetweenWordsSelectionAction.

			Created RestoreSelectionAction.

			Changed AcceptKey() methods of BetweenWordsSelection and
			BetweenGlyphsSelection to restore the selection on undo.  (A)

			Added View::ConstrainClippingRegion().

			Enabled clipping of selection in DisplayDirector::Draw().  (B)

			Added GlyphRef::CommonAncestorWith(), moving code there from
			GlyphsSelection::CommonAncestor() (which is now deleted).

			Removed GlyphsMover::CommonAncestor(), and made ctor use
			GlyphRef::CommonAncestorWith() instead.

			Added GlyphRef::StartOffset() and EndOffset().

			Wrote GlyphsSelection::AcceptKey().

			Created RemoveNodesAction.  Typing to replace a GlyphsSelection
			now works.  (C)

			Created SelectPointAction.

			Made GlyphsSelection::AcceptKey() handle backspace and delete keys.  (D)

1999.6.25	Made PointSelection keep "textNode", and changed its subclasses so
			they don't do that themselves.

			Added PointSelection::IsInLastTextOfBlock() and
			EnclosingLeafBlockElement().

			Created NewLeafBlockAction.

			Made AcceptKey() methods of BetweenWordsSelection and
			BetweenGlyphsSelection handle creation of new paragraphs.  Still need
			to restore selection on undo, though--I'm thinking of adding a
			Selection::GetRestoreAction() method.  (A)

1999.6.23	Created LiveText and made BasicLiveText a subclass of it.

			Created LiveCDATASection and made BasicLiveCDATASection a subclass of it.

			Created LiveElement and made BasicLiveElement a subclass of it.

			Created LiveAttr and made BasicLiveAttr a subclass of it.

			Created LiveDocument and made BasicLiveDocument a subclass of it.

			Created LiveEntityReference and made BasicLiveEntityReference a subclass
			of it.  (1999.6.23.A)

			Changed TextDisplayNode to keep a pointer to a LiveText instead of a
			BasicLiveText.  Included changing the return type of GetText(), which
			meant changes to CharacterSelection::AcceptKey, and some of the changes
			below.

			Changed RestoreGlyphsSelectionAction to keep a pointer to a LiveText
			instead of a BasicLiveText.

			Changed BackCharsAction to keep a pointer to a Text instead of a
			LiveText.

			Changed AddCharsAction to keep a pointer to a Text instead of a
			LiveText.  (1999.6.23.B)

			Changed DisplayDirector::DisplayNodeFor() so it only needs to know
			about LiveText, not BasicLiveText.

			Made ElementDisplayNode ctor register itself as a change client
			of the LiveElement.

			Made ElementDisplayNode keep a pointer to a LiveElement instead of
			a BasicLiveElement.

			Made DocumentDisplayNode ctor register itself as a change client
			of the LiveDocument.

			Changed DisplayDirector so it doesn't set the change client of the
			nodes, now that display node ctors do it.

			Made DocumentDisplayNode keep a pointer to a LiveDocument instead
			of a BasicLiveDocument.

			Changed DisplayDirector::DisplayNodeFor() so it only needs to know
			about LiveElement and LiveDocument, not the Basic... versions thereof.

			Cleanup of #includes for BetweenGlyphsSelection, SpaceDestination,
			BetweenGlyphsDestination, GlyphsMover, TextSpan, AddCharsAction, and
			TextDisplayNode, now that we're not passing BasicLiveTexts around.
			(1999.6.23.C)

1999.6.17	Created CopyNodesAction and made GlyphsMover::MakeAction() use it.

			Wrote GetCopyAction() methods for SpaceDestination and
			BetweenGlyphsDestination.

			Made DisplayDirector::DragSelection() handle copies.

			Added copy constructors and CloneNode() methods to BasicLiveDocument,
			BasicLiveAttr, BasicLiveElement, BasicLiveEntityReference,
			BasicLiveText, and BasicLiveCDATASection.  These now clone themselves
			correctly.

			Changes to GlyphsMover::MakeAction() to select properly after copying
			if nodes were copied and there is no first text or no last text.
			(1999.6.18.A)

1999.6.14	Created CopyCharsAction.

			Made GlyphsMover::MakeAction() use CopyCharsAction (instead of just
			throwing an exception).

			Some debugging of GlyphsMover.  (1999.6.15.A)

			Further debugging of GlyphsMover (adjusting "destOffset" after moves).
			(1999.6.15.B)

			Further debugging of GlyphsMover, so it works when moving nodes with
			only a first text OR a last text.  Included adding FirstTextIn() and
			LastTextIn() methods.  I think this takes care of the
			BetweenGlyphsDestination move.  (1999.6.15.C)

			Rewrote SpaceDestination::GetMoveAction() to use GlyphsMover.

			More debugging of GlyphsMover (adjusting "endSelection" when moving
			an end space or deleting a source end space, optimizing taking/deletion
			of spaces).  (1999.6.15.D)

			Made GlyphsMover::MakeAction() do the insertion of a space into the
			source if necessary.

			Made GlyphsMover::MakeAction() adjust the "selectionStart" after
			moving the second text.  (1999.6.15.E)

1999.6.13	Created TextSpan.

			Added "useAssertions" global to InternalException's .h preamble.

			Made the instance variables of GlyphRef public.

			Created GlyphsMover.  Not yet tested.  (A)

1999.6.12	Created SplitTextAction.  Made
			BetweenGlyphsDestination::MoveActionWithElements() use it.

			Added ElementDisplayNode::ChildRemoved().

			Added SelectGlyphsAction::Undo(), making it clear the selection.

			Added "select" ctor arg & ivar to MoveCharsAction, making Do() and
			Undo() honor it.  Made GetMoveAction() methods of
			BetweenGlyphsDestination and SpaceDestination pass it.

			With the DOMString fixes, the move-with-elements thing seems to be
			working quite well (except for not handling spaces/binding next to
			elements correctly).  (A)

			Changed BetweenGlyphsDestination::MoveActionWithElements() to handle
			the case where two Texts are next to each other.  (B)

			Created InsertSpaceAction.

			Changed BetweenGlyphsDestination::MoveActionWithElements() to also
			handle the case where there's only one source text (and no elements).
			Made GetMoveAction() call it always.

			Changed DeleteCharsAction so it takes a Text rt a BasicLiveText.

			Made BetweenGlyphsDestination::MoveActionWithElements() handle
			removing pre and post space.  Renamed it to GetMoveAction(), deleting
			the old one.  (C)

1999.6.11	Tracked that crash on redo to a bug in DOMString.

			More work on BetweenGlyphsDestination::MoveActionWithElements().  It's
			not fully working right yet, but I might make some major changes and
			wanted a backup here.  (B)

			Much work on BetweenGlyphsDestination::MoveActionWithElements().

			Made RestoreGlyphsSelectionAction::Do() clear the selection.

			BetweenGlyphsDestination::MoveActionWithElements() seems to finally
			work, except for an intermittent crasher when dragging "coed vocal
			quintet" between "here" and ".".  The crash happens in
			DisplayDirector::SetSelection() when called by SelectGlyphsAction::Do(),
			when getting the bounds of the old selection to refresh it prior to
			deleting it.  The old selection is from the second MoveCharsAction.
			Why it's a problem I don't know; I'm done for the night.  (C)

1999.6.10	Made ElementDisplayNode::Load() remove all children before (re)loading
			them.

			Added ElementDisplayNode::ChildInsertedBefore().

			Fixes to BetweenGlyphsDestination::MoveActionWithElements():
			"firstDestOffset" wasn't being set correctly when splitting the
			destination.

			Made TextDisplayNode::Load() clear any existing glyphs before creating
			the new ones.

			Had to rebuild the project from (unarchived) backup after it got
			corrupted.

			Much futzing around with virtual base classes, but I think I restore
			everything back to what it was.

			Moving glyphs-with-elements now sorta works, but it doesn't select
			correctly at the end, and there's a big crash on redo.  (1999.6.11.A)

			Got rid of some extra unnecessary steps in
			BetweenGlyphsDestination::MoveActionWithElements() that I added
			while debugging.

1999.6.9	Changed MoveCharsAction so it takes Texts rt BasicLiveTexts.

			Made Action a *public* superclass of RestoreGlyphsSelectionAction,
			which it wasn't before (stupid C++...).

			Added ElementDisplayNode::GetElement().

			Changed SelectGlyphsAction so it takes Texts rt BasicLiveTexts.

			Wrote BetweenGlyphsDestination::MoveActionWithElements() and made
			GetMoveAction() call it when appropriate.

			Changed TextDisplayNode::InlineFindDestination() so it doesn't reject
			embedded elements.  (Still need to validate, though.)

			Made SpaceDestination::GetMoveAction() check for embedded elements.

			Started testing the above, but more work needs to be done.  Specifically,
			adding a new node to an Element must trigger a Load.  (A)

1999.6.8	Added defaults for the last three args of the MoveCharsAction ctor, so it
			can be more easily used as if it were a more lightweight kind of action.

			Created NodeTypeList.

			Created Validator.

			Added IsLeafBlock() virtual method to DisplayNode, CompositeDisplayNode,
			GeneratedLeafBlock, and TextDisplayNode.

			Created DefaultValidator.  (A)

			Added validator to DisplayDirector.

			Changed DisplayDirector::DisplayNodeFor() so it takes a regular Node,
			instead of requiring a DOMLiveNode.  This should make some things easier;
			for instance, DefaultValidator::AllowsContents() was changed and made
			simpler.

			Moved Error from the "Utils" section to the "Cross-Platform" section.

			Made DisplayDirector::KeyDown() and MouseDown() catch and display
			exceptions.  (B)

			Created NewTextAction.

			Created MoveNodesAction.  (C)

1999.6.6	Added "nextAction" arguments to CanIncorporateNext() and IncorporateNext()
			methods of Action, AddCharsAction, and BackCharsAction.  Appropriate changes
			to DisplayDirector::DoAction().

			Created CompositeAction.  (A)

			Added DisplayDirector::GetSelection().

			Created RestoreGlyphsSelectionAction.  Neither this nor CompositeAction
			is tested yet.  (B)

			Created SelectGlyphsAction.

			Created DeleteCharsAction.

			Changes to BetweenGlyphsDestination::GetMoveAction() to handle
			"removePreSpace" and "removePostSpace".  Actually seems to work--
			cross your fingers.  (C)

1999.6.3	Added TextDisplayNode::GlyphBefore() and GlyphAfter().

			Added IsPunctuation() virtual method to Glyph, Word and SmartMDash,
			with an ivar and a ctor default arg in Word to support it.

			Rewrote TextDisplayNode::CreateGlyphs() somewhat so it's much clearer,
			and so it doesn't accumulate punctuation characters together into one
			Glyph.  (D)

			Added FirstGlyph() and LastGlyph() to GlyphsSelection.

			Added ShouldBindBefore() and ShouldBindAfter() virtual methods to
			Glyph and subclasses.

			More slight fixes to TextDisplayNode::CreateGlyphs(): '-' is part
			of a word, rt a punctuation, and '[' and ']' are punctuation.

			Added TextDisplayNode::GlyphAtOffset().

			Wrote SpaceDestination::GetMoveAction().

			Created MoveCharsAction.

			Enabled more of DisplayDirector::DragSelection().  (E)

			Wrote BetweenGlyphsDestination::GetMoveAction().

			Fixed some bugs in TestDisplayNode::InlineFindDestination().

			Fixed some bugs in MoveCharsAction::Do() and Undo().

			More work on BetweenGlyphsDestination::GetMoveAction(), but still
			need to implement "removePreSpace"/"removePostSpace".  I'm not doing
			this right away because I need to think about if I really want to
			do it in MoveCharsAction, or use CompositeAction.  (F)

1999.6.2	Added TextDisplayNode::TextOffset() and made OffsetOfGlyph() call it.
			So far TextOffset() just returns zero, but it'll change when I do the
			sentences stuff, which will require associating several TextDisplayNodes
			with one Text node.

			Created Destination and FindDestinationContext.

			Added BlockFindDestination() virtual method to BlockableDisplayNode
			and CompositeDisplayNode.

			Added InlineFindDestination() virtual method to InlineableDisplayNode,
			CompositeDisplayNode, and TextDisplayNode.

			Added GlyphsSelection::HasEmbeddedElement().

			Created InlineArrow.

			Added View::StrokeBezier().

			Created SpaceDestination and BetweenGlyphsDestination.

			Added DisplayDirector::SetDestination() and changed Draw() to draw
			the destination.  Enabled parts of DragSelection() which were commented
			out.

			Fixed up GlyphsHilite::Draw() so those glitches at the mid corners
			don't happen anymore.  (1999.6.3.A)

			Fixed TextDisplayNode::GlyphAtPoint() so it never selects a whitespace
			Glyph (it would do so at the end of a line before).  (1999.6.3.B)

			Better frame timing in DisplayDirector:  moved the lastScrollFrameTime
			timing code from DoScrollStep() to Draw(), with modifications so
			"lastScrollStepTime" is set/reset correctly, and to check if the whole
			document is being drawn; changed SetScrollTarget() so it no longer resets
			"lastScrollStepTime" to signal that timing can't take place this time
			(since maybe it can); gave ScrollMessageReceived() a refresh cycle, so
			drawing doesn't happen until the end and therefore there's an opportunity
			for DoScrollStep() to call ContinueScrolling() before it does.  This needs
			more work, though...it's not working right in FindSelection() or
			ExtendSelection(), or presumably anywhere there's a tracking loop.  I
			think I may need to break "scrollStepPending" into "scrollStepPending"
			and "scrollMessagePending". ... Okay, did that, and gave DoScrollStep()
			a refresh cycle so the frame rate is tracked while using the
			ScrollerControl.

			Put the MouseTrackingPause() call into DisplayDirector::ExtendSelection().

			Fixed ScrollerControl::MouseDown() so it uses View::MouseTrackingPause()
			instead of a Be-specific call.

			Reinstated calls to Autoscroll() in DisplayDirector::ExtendSelection()
			and DragSelection().  (1999.6.3.C)

1999.5.30	Filled in some of GlyphsSelection (so it uses a GlyphsHilite), added
			CharacterSelection::Promote(), and fixed a bug in GlyphsHilite::Draw(),
			which wasn't adding in the ascent when calculating the bottom of a
			one-line hilite.

			Created GlyphLoc.

			Added FirstSelectableGlyph() and LastSelectableGlyph() virtual methods to
			InlineableDisplayNode, TextDisplayNode, and CompositeDisplayNode.

			Wrote the forward-selecting half of GlyphsSelection::ExtendTo().

			Changed BetweenGlyphsSelection::Point() to work if both "firstGlyph"
			and "secondGlyph" are null.

			Changed TextDisplayNode::InlineFindSelection() so it doesn't return
			a selection at the end of the node if the mouse isn't in the node.
			When it did that, you couldn't select past the first TextDisplayNode
			in a leaf block.

			Added EndSelection() virtual method to DisplayNode, TextDisplayNode,
			and CompositeDisplayNode.  Made
			CompositeDisplayNode::FindSelectionInInlineChildren() call it.  (A)

			Wrote the backward-selecting half of GlyphsSelection::ExtendTo().  (B)

1999.5.22	Added CanSelectAcross() virtual method to InlineableDisplayNode,
			ElementDisplayNode, TextDisplayNode, DocumentDisplayNode, and
			GeneratedLeafBlock.

			Created GlyphRef.

			Added TextDisplayNode::CurFont().

			Created GlyphsSelection, but it's not anywhere near done yet.

			Created GlyphsHilite.

			Made Glyphs keep track of which line they're on.  Changes to Glyph and
			to InlineLayoutContext ctor, AddGlyph(), FinishCurGlyphs(), and NewLine().

			Added View::MovePenTo(CoordPoint).

			Created Shape and added View::StrokeShape().  (A)

1999.5.19	Renamed DOMWriter to XMLWriter.

			Made EnglishEditorWind::DispatchMessage() intercept command-keys and
			pass them on to the view, and made DisplayDirector::KeyDown() handle
			them.

			Added Save() virtual method to DocumentSource and XMLFileSource.

			Added DisplayDirector::Save(), and made KeyDown() call it.

			Fixed a bug in XMLWriter::WriteChildren(), which was calling NodeType()
			on "node" instead of "child".  Saving now works.  (1999.5.20.A)

			Had to rebuild the project after it became corrupted.  (1999.5.20.B)

			Created StatusControl.

			Added DisplayDirector::IsDirty().

			Added "statusControl" to DisplayDirector.  (1999.5.20.C)

			Created BasicLiveCDATASection, and added
			LiveXMLNodeFactory::MakeCDATASection() to create them.  IT'S REALLY
			WRONG, though...it should inherit from BasicCDATASection instead of
			BasicLiveText; we really need LiveText etc.

			Made DisplayDirector::DisplayNodeFor() handle CDATA sections.
			(1999.5.20.D)

1999.5.16	Changed XMLFileSource so the constructor takes the file's path, instead
			of a BFile.  Changed EnglishEditorApp::OpenFile() and
			DisplayDirector::InitStatics() accordingly.  Also made
			XMLFileSource::GetWindowTitle() work correctly.  (A)

			Created DOMWriter.

1999.5.14	Added "isIgnorableWhitespace" arg to BasicLiveText and
			MakeIgnorableWhitespace() method to LiveXMLNodeFactory.

			Changed ElementDisplayNode::Load() to skip ignorable whitespace
			Texts.  (A)

1999.5.10	Created SmartMDash.

			Rewrote TextDisplayNode::CreateGlyphs() somewhat so it no longer
			uses DOMSliceIter.  It seems faster--Constitution now opens in
			2.5 secs.  Oh well, that's the same as the old one.

			Changes to TextDisplayNode::CreateGlyphs() and AddGlyph() to smarten
			double-hyphens into m-dashes.

			Fixed BetweenGlyphsSelection::AcceptKey() to work when there is
			no "secondGlyph" (selecting at the end of a Text).

			Changes to TextDisplayNode::CreateGlyphs() so each punctuation
			character gets its own glyph, even when they are next to each other.
			You can't see the result of this yet, but when we get word selections
			it'll make a difference.  (1999.5.11.A)

1999.5.9	Made ElementDisplayNode::Load() check to make sure the cast to a
			DOMLiveNode succeeded before doing anything with it.  This fixes a
			crash on comments.  (1999.5.10.A)

1999.5.8	Fixed Font::CharIndexAtX() to return the *byte* index.  This fixes
			a bug with finding the selection point after a non-ASCII character.

			Added Keys::DelKey.

			Moved CharacterSelection::Clear() to PointSelection(), since it works
			the same for all PointSelections.

			Created BetweenGlyphsSelection and made
			TextDisplayNode::InlineFindSelection() and GetSelectionAtOffset() return
			it if appropriate.  Still need to handle backspace and delete keys.  (A)

			Added DeleteFrontAction() and DeleteBackAction() virtual methods to
			Glyph and its subclasses.

			Fixed Keys ctor, which wasn't setting up DelKey correctly.

			Changed BackCharsAction so the ctor takes an optional "numBytes"
			argument, and so "chars" is set in the ctor instead of in Do().
			Made Space::DeleteFrontAction() and DeleteBackAction() pass this
			argument in, so the entire space is deleted.

			Made CharacterAction::AcceptKey() handle the delete key.

			Changed BackCharsAction::CanIncorporateNext() and IncorporateNext()
			so forward deletes, not just backward deletes, are incorporated.
			Note that BackCharsAction is misnamed now; it deals with any delete
			via typing out of a PointSelection.  (B)

			Created BetweenWordsSelection, and made
			TextDisplayNode::InlineFindSelection() and GetSelectionAtOffset()
			return it.

			Fixed BetweenGlyphsSelection::Point() to work when "secondGlyph"
			is NULL.

			A minor change to TextDisplayNode::InlineFindSelection() so it
			skips zero-width Spaces at the beginning of a leaf block.  Did this
			by comparing "mouseX < glyphRight" instead of "mouseX <= glyphRight".  (C)

			Changed BetweenGlyphsSelection::Point() to prefer the end of the
			firstGlyph, in case it's a space at the end of a line.

			Changed TextDisplayNode::InlineFindSelection() return a
			BetweenWordsSelection if the mouse point is at the end of a line
			(or at the end of the block).

			Changed DisplayDirector::MouseDown() so clicking in the margins
			(but not in a control) is guaranteed to clear the selection.  (D)

			Fixed DisplayDirector ctor, which wasn't initializing "selection".  (E)

1999.5.6	Changed the application signature to use the (recommended) dot
			between my name and the app name, and added icons.

			Added Keys::EscKey.

			Added Undo() and Redo() methods and "sentinalAction" ivar to
			DisplayDirector, and made KeyDown() do undo/redo on the ESC key.

			Made NativeView::KeyDown() store the modifiers for CurModifiers().
			(1999.5.7.A)

			Added BackCharsAction, copying (with modifications) from EE1.

			Added UTF8Utils::IsFirstByte().

			Made CharacterSelection::AcceptKey() handle the backspace key
			by using BackCharsAction.

			Changed AddCharsAction::CanIncorporateNext() and IncorporateNext()
			so AddCharsAction can incorporate a BackCharsAction.  (1999.5.7.B)

1999.5.5	Added TextDisplayNode::ClearGlyphs() and made dtor call it.

			Wrote TextDisplayNode::ClearGlyphs() and CreateGlyphs().

			Added InlineableDisplayNode::EnclosingLeafBlock().

			Added DisplayDirector::RefreshDocAfter().

			Added BlockableDisplayNode::RefreshAfter().

			Created Action and AddCharsAction, copying them (with modifications)
			from EE1.

			Added DisplayDirector::DoAction() and associated ivars, copying them
			(with modifications) from EE1.

			Modified DisplayDirector::KeyDown() to pass the key to the selection
			when appropriate.

			Added TextDisplayNode::GetText().

			Added NumCharsInText() virtual method to Glyph and its subclasses,
			with appropriate changes to Space ctor.

			Added TextDisplayNode::OffsetOfGlyph().

			Wrote CharacterSelection::AcceptKey().

			Had to fix a DOMString bug; see "xML-DOM Classes".  Now rudimentary
			insertion works.

			Added TextDisplayNode::GetSelectionAtOffset() and changed GetText()
			to return BasicLiveText rt plain Text.

			Changed AddCharsAction to keep BasicLiveText rt plain Text, and made
			Do() move the selection point.

			Changed DisplayDirector::KeyDown() so it only scrolls on the spacebar
			if there's no selection.  (1999.5.6.A)

1999.5.3	Created Region.

			Added View::CurClicks() and CurModifiers(), with support in
			NativeView::MouseDown().

			Added StartRefreshCycle() and FinishRefreshCycle() to DisplayDirector.

			Changed FindSelectionContext so it's no longer a subclass of
			DisplayContext (it didn't need to keep the director).

			Extensive additions to DisplayDirector, notably changing MouseDown(),
			adding all selection-related methods, and adding several ancillary
			methods (eg. StartRefreshCycle(), DocToView(), etc.).  Mostly this
			all came from EE1.

			Fixed CompositeDisplayNode::GetChildTop(), which wasn't iterating
			correctly.

			Made DisplayDirector::Draw() draw the selection.

			Added Keys::UpArrowKey and DownArrowKey.

			Changed DisplayDirector::KeyDown() to handle up and down arrow keys.

			Fixed CompositeDisplayNode::GetChildTop(), which wasn't handling
			the space at the top of the child block correctly.

			Added DisplayDirector::Autoscroll() (from EE1) and reinstated
			FindSelection()'s call of it.

			Added View::MouseTrackingPause and made DisplayDirector::FindSelection()
			call it.

			Fixed a slight bug in DisplayDirector::FindSelection() which caused it
			never to consider the mouse unmoved.  (19990503A)


1999.4.29	Created Selection and PointSelection, mostly copying from EE1.

			Made all reporting methods of Font be const.

			Added View::SetPenSize().

			Added four-coord Rectangle ctor, and made all Rectangle ctors
			inline.

			Added GetChildTop() method to BlockableDisplayNode and
			CompositeDisplayNode and Top() to BlockableDisplayNode().

			Added Word::GetWord().

			Created PointSelection.

			Created UTF8Utils.

			Added Font::CharIndexAtX().

			Made TextDisplayNode::InlineFindSelection() return CharacterSelections.
			Now I just need to add selection support to DisplayDirector and
			test it all.  (19990430A)

1999.4.26	Created FindSelectionContext.

			Added BlockFindSelection() virtual method to BlockableDisplayNode and
			to CompositeDisplayNode, with a couple of private methods to handle it
			in the latter.

			Added GetX() and GetY() methods to Glyph.

			Added InlineFindSelection() virtual method to InlineableDisplayNode,
			CompositeDisplayNode, and TextDisplayNode.  The TextDisplayNode one
			isn't finished, and the CompositeDisplayNode one doesn't find selections
			between two nodes.  (19990427A)

1999.4.24	(Opening Constitution takes about 2.8 seconds.  After the rewrite of
			DOMString, it now takes 2.5 seconds.)

			Changed TextDisplayNode::CreateGlyphs() to use the new no-argument
			DOMString::erase().

			Added UpdateProperties() and BlockLayout() methods to DocumentDisplayNode.
			These do nothing but call the inherited versions, but this'll give
			better profiling results.

			Changes throughout Word since DOMString now does the string_storage
			thing.

			(Had to remake the CY project from the backup because it got corrupted.)
			(B)

1999.4.23	Removed Rectangle::Contains(int,int), since CW for some reason wouldn't
			then allow use of Contains(BPoint) without specifying BRect::Contains().
			Why the hell not?!?  Anyway, changed DisplayDirector::MouseDown(), which
			was the only thing using it.  Actually, Rectangle could just become a
			typedef now, but I haven't done that yet.

			Changed Control::CurAlpha() to check if the mouse is outside the window.  (B)

			In DisplayDirector::KeyDown(), made the space, home, and end keys work.
			(19990424A)

1999.4.22	Added GetHMargin() and GetVMargin() methods to DisplayDirector.

			Created CoordPoint.

			Added View::GetMousePoint(), SetDrawingMode(), and StrokeLine().

			Added Control::GetAlpha().

			Added DisplayDirector::GetScrollPos(), GetDocumentHeight(),
			GetVisibleProportion(), and WindowView().

			Created ScrollerControl, mostly copying it from EE1.

			Added the scroller control to DisplayDirector.

			Added MouseMoved() methods to View, NativeView, EnglishEditorView, and
			DisplayDirector.  NativeView's version discards all pending mouse-moved
			events to avoid queue poisoning.

			Fixed DisplayDirector::DoScrollStep(), which for some reason was
			clearing "scrollStepPending"...oh, I see why...

			Added DisplayDirector::ScrollMessageReceived(), making
			EnglishEditorView::MessageReceived() call it.  Finally, all the
			scrolling works!  (And I'm even seeing peaks of 20fps for Declaration!)  (A)

			Added LeftSpace() methods to BlockableDisplayNode and DocumentDisplayNode.
			Added "extraIndent" arg to InlineDrawContext ctor and made
			CompositeDisplayNode::DrawInlineChildren() pass it.  These changes make
			the "margin-left" property work for blocks.

			Fixed ScrollerControl::GetRect(), which wasn't centering the scroller
			correctly horizontally.

			Added Constitution and Change Log to the distribution.  (19990423A)

1999.4.20	(Declaration peaks at 19fps.)

			Changes to prevent drawing of text into the margin areas.  Changes to
			DisplayDirector::Draw(), GlyphDrawContext, TextDisplayNode::InlineDraw(),
			and Word::Draw().  (No impact on frame rate.)

			Added View::FillRect() and StrokeRect().  (A)

1999.4.18	Created Control and FrameRateControl.

			Added DisplayDirector::ViewBounds(), DrawingView(), LastScrollFrameTime(),
			LastDrawTime(), and LastBlitTime().

			Added Font::Normal.

			Added View::PushState(), PopState(), SetHighColor() and SetLowColor().

			Created Color.

			Added DisplayDirector::MouseDown() and made EEView::MouseDown() call it.

			Added the FrameRateControl to DisplayDirector (ctor, dtor, Draw(),
			MouseDown()).

			Changed Rectangle from a typedef to a subclass of BRect and added a
			new Contains() method (taking a point as two ints) and ctors.  (A)

			Added UpdateProperties() virtual methods to DisplayNode,
			CompositeDisplayNode, and TextDisplayNode.  TextDisplayNode now
			caches its font.  Made DisplayDirector ctor call UpdateProperties().
			This bought about 3fps.  (B)

			Made CompositeDisplayNode cache its top and bottom margins.  This
			bought another couple fps.  It's still about 5fps behind EE1.  (C)

			Instrumented CompositeDisplayNode::DrawChildBlocks() to see if the
			dynamic_cast was a big hit.  It sorta looked like it; replacing it
			with a call to new DisplayNode virtual method AsBlockableDisplayNode()
			definitely improved the time, but made little or no difference in the
			frame rate.  So I removed the changes, except I left
			AsBlockableDisplayNode() in just in case I wanna go for it later.

			Made BlockableDisplayNode::Height() inline.  Not sure if that bought
			anything; it was under 1 fps if so.

			Full optimization bought under 1 fps.

			Experimented with making "childBlock" in
			CompositeDisplayNode::DrawChildBlocks() be a CompositeDisplayNode
			(since all BlockableDisplayNodes are anyway) to get quicker access
			to "topMargin" and "bottomMargin", but it didn't really help.  Where
			is that time going that I'm seeing in the profile?  It's consistently
			showing that DrawInlineChildren is only taking a third of the time of
			DrawChildBlocks.  Hmm, and CompositeDisplayNode::InlineDraw() is always
			taking more than DrawInlineChildren(), even though the former is always
			called from within the latter.  Boosting the profiling stack depth didn't
			help.  Finally I think I know what's up: it double-counts time in
			recursive routines.  Reinterpreting the profile in that light, it now
			looks like Word::Draw() is the bottleneck.

			Tried cacheing the stopper iterator in Word::Draw(); it didn't have
			much effect.

			Experimentally tried just using the first string_slice in each word
			in Word::Draw().  This got a couple of fps (peaking at 16).  Two or three
			more fps will get us up to what EE1 was doing.  Having Word cache that
			slice didn't help much, unfortunately... I'd've known what do to if it had.
			Actually, trying the same test document in EE1, we're within 1 fps.
			I'm leaving the experimental stuff in for now.

			Rewrote Word to store the characters itself if the DOMString it's given
			has more than one slice.  Probably DOMString should do this instead--it's
			too clever by half the way it is.  But for now it was much easier to
			make Word do it.  16fps still.  And it looks like memory usage went down.
			Also of interest: not one word actually spilled over to a second slice.  (D)


4/17/99	Created Timing.

		Created Message, although it doesn't take any info other than the "what"
		yet.

		Added MessageReceived() methods to View and NativeView.

		Added View::Lock(), Unlock(), and Bounds().

		Extensive additions to DisplayDirector to support scrolling.  Most of
		the code was copied over from EE1 and adapted.

		Created Keys.

		Added DisplayDirector::KeyDown() and wrote EEView::KeyDown().

		More work on scrolling...now it works.  (A)

4/15/99	Changed name of BlockableDisplayNode::HeightChanged() to HeightChangedBy(),
		added HeightChangedTo(), and changed
		CompositeDisplayNode::LayoutInlineChildren() accordingly.

		Added TopMargin() and BottomMargin() methods to BlockableDisplayNode and
		CompositeDisplayNode.

		Changed CompositeDisplayNode::LayoutChildBlocks() and DrawChildBlocks()
		to handle inter-block spacing.

		Added "debugTagName" ivar to ElementDisplayNode, for debugging only.

		Changed DisplayNode::GetPropertyInPixels() so "inherited" no longer has a
		default (which was "true" before).  (19990416A)

4/14/99	Added IsWhitespace() methods to Glyph and Space.

		Extensive changes to InlineLayoutContext so it works better; this meant
		changing TextDisplayNode::InlineLayout() so it doesn't call NewLine() (this
		is now part of the semantics of AddGlyph()), and making
		CompositeDisplayNode::LayoutInlineChildren() call the new Finish() method.

		Fixed DisplayDirector::Draw(), which wasn't syncing the bitmap before
		blitting it onto the screen.

		Removed "haveGlyphs" ivar from InlineLayoutContext, and all references to
		it.  It's not used anymore.  (19990415A)

		Added "textIndent" ivar to InlineLayoutContext, made NewLine() use it, and
		made CompositeDisplayNode::LayoutInlineChildren() pass it in to the ctor.

		Fixed CompositeDisplayNode::CheckIfBlock() so it doesn't make
		GeneratedLeafBlocks for the children of a leaf block.

		Made GeneratedLeafBlock ctor set "isBlock" and "isLeafBlock", since
		CheckIfBlock() doesn't get called for GeneratedLeafBlocks.

		Added "haveStarted" ivar to InlineLayoutContext, and made FinishCurGlyphs()
		use and set it.  This prevents whitespace from indenting the first line in
		a block.  (B)

4/12/99	Changed the way View and NativeView are associated: View's constructor now
		takes a NativeView as its argument, then registers itself with the NativeView
		(using the new SetView() method).  Changed the EnglishEditorWind ctor
		accordingly.

		Completely changed the purpose and implementation of EnglishEditorView.  Now,
		instead of being a NativeView, it's a View that passes the hooks on to the
		associated DisplayDirector.

		Work on DisplayDirector::Draw().  It should actually be drawing now.

		Made DisplayDirector's ctor get the DocumentDisplayNode and save it in an
		ivar, moving the code from Draw().

		Made CompositeDisplayNode ctor initialize "firstChild" and "lastChild".

		Added Load() methods to DisplayNode, DocumentDisplayNode, ElementDisplayNode,
		and TextDisplayNode.  Took the CreateGlyphs() call out of TextDisplayNode's
		ctor, since it makes more sense to do this in the load phase.

		Made DisplayDirector ctor do the load phase.

		Fixed TextDisplayNode::CreateGlyphs(), which did a break from an inner loop
		when it wanted to exit the outer loop.

		Fixed GeneratedDisplayBlock::Width() so it would compile.

		Made CompositeDisplayNode::BlockLayout() call CheckIfBlock().  Is this
		the right place?  Probly not, we'll see when the margin controls are
		working.

		Fixed DOMEditStylesheet::PropertyForElement(), which was trying to use
		"attrValue" (instead of "attr") to initialize itself.

		Fixed EnglishEditorWind ctor to build an EnglishEditorView instead of a
		View.  Changed DisplayDirector so it knows its view is an EnglishEditorView.

		Added Bitmap::Lock() and Unlock(), and made DisplayDirector::Draw() call them.

		Fixed DisplayNode::GetFont() to inherit the font size.

		Fixed Word::Width(), which wasn't initializing the "width" variable.  At this
		point, it actually displays something (somthing wrong and it takes too long,
		but hooray)!  (19990413A)

		Fixed some bugs in TextDisplayNode::CreateGlyphs(), which wasn't resetting
		"glyphStart" and "glyphText" when it was supposed to.

		Fixed CompositeDisplayNode::CheckIfBlock(), which was using the wrong
		sense when testing if a child was a GeneratedLeafBlock.  It still doesn't
		work because CheckIfBlock() is happening at the wrong time.

		Deleted CheckIfBlock() call from CompositeDisplayNode::BlockLayout().  Added
		it to the Load() methods of DocumentDisplayNode and ElementDisplayNode.

		Made CompositeDisplayNode::DrawInlineChildren() update the BlockDrawContext's
		"curY".

		Made CompositeDisplayNode::LayoutInlineChildren() update the height.  (B)

		Made InlineLayoutContext::AddGlyph() and NewLine() update the "haveGlyphs"
		ivar.

		Fixed DisplayNode::GetInheritedProperty(), which was always getting the
		"font-family" property regardless of what was being asked for.  (C)

		Fixed the Font ctor, which wasn't calculating "face" correctly (it turns out
		B_REGULAR_FACE is *not* zero).

4/11/99	Created DocumentSource and XMLFileSource.

		Created OSException.  (B)

		Created NativeView and added Draw(), FrameResized(), KeyDown(), and MouseDown()
		methods to View.

		Changes to DisplayDirector so it really provides a stylesheet.  (C)

		Problem: NativeView creates its own View, but we need to have subclasses of
		View to override the hook functions.

		Created EnglishEditorView.

		Added NativeView::GetView().

		Added GetWindowTitle() method to DocumentSource and XMLFileSource.

		Added ScreenChanged() and CloseRequested() methods to DisplayDirector.

		Added the EnglishEditorWind file to the project (a copy of the one from EE1)
		and modified it to compile.  (D)

		Made DisplayDirector keep the DocumentSource, and changed EnglishEditorWind
		to pass it.

		Added Prefs().

		Added EnglishEditorApp and the NewDocWind stuff to the project (they were
		copied from EE1), with various quick changes to get them to compile.  It
		builds!

		Reenabled prefs stuff (which had been commented out) in EnglishEditorWind.  (E)

		Tweex to NewDocView to give Drew credit and change the rollover color.

		Fixed a bug in the XMLFileSource ctor, which wasn't interpreting the results
		for BFile::ReadAt() correctly.

		Created Error.

		Added Display() methods to InternalException() and OSException().

		Fixed a bug in DOMEditStylesheet ctor (classic = vs. == bug).  Now it puts
		up a window!  (Albeit an empty one.)  (F)

		Plugged a couple warnings now that warnings are on in the project (deleting
		of incomplete classes).

		Created DisplayableException and made InternalException and OSException
		subclasses of it.

		Made EnglishEditorApp::RefsReceived() catch exceptions.  (G)

4/10/99	Created Bitmap.

		Added View::GetColorSpace().

		Created Rectangle.

		Added View::ClearRect(), DrawBitmap(), and Sync().

		Added DisplayDirector::Draw().

		Added DOMLiveNode::GetChangeClient().

		Made DOMLiveNode a subclass of Node.

		Added DisplayDirector::DisplayNodeFor().

		Removed Height() virtual method from DisplayNode, since it's not meaningful
		for inline nodes.  A minor change to CompositeDisplayNode::DrawChildBlocks
		was needed to accomodate this.

		Added TextDisplayNode::GetDisplayType() and DeclaredDisplayType(), which
		were missing.  (19990411A)

4/2/99	Added DOMChangeClient::NodeDying() and DOMLiveNode destructor.

		Added TextDisplayNode::NodeDying().

		Created ElementDisplayNode and DocumentDisplayNode.

		Added DisplayNode::GetDisplayDirector.

		Added DisplayDirector::GetStylesheet(), although it doesn't work yet.  (B)

		Added "inherited" argument to DisplayNode::GetPropertyInPixels().

		Moved Width() pure virtual method from DisplayNode to BlockableDisplayNode.

		Added DisplayDirector::DisplayWidth(), although it doesn't work yet.

		Added DocumentDisplayNode::Width(), and wrote the new non-pure-virtual
		BlockableDisplayNode::Width().  (C)

		Added View::Width() and Height().

		Added "hMargin" and "vMargin" ivars to DisplayDirector and wrote the
		DisplayWidth() method.  (D)

4/1/99	Removed DisplayNode::Layout() virtual method and replaced it with
		BlockableDisplayNode::BlockLayout().  Appropriate changes to
		CompositeDisplayNode.

		A tad more work on DisplayDirector.

		Created BlockDrawContext and InlineDrawContext.

		Added BlockDraw() method to BlockableDisplayNode and CompositeDisplayNode.

		Added InlineDraw() method to InlineableDisplayNode and CompositeDisplayNode.

		Added DrawInlineChildren() and DrawChildBlocks() methods to
		CompositeDisplayNode.

		Added View::SetFont().

		Added TextDisplayNode::InlineDraw().  (19990402A)

3/30/99	Created Word and Space.

		Created View.

		Wrote TextDisplayNode::AddGlyph().  (033199A)

3/27/99	Created Font.

		Work on DisplayNode::GetProperty(), GetPropertyInPixels(), and new
		GetInheritedProperty() and GetFont() methods.  (A)

		Made Glyph::Width() take a Font argument.  Made InlineLayoutContext keep
		track of the font.  Appropriate changes to TextDisplayNode::InlineLayout().  (B)

		NOTE: The DisplayNode property stuff still doesn't work exactly right;
		not all pixel-valued properties should be inherited.

		Added Glyph::Draw().

3/26/99	Changed Glyph so it's no longer a subclass of DisplayNode, and added Width()
		virtual method.

		Changed CompositeDisplayNode so it keeps its list of children using their
		prev/next links.  Added UnlinkChildren(), LinkChildrenBefore(), and
		AppendChildren() methods.  (A)

		Added CompositeDisplayNode::FirstChild(), LastChild() and GetDisplayType().

		Created GeneratedLeafBlock.

		Finished writing (but not testing) CompositeDisplayNode::CheckIfBlock().  (B)

3/25/99	Wrote TextDisplayNode::InlineLayout().

		Added "isLeafBlock" ivar to CompositeDisplayNode and made Layout() method
		use it.

		Started writing CompositeDisplayNode::CheckIfBlock().  But it occurs to me
		that the approach is wrong...instead of having one GeneratedLeafBlock for
		each inline child node, we really need to combine runs of inline nodes into
		one GeneratedLeafBlock.  And it'd be a lot easier to splice these runs in
		and out of DisplayNode kept "prevSibling" and "nextSibling" ivars.  And then
		it might be better if Glyph weren't a subclass of DisplayNode, so Glyphs
		could be as lightweight as possible.  (A)

3/22/99	Added DisplayNode::GetProperty() method.

		Changed TextDisplayNode::CreateGlyphs() due to changes in DOMString.

		Created DisplayNode::GetPropertyInPixels(), but more needs to be done.
		Actually, I'm probably going about it all wrong... GetPropertyInPixels()
		should be the one to ask the parent; GetProperty shouldn't inherit....  (A)

3/21/99	Created InlineableDisplayNode and TextDisplayNode.

		Work on CompositeDisplayNode and InlineLayoutContext.  (A)

3/20/99	Created InlineLayoutContext and Glyph, but they need to be fleshed out.  (A)

3/19/99	Created BasicLiveText.

		Created LiveXMLNodeFactory.  (A)

3/10/99	Renamed EditFormat and DOMEditFormat to EditStylesheet and DOMEditStylesheet.
		Created DOMChangeClient mixin class.

		Created DOMLiveNode mixin class, and BasicLiveDocument, BasicLiveElement,
		BasicLiveAttr, and BasicLiveEntityReference.  (A)

		Changed PropertyForElement() method of EditStylesheet and DOMEditStylesheet
		to return DOMString instead of string_slice.  This is not what I really want,
		efficiency-wise, but it's more general and was the easy way to accomodate
		the changes to DOM.  (B)

3/9/99	Created MW project.  Initial creation of DisplayNode, BlockableDisplayNode,
		CompositeDisplayNode, EditFormat, DOMEditFormat, DisplayDirector, DisplayType,
		and DisplayContext.  Weird system crash before the backup made me fear for
		the CY project file, but it seems okay and I was able to do the backup.  (A)

3/5/99	Started project.  Copied EnglishEditorApp, EnglishEditorWind, and all
		NewDocWind classes from the old EE, but haven't even tried to make them
		compile yet.
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Notes"

Window should keep the bitmap, not the WindowDirector.  (So we can have multiple
[switching] WindowDirectors.)
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"App/Wind/View"
</name>
</class>


<class mod-time="Thu, 06 Apr 2000 00:43:30 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
EnglishEditorApp
</name>
<superclasses>
public BApplication, public StyleScriptable
</superclasses>
<hIncludes><![CDATA[
#include "StyleScriptable.h"
#include <Application.h>

class NewDocWind;
class EnglishEditorWind;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Prefs.h"
#include "EnglishEditorWind.h"
#include "IntroDocWind.h"
//*** #include "TextFileSource.h"
#include "XMLFileSource.h"
#include "MessageFileSource.h"
#include "IntroDocSource.h"
#include "System.h"
#include "Error.h"
#include "InternalException.h"
#include "InvalidXMLException.h"
#include "string_slice.h"
#include <FilePanel.h>
#include <Entry.h>
#include <File.h>
#include <Roster.h>
#include <Resources.h>
#include <Path.h>
#include <NodeInfo.h>

#if __profile__
#include "libprof.h"
#endif


int main(void)
{
#if __profile__
	PROFILE_INIT(200);
#endif

	EnglishEditorApp app;
	app.Run();

#if __profile__
	PROFILE_DUMP("/boot/Development/English Editor II/profile.dump");
#endif

	return 0;
}
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorApp()
	: BApplication("application/x-vnd.SteveFolta.EnglishEditorII"),
	  haveOpenedFiles(false), openFilePanel(NULL), newDocWind(NULL), introWind(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~EnglishEditorApp()
{
	delete Prefs();

	delete openFilePanel;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BApplication virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefsReceived(BMessage* message)
{
	// sanity clauses
	if (message == NULL)
		return;
	uint32 type;
	int32 count;
	message->GetInfo("refs", &type, &count);
	if ( type != B_REF_TYPE )
		return;

	// process the files
	for (long i = count - 1; i >= 0; i--) {
		// get the ref & make sure it's a file
		entry_ref ref;
		if (message->FindRef("refs", i, &ref) != B_OK )
			continue;
		BEntry entry;
		entry.SetTo(&ref);
		if (!entry.IsFile())
			continue;

		// create the file & project
		BFile* file = new BFile();
		if (file->SetTo(&ref, B_READ_WRITE) != B_OK) {
			delete file;
			continue;
			}
		try {
			OpenFile(file, &entry, message);
			haveOpenedFiles = true;
			}
		catch (DisplayableException& e) {
			e.Display();
			}
		catch (InvalidXMLException& e) {
			qstring msg = "Invalid XML, somewhere near:\n\n";
			string_slice text(e.Location(), e.Text().end());
			msg += text.substr(0, 30);
			Error::ShowError(msg);
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ReadyToRun()
{
	if (CountWindows() == 0)
		NewFile();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BResources* Resources()
{
	app_info info;
	if (GetAppInfo(&info) != B_OK)
		return NULL;
	BFile rsrcFile(&info.ref, B_READ_ONLY);
	if (rsrcFile.InitCheck() != B_OK)
		return NULL;
	BResources* rsrcs = new BResources();
	if (rsrcs->SetTo(&rsrcFile) != B_OK) {
		delete rsrcs;
		rsrcs = NULL;
		}
	return rsrcs;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void OpenFile(BFile* file, const BEntry* entry, BMessage* message = NULL)
{
	// get the file path
	BPath filePath(entry);
	// get the MIME type
	BNodeInfo nodeInfo(file);
	char mimeTypeStr[B_MIME_TYPE_LENGTH];
	nodeInfo.GetType(mimeTypeStr);
	string_slice mimeType(mimeTypeStr);
	// open a wind, using the correct DocumentSource as determined from the MIME type
	if (mimeType == "text/xml" || mimeType == "text/xhtml")
		new EnglishEditorWind(new XMLFileSource(filePath.Path()));
	else if (mimeType == "text/x-email" || mimeType == "text/x-news" || 
	         mimeType == "message/news") {
		new EnglishEditorWind(new MessageFileSource(filePath.Path()));
		}
	else if (mimeType.startsWith("text/"))
		new EnglishEditorWind(new XMLFileSource(filePath.Path()));
	else
		throw InternalException("Can't open file of that type.");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NewFile()
{
	if (introWind)
		introWind->Activate();
	else
		introWind = new IntroDocWind(new IntroDocSource());
/***
	if (newDocWind)
		newDocWind->Activate();
	else
		newDocWind = new NewDocWind();
***/
}
]]></method>

<method access="public" mod-time="Thu, 06 Apr 2000 00:43:30 PDT"><![CDATA[
void WindowClosing(BWindow* window)
{
	if (window == introWind)
		introWind = NULL;
	if (CountWindows() == 1) {	// last window
		Lock();
		Quit();
		Unlock();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"StyleScriptable virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString FunctionCall(DOMString function, DOMString arg, StyleScriptable* target)
{
	if (function == "NewDocument") {
		DOMString protoPath = System::AppDirectory();
		protoPath += "Prototype Documents/";
		protoPath += target->Eval(arg);
		new EnglishEditorWind(new XMLFileSource(protoPath, true));
		if (introWind)
			introWind->Close();
		return "";
		}
	else if (function == "NewMessage") {
		DOMString protoPath = System::AppDirectory();
		protoPath += "Prototype Documents/";
		protoPath += arg;
		new EnglishEditorWind(new MessageFileSource(protoPath, true));
		if (introWind)
			introWind->Close();
		return "";
		}
	else
		return StyleScriptable::FunctionCall(function, arg, target);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool haveOpenedFiles;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFilePanel* openFilePanel;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewDocWind* newDocWind;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorWind* introWind;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:42:12 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
EnglishEditorWind
</name>
<superclasses>
public BWindow
</superclasses>
<hIncludes><![CDATA[
#include "Rectangle.h"
#include <Window.h>

class EnglishEditorView;
class DocumentSource;
class WindowDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "EnglishEditorView.h"
#include "EnglishEditorApp.h"
#include "DocumentSource.h"
#include "WindowDirector.h"
#include "View.h"
#include "NativeView.h"
#include "Prefs.h"
#include "qstring.h"
#include <Screen.h>

static const BRect frameRect(40, 60, 620, 660);
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorWind(DocumentSource* docSource)
#ifdef USE_WINDOW_SCREEN
	: BWindowScreen(docSource->GetWindowTitle(), B_32_BIT_800x600, &openError)
#else
	: BWindow(frameRect, "", B_TITLED_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL, 0)
#endif
{
	// move to saved position
	BRect defaultFrame = Prefs()->GetRectPref("defaultWindFrame");
	if (defaultFrame.IsValid()) {
		MoveTo(defaultFrame.LeftTop());
		ResizeTo(defaultFrame.Width(), defaultFrame.Height());
		}

	// adjust size for screen
	BRect screenRect = BScreen(this).Frame();
	BRect frame = Frame();
	if (!screenRect.Contains(frame)) {
		float newWidth = frame.Width();
		if (frame.right > screenRect.right)
			newWidth = screenRect.right - screenMargin - frame.left;
		float newHeight = frame.Height();
		if (frame.bottom > screenRect.bottom)
			newHeight = screenRect.bottom - screenMargin - frame.top;
		ResizeTo(newWidth, newHeight);
		}

	Init(docSource);

	Show();
}
]]></method>

<method access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorWind()
	: BWindow(frameRect, "", B_TITLED_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL, 0)
{
	// for subclasses only
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Init(DocumentSource* docSource)
{
	// set the title
	qstring title(docSource->GetWindowTitle());
	SetTitle(title.c_str());

	// make the EnglishEditorView
	// do this *after* setting up the frame so it doesn't have to resize
	BRect editViewFrame = Frame();
	editViewFrame.OffsetTo(0, 0);
	NativeView* editView =
		new NativeView(editViewFrame, "EnglishEditorView", B_FOLLOW_ALL_SIDES,
		               B_WILL_DRAW | B_FRAME_EVENTS);
	AddChild(editView);
	editView->MakeFocus();

	// make the director
	director = new WindowDirector(docSource, new EnglishEditorView(editView), this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~EnglishEditorWind()
{
	((EnglishEditorApp*) be_app)->WindowClosing(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BWindow virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DispatchMessage(BMessage* message, BHandler* handler)
{
	bool passMessage = true;

	// take over most command-keys, passing them on to the director
	if (message->what == B_KEY_DOWN) {
		uint32 modifiers = message->FindInt32("modifiers");
		if ((modifiers & B_COMMAND_KEY) != 0) {
			int8 c;
			message->FindInt8("byte", &c);
			switch (c) {
				case 'w':
				case 'W':
				case 'q':
				case 'Q':
					// let BeOS handle these in the normal way
					break;

				default:
					// otherwise, pass it on to the view
					BView* eeView = FindView("EnglishEditorView");
					char keyBytes[4];
					int numBytes = 0;
					for (signed char* p = (signed char*) &keyBytes[0]; ; ++p, ++numBytes) {
						status_t result = message->FindInt8("byte", numBytes, p);
						if (result != B_NO_ERROR) {
							*p = 0;
							break;
							}
						
						}
					eeView->KeyDown(keyBytes, numBytes);
					break;
				}
			}
		}

/***
	if (message->what == B_KEY_DOWN) {
		// since we have no menus, we need to handle most command-keys ourselves
		uint32 modifiers = message->FindInt32("modifiers");
		if ((modifiers & B_COMMAND_KEY) != 0) {
			int8 c;
			message->FindInt8("byte", &c);
			switch (c) {
				case 's':
				case 'S':
					editView->Save();
					break;

				case 'n':
				case 'N':
					((EnglishEditorApp*) be_app)->NewFile();
					break;

				case 'i':
				case 'I':
					editView->ToggleFontStyle(ITALIC);
					break;

				case 'b':
				case 'B':
					editView->ToggleFontStyle(BOLD);
					break;
				}
			}
		}
***/

	if (passMessage)
		BWindow::DispatchMessage(message, handler);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScreenChanged(BRect frame, color_space mode)
{
	director->ScreenChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool QuitRequested()
{
	return director->CloseRequested();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameMoved(BPoint screenPoint)
{
	FrameChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(float width, float height)
{
//***	director->ScreenChanged();
	FrameChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RequestClose()
{
	PostMessage(B_QUIT_REQUESTED);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetFrame(Rectangle newFrame)
{
	MoveTo(newFrame.left, newFrame.top);
	ResizeTo(newFrame.Width(), newFrame.Height());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsOnlyDocumentWind()
{
	int numWindows = be_app->CountWindows();
	for (int i=0; i<numWindows; i++) {
		BWindow* wind = be_app->WindowAt(i);
		EnglishEditorWind* eeWind = dynamic_cast<EnglishEditorWind*>(wind);
		if (eeWind && eeWind != this)
			return false;
		}
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void FrameChanged()
{
	director->FrameChanged(Frame());
/***
	// only save the change if this is the only EnglishEditorWind up
	if (!IsOnlyDocumentWind())
		return;

	// save as pref
	Prefs()->SetRectPref("defaultWindFrame", Frame());
***/
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float screenMargin = 6;
]]></variable>

</class>


<class mod-time="Thu, 09 Mar 2000 21:56:17 PST" wind-frame="195.000000,95.000000,835.000000,625.000000" list-views-height="0.000000">
<name>
EnglishEditorView
</name>
<superclasses>
public View
</superclasses>
<hIncludes><![CDATA[
#include "View.h"

class WindowDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "Message.h"
#include "Messages.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorView(NativeView* nativeView)
	: View(nativeView), director(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"View virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(Rectangle updateRect)
{
	if (director == NULL)
		throw InternalException("Attempt to draw EEView without associated DisplayDirector!");
	director->Draw(updateRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(int x, int y)
{
	director->MouseDown(x, y);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KeyDown(string_slice key)
{
	director->KeyDown(key);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved(int transitType)
{
	director->MouseMoved();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(int newWidth, int newHeight)
{
	/***/
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 21:56:17 PST"><![CDATA[
void MessageReceived(Message* message)
{
	switch (message->What()) {
		case ScrollStepMessage:
			director->ScrollMessageReceived();
			break;

		default:
			View::MessageReceived(message);
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Connection to DisplayDirector"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetDirector(WindowDirector* newDirector)
{
	director = newDirector;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:46:14 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
IntroDocWind
</name>
<superclasses>
public EnglishEditorWind
</superclasses>
<hIncludes><![CDATA[
#include "EnglishEditorWind.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DocumentSource.h"
#include "WindowDirector.h"
#include "DocumentDisplayNode.h"
#include "Document.h"
#include <Screen.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:46:14 PST"><![CDATA[
IntroDocWind(DocumentSource* docSource)
{
	Init(docSource);
	director->KillControls();

	// resize to the width & height of the document
	int windWidth = (int) Bounds().Width();
	int windHeight = (int) Bounds().Height();
	DocumentDisplayNode* docDisplayNode =
		dynamic_cast<DocumentDisplayNode*>(director->DisplayNodeFor(docSource->GetDocument()));
	if (docDisplayNode) {
		int docWidth = docDisplayNode->MaxLineWidth();
		int docHeight = director->GetDocumentHeight();
		windWidth = docWidth + 2 * director->GetHMargin();
		windHeight = docHeight + 2 * director->GetVMargin();
		ResizeTo(windWidth, windHeight);
		docDisplayNode->BlockLayout(true);
		}

	// center on the screen
	BRect screenRect = BScreen(this).Frame();
	MoveTo((screenRect.Width() - windWidth) / 2,
	       (screenRect.Height() - windHeight) / 2);

	SetLook(B_MODAL_WINDOW_LOOK);
	Show();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"EnglishEditorWind virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameChanged()
{
	// do nothing--we don't want to save the size/position
}
]]></method>

</class>


<class mod-time="Sat, 03 Jun 2000 23:37:35 PDT" wind-frame="252.000000,117.000000,892.000000,647.000000" list-views-height="0.000000">
<name>
DisplayDirector
</name>
<superclasses>
public StyleScriptable
</superclasses>
<hIncludes><![CDATA[
#include "StyleScriptable.h"
#include "CoordPoint.h"
#include "Rectangle.h"
#include "DOMString.h"
#include "string_slice.h"

class DocumentSource;
class DocumentDisplayNode;
class View;
class EditStylesheet;
class Validator;
class Selection;
class Destination;
class Hotspot;
class DisplayNode;
class Node;
class Action;
class SelectionList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DocumentDisplayNode.h"
#include "ElementDisplayNode.h"
#include "TextDisplayNode.h"
#include "Document.h"
#include "Element.h"
#include "Text.h"
#include "XMLFileSource.h"
#include "Selection.h"
#include "Destination.h"
#include "Hotspot.h"
#include "Action.h"
#include "NullAction.h"
#include "FindSelectionContext.h"
#include "FindDestinationContext.h"
#include "FindHotspotContext.h"
#include "EnglishEditorApp.h"
#include "System.h"
#include "View.h"
#include "InternalException.h"
#include <vector>

class SelectionList : public vector<Selection*> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector(DocumentSource* docSourceIn)
	: docSource(docSourceIn), selection(NULL), destination(NULL), hotspot(NULL)
{
	// misc ivars
	deletedSelections = new SelectionList();
	sentinalAction = new NullAction();
	lastAction = sentinalAction;
	lastSaveAction = sentinalAction;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetupDisplayNodes()
	// to be called by any subclass' ctor, after the stylesheet is set up
{
	// find the document's DisplayNode
	docDisplayNode =
		dynamic_cast<DocumentDisplayNode*>(DisplayNodeFor(docSource->GetDocument()));
	if (docDisplayNode == NULL)
		throw InternalException("Couldn't get the DocumentDisplayNode!");

	// load
	docDisplayNode->Load(this);
	docDisplayNode->UpdateProperties();

	// layout
	docDisplayNode->BlockLayout();

	// notify the docSource (we do this *after* setting up the display nodes
	// so it will be able to set a selection, etc.)
	docSource->AttachedToDirector(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~DisplayDirector()
{
	if (lastAction)
		lastAction->DeleteAll();
	ClearDeletedSelections();
	delete deletedSelections;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* DisplayNodeFor(Node* nodeIn, bool create = true)
{
	Node* node = nodeIn;	/***/
	DisplayNode* existingNode = dynamic_cast<DisplayNode*>(node->GetChangeClient());
	if (existingNode)
		return existingNode;

	// doesn't exist yet, have to make one
	if (!create)
		return NULL;
	switch (node->NodeType()) {
		case DOCUMENT_NODE:
			return new DocumentDisplayNode(dynamic_cast<Document*>(node), this);
			break;

		case ELEMENT_NODE:
			return new ElementDisplayNode(dynamic_cast<Element*>(node));
			break;

		case TEXT_NODE:
		case CDATA_SECTION_NODE:
			return new TextDisplayNode(dynamic_cast<Text*>(node));
			break;
		}

	return NULL;
/***
	DOMLiveNode* node = dynamic_cast<DOMLiveNode*>(nodeIn);
	if (node == NULL)
		return NULL;

	DisplayNode* existingNode = dynamic_cast<DisplayNode*>(node->GetChangeClient());
	if (existingNode)
		return existingNode;

	// doesn't exist yet, have to make one
	if (!create)
		return NULL;
	switch (node->NodeType()) {
		case DOCUMENT_NODE:
			DocumentDisplayNode* newDocNode =
				new DocumentDisplayNode(dynamic_cast<LiveDocument*>(node), this);
			return newDocNode;
			break;

		case ELEMENT_NODE:
			ElementDisplayNode* newElementNode =
				new ElementDisplayNode(dynamic_cast<LiveElement*>(node));
			return newElementNode;
			break;

		case TEXT_NODE:
		case CDATA_SECTION_NODE:
			TextDisplayNode* newTextNode =
				new TextDisplayNode(dynamic_cast<LiveText*>(node));
			return newTextNode;
			break;
		}

	return NULL;
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(Rectangle updateRect) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void KeyDown(string_slice key) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MouseDown(int x, int y)
{
	CoordPoint mousePoint(x, y);
	View* view = WindowView();

	// hit the hotspot
	if (hotspot && hotspot->ContainsPoint(ViewToDoc(mousePoint)))
		hotspot->Clicked(this);

	// extend the selection
	else if ((view->CurModifiers() & ShiftModifier) != 0)
		ExtendSelection();

	// promote or drag the selection
	else if (selection && selection->ContainsPoint(ViewToDoc(mousePoint))) {
		if (view->CurClicks() > 1) {
			StartRefreshCycle();
			selection->Promote(this);
			FinishRefreshCycle();
			ExtendSelection();
			}
		else
			DragSelection(mousePoint);
		}

	// otherwise find a new selection
	else {
		if (DocRect().Contains(mousePoint))
			FindSelection();
		else
			SetSelection(NULL);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MouseMoved() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ScreenChanged() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DoDocAction(DOMString action)
{
	// default: ignore
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DocTypeChanged() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void RequestClose()
{
	// default: don't close
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:37:35 PDT"><![CDATA[
virtual void Paste()
{
	if (selection == NULL || !selection->CanPaste())
		return;

	StartRefreshCycle();

	String clipText = System::GetClipboardText();
	if (!clipText.empty())
		selection->Paste(clipText, this);

	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection/Destination/Hotspot"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetSelection(Selection* newSelection)
{
	StartRefreshCycle();
	if (selection) {
		RefreshDocRect(selection->Bounds());
		DeleteSelection(selection);
		}
	selection = newSelection;
	if (newSelection)
		RefreshDocRect(newSelection->Bounds());
	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FindSelection()
{
//***	be_app->HideCursor();
	View* view = WindowView();
	CoordPoint point;
	CoordPoint lastPoint(-1000000, -1000000);
	bool scrolling = false;
	for (;; lastPoint = point) {
		// get & check mouse state
		int buttons = view->GetMouseButtons();
		if (buttons == 0)
			break;
		point = view->GetMousePoint();
		bool autoscrolling = Autoscroll(point);
		if (point == lastPoint && !autoscrolling && !scrolling) {
			view->MouseTrackingPause();
			continue;
			}

		// move the selection
		StartRefreshCycle();
		CoordPoint docPoint = ViewToDoc(point);
		FindSelectionContext context(docPoint.x, docPoint.y);
		Selection* newSelection = docDisplayNode->BlockFindSelection(&context);
		SetSelection(newSelection);
		scrolling = DoScrollStep();
		FinishRefreshCycle();
		ClearDeletedSelections();
		}
//***	be_app->ShowCursor();	//*** didn't work
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ExtendSelection()
{
	if (selection == NULL)
		return;

	View* view = WindowView();
	CoordPoint lastPoint;
	Selection* rootSelection = selection;
	bool scrolling = false;
	while (true) {
		// get the mouse point and check if moved/finished
		int buttons = view->GetMouseButtons();
		if (buttons == 0)
			break;
		CoordPoint point = view->GetMousePoint();
		Autoscroll(point);
		point = ViewToDoc(point);
		if (point == lastPoint && !scrolling) {
			view->MouseTrackingPause();
			continue;
			}

		// change the selection
		Selection* newSelection = rootSelection->ExtendTo(point);
		if (newSelection != selection) {
			StartRefreshCycle();
			RefreshSelection();

			if (selection != rootSelection)
				delete selection;
			selection = newSelection;

			scrolling = DoScrollStep();

			RefreshSelection();
			FinishRefreshCycle();
			}

		lastPoint = point;
		}

	// clean up root selection
	if (selection != rootSelection)
		delete rootSelection;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DragSelection(CoordPoint startPoint)
{
	if (selection == NULL)
		return;

	View* view = WindowView();
	CoordPoint lastPoint = ViewToDoc(startPoint);
	bool scrolling = false;
	bool wasRightButton = false;
	bool optionDown = false;
	while (true) {
		// get the mouse point and check if moved/finished
		CoordPoint point = view->GetMousePoint();
		int buttons = view->GetMouseButtons();
		if (buttons == 0)
			break;
		wasRightButton = ((buttons & (SecondaryMouseButton | TertiaryMouseButton)) != 0);
		optionDown = ((view->CurModifiers() & OptionModifier) != 0);
		scrolling |= Autoscroll(point);
		point = ViewToDoc(point);
		if (point == lastPoint && !scrolling) {
			view->MouseTrackingPause();
			continue;
			}

		// change the destination
		Destination* newDestination = NULL;
		if (!selection->ContainsPoint(point)) {
			FindDestinationContext destContext(selection, point.x, point.y);
			newDestination = docDisplayNode->BlockFindDestination(&destContext);
			}
		if (newDestination != destination) {
			StartRefreshCycle();

			SetDestination(newDestination);

			scrolling = DoScrollStep();

			FinishRefreshCycle();
			}
		else
			scrolling = DoScrollStep();

		lastPoint = point;
		}

	// do the move/copy
	if (destination) {
		// figure out if it's a move or a copy
		bool doing = true;
		bool copying = false;
/***
		if (wasRightButton) {
			BPopUpMenu* menu = new BPopUpMenu("Move/Copy");
			BMenuItem* moveItem = new BMenuItem("Move", NULL);
			menu->AddItem(moveItem);
			BMenuItem* copyItem = new BMenuItem("Copy", NULL);
			menu->AddItem(copyItem);
			BMenuItem* chosenItem = menu->Go(ConvertToScreen(DocToView(lastPoint)), false, true);
			copying = (chosenItem == copyItem);
			if (chosenItem == NULL)
				doing = false;
			delete menu;
			}
		else if (optionDown)
			copying = true;
***/
		if (optionDown)
			copying = true;

		if (doing) {
			StartRefreshCycle();

			// do the move or copy
			Action* moveAction = NULL;
			if (copying)
				moveAction = destination->GetCopyAction();
			else
				moveAction = destination->GetMoveAction();
			if (moveAction)
				DoAction(moveAction);

			SetDestination(NULL);

			FinishRefreshCycle();
			}
		else
			SetDestination(NULL);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshSelection()
{
	// helpful for refreshing the selection before triggering a re-layout that moves it
	//** NOTE:  in many situations it's better to use SetSelection(NULL) instead
	if (selection)
		RefreshDocRect(selection->Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* GetSelection()
{
	return selection;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeleteSelection(Selection* deletedSelection)
{
	// deletion of selections is deferred, since selections often do things
	// that result in the selection being changed, which "deletes" the selection.
	// However, the selection may still need to exist to do other things.
	deletedSelections->push_back(deletedSelection);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ClearDeletedSelections()
{
	for (SelectionList::iterator s = deletedSelections->begin(); s != deletedSelections->end(); ++s)
		delete *s;
	deletedSelections->clear();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void CopyToClipboard()
{
	if (selection == NULL)
		return;

	DOMString xmlData = selection->GetXMLCopy();
	System::CopyToClipboard(xmlData, xmlData);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetDestination(Destination* newDestination)
{
	if (destination) {
		RefreshDocRect(destination->ArrowBounds());
		delete destination;
		}
	destination = newDestination;
	if (newDestination)
		RefreshDocRect(newDestination->ArrowBounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateHotspot(CoordPoint mousePoint)
{
	mousePoint = ViewToDoc(mousePoint);

	if (hotspot && hotspot->ContainsPoint(mousePoint))
		return;

	// find the hotspot
	delete hotspot;
	FindHotspotContext context(this, mousePoint.x, mousePoint.y);
	hotspot = docDisplayNode->BlockFindHotspot(&context);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Actions"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DoAction(Action* action)
{
	// do it
	action->Do(this);

	// put it in the undo list
	if (lastAction) {
		// kill undone actions and link new action into the list
		lastAction->DeleteRest();
		action->InsertAfter(lastAction);

		// incorporate into lastAction
		if (lastAction != lastSaveAction && lastAction->CanIncorporateNext(action)) {
			// incorporate
			lastAction->IncorporateNext(action);
			action->Unlink();
			delete action;

			// delete lastAction if it was nulled
			if (lastAction->IsNulled()) {
				Action* prevAction = lastAction->PrevAction();
				lastAction->Unlink();
				delete lastAction;
				lastAction = prevAction;
				}
			}
		else
			lastAction = action;
		}
	else
		lastAction = action;

	// scroll to the selection
	ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo()
{
	StartRefreshCycle();
	if (lastAction != sentinalAction) {
		lastAction->Undo(this);
		lastAction = lastAction->PrevAction();
		}
	FinishRefreshCycle();
	ClearDeletedSelections();
	ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Redo()
{
	StartRefreshCycle();
	Action* nextAction = lastAction->NextAction();
	if (nextAction) {
		nextAction->Do(this);
		lastAction = nextAction;
		}
	FinishRefreshCycle();
	ClearDeletedSelections();
	ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Save()
{
	docSource->Save();
	lastSaveAction = lastAction;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDirty()
{
	return (lastAction != lastSaveAction);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Scrolling"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool Autoscroll(CoordPoint point)
{
	// default: do nothing (scrolling not supported by default)
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ScrollToSelection()
{
	// default: do nothing (scrolling not supported by default)
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool DoScrollStep()		// true => still scrolling
{
	// default: do nothing (scrolling not supported by default)
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual EditStylesheet* GetStylesheet() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Validator* GetValidator() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int DisplayWidth() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual View* DrawingView() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual View* WindowView() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetDocumentHeight()
{
	return docDisplayNode->Height();
}
]]></method>

<method access="public" mod-time="Mon, 28 Feb 2000 00:03:03 PST"><![CDATA[
DocumentSource* GetDocSource()
{
	return docSource;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual CoordPoint ViewToDoc(CoordPoint viewPoint) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual CoordPoint DocToView(CoordPoint docPoint) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle ViewToDoc(Rectangle rect) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle DocToView(Rectangle rect) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle DocRect() = 0;
	// returns the visible document rectangle in View coords
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void StartRefreshCycle() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void FinishRefreshCycle() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void RefreshViewRect(Rectangle rect) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshDocRect(Rectangle rect)
{
	RefreshViewRect(DocToView(rect));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void RefreshDocAfter(int y) = 0;
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:40:32 PDT"><![CDATA[
virtual void RefreshAll() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"StyleScriptable virtuals"
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 21:49:25 PST"><![CDATA[
DOMString FunctionCall(DOMString function, DOMString arg, StyleScriptable* target)
{
	if (function == "actionAllowed") {
		bool result = false;
		arg = target->Eval(arg).trim();
		if (arg == "Save()")
			result = IsDirty();
		else if (arg == "Undo()")
			result = (lastAction != sentinalAction);
		else if (arg == "Redo()")
			result = (lastAction->NextAction() != NULL);
		else if (arg == "Copy()" || arg == "Cut()")
			result = (selection && selection->CanCopy());
		else if (arg == "Paste()")
			result = (selection && selection->CanPaste() && !System::GetClipboardText().empty());
		else if (arg.startsWith("doc-source.")) {
			arg = arg.substr(11, arg.length() - 11);
			return docSource->FunctionCall("actionAllowed", arg, target);
			}
		return (result ? "true" : "");
		}
	else if (function == "Undo")
		Undo();
	else if (function == "Redo")
		Redo();
	else if (function == "Save")
		Save();
	else if (function == "Copy")
		CopyToClipboard();
	else if (function == "Paste")
		Paste();
	else
		return StyleScriptable::FunctionCall(function, arg, target);

	return DOMString();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetScriptProperty(DOMString property)
{
	if (property == "doc-source")
		return docSource->AsString();
	else if (property == "app")
		return System::GetApplication()->AsString();
	else
		return StyleScriptable::GetScriptProperty(property);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" General"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DocumentSource* docSource;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DocumentDisplayNode* docDisplayNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* selection;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectionList* deletedSelections;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* destination;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* hotspot;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" Actions"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* lastAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* sentinalAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* lastSaveAction;
]]></variable>

</class>


<class mod-time="Thu, 20 Apr 2000 00:40:32 PDT" wind-frame="85.000000,60.000000,725.000000,590.000000" list-views-height="0.000000">
<name>
WindowDirector
</name>
<superclasses>
public DisplayDirector
</superclasses>
<hIncludes><![CDATA[
#include "DisplayDirector.h"
#include "Region.h"
#include "Timing.h"

class EnglishEditorView;
class EnglishEditorWind;
class Bitmap;
class ScrollerControl;
class StatusControl;
class MenuControl;
class HMarginControl;
class VMarginControl;
class FrameRateControl;
class MenuDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "EnglishEditorView.h"
#include "EnglishEditorWind.h"
#include "Bitmap.h"
#include "DocumentSource.h"
#include "Document.h"
#include "Element.h"
#include "DocumentDisplayNode.h"
#include "Selection.h"
#include "Destination.h"
#include "Hotspot.h"
#include "DOMEditStylesheet.h"
#include "CompositeStylesheet.h"
#include "DefaultValidator.h"
#include "MenuDirector.h"
#include "BlockDrawContext.h"
#include "ScrollerControl.h"
#include "StatusControl.h"
#include "MenuControl.h"
#include "HMarginControl.h"
#include "VMarginControl.h"
#include "FrameRateControl.h"
#include "XMLFileSource.h"
#include "Confirmer.h"
#include "Region.h"
#include "Message.h"
#include "System.h"
#include "Messages.h"
#include "Keys.h"
#include "Prefs.h"
#include "qstring.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector(DocumentSource* docSourceIn, EnglishEditorView* viewIn,
               EnglishEditorWind* windIn)
	: DisplayDirector(docSourceIn), view(viewIn), wind(windIn),
	  hMargin(DefaultHMargin), vMargin(DefaultVMargin), menu(NULL),
	  scrollPos(0), scrollTarget(0), curAnimatedScrollPos(0),
	  scrollStepPending(false), scrollMessagePending(false),
	  refreshCycleNesting(0), refreshRegion(NULL),
	  lastScrollFrameTime(0), lastScrollStepTime(0), lastDrawTime(0), lastBlitTime(0)
{
	// stylesheet & validator
	Document* documentNode = docSource->GetDocument();
	stylesheet = new CompositeStylesheet(documentNode->DocumentElement()->TagName());
	validator = new DefaultValidator(this);

	// install into the view
	view->SetDirector(this);

	// make the bitmap
	bitmap = new Bitmap(view->Width(), view->Height(), view->GetColorSpace());

	// controls
	scrollerControl = new ScrollerControl(this);
	statusControl = new StatusControl(this);
	menuControl = new MenuControl(this);
	hMarginControl = new HMarginControl(this);
	vMarginControl = new VMarginControl(this);
	frameRateControl = new FrameRateControl(this);

	// get the default margins
	int hMarginPref = Prefs()->GetInt32Pref("h-margin");
	if (hMarginPref > 0)
		hMargin = hMarginPref;
	int vMarginPref = Prefs()->GetInt32Pref("v-margin");
	if (vMarginPref > 0)
		vMargin = vMarginPref;

	// restore the window position
	Rectangle frame = wind->Frame();
	Element* docElement = documentNode->DocumentElement();
	if (docElement) {
		// window frame
		DOMString attr = docElement->GetAttribute("ee2:wind-left");
		if (!attr.empty())
			frame.left = string_slice(attr).asInt();
		attr = docElement->GetAttribute("ee2:wind-top");
		if (!attr.empty())
			frame.top = string_slice(attr).asInt();
		attr = docElement->GetAttribute("ee2:wind-width");
		if (!attr.empty())
			frame.right = frame.left + string_slice(attr).asInt();
		attr = docElement->GetAttribute("ee2:wind-height");
		if (!attr.empty())
			frame.bottom = frame.top + string_slice(attr).asInt();
		wind->SetFrame(frame);

		// margins
		attr = docElement->GetAttribute("ee2:h-margin");
		if (!attr.empty())
			hMargin = string_slice(attr).asInt();
		attr = docElement->GetAttribute("ee2:v-margin");
		if (!attr.empty())
			vMargin = string_slice(attr).asInt();
		}

	SetupDisplayNodes();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~WindowDirector()
{
	delete docSource;
	delete menu;

	delete bitmap;

	delete validator;
	delete stylesheet;

	// controls
	delete scrollerControl;
	delete statusControl;
	delete menuControl;
	delete hMarginControl;
	delete vMarginControl;
	delete frameRateControl;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(Rectangle updateRect)
{
	Microseconds startTime = Timing::SystemTime();

	CoordPoint origin = DocToView(CoordPoint(0, 0));

	// calculate the visible page (in document coordinates)
	Rectangle pageRect = view->Bounds();
	pageRect.InsetBy(hMargin, vMargin);
	bool drawingWholeDoc = updateRect.Contains(pageRect);
	pageRect.OffsetBy(-hMargin, -vMargin + scrollPos);

	// draw document into the offscreen bitmap
	bitmap->Lock();
	View* bitmapView = bitmap->GetView();
	bitmapView->ClearRect(updateRect);
	int vOrigin = vMargin - scrollPos;
	BlockDrawContext
		drawContext(this, bitmapView, hMargin, vOrigin,
		            pageRect.top, pageRect.bottom);
	docDisplayNode->BlockDraw(&drawContext);

	// draw selection
	if (selection && selection->IsVisible(pageRect)) {
		bool needsClip = selection->NeedsClip();
		if (needsClip) {
			bitmapView->PushState();
			Rectangle clipRect = DocToView(pageRect);
			// don't clip top if scrolled to top, or bottom if scrolled to bottom
			if (scrollPos == 0)
				clipRect.top = view->Bounds().top;
			else if (scrollPos == LastScrollPos())
				clipRect.bottom = view->Bounds().bottom;
			clipRect.left = view->Bounds().left;
			clipRect.right = view->Bounds().right;
			Region clipRgn;
			clipRgn.Include(clipRect);
			bitmapView->ConstrainClippingRegion(&clipRgn);
			}

		selection->Draw(bitmapView, origin);

		if (needsClip)
			bitmapView->PopState();
		}

	// draw destination
	if (destination)
		destination->DrawArrow(bitmapView, origin);

	// draw hotspot
	if (hotspot)
		hotspot->Draw(bitmapView, origin);

	// draw controls
	if (scrollerControl)
		scrollerControl->Draw(this);
	if (frameRateControl)
		frameRateControl->Draw(this);
	if (menuControl)
		menuControl->Draw(this);
	if (hMarginControl)
		hMarginControl->Draw(this);
	if (vMarginControl)
		vMarginControl->Draw(this);
	if (statusControl)
		statusControl->Draw(this);

	// draw menu
	if (menu)
		menu->Draw(updateRect);

/***
	// TEST: draw border
	Rectangle borderRect = view->Bounds();
	borderRect.InsetBy(hMargin, vMargin);
	bitmap->GetView()->StrokeRect(borderRect);
***/

	// sync
	bitmapView->Sync();

	// finish timing draw
	Microseconds curTime = Timing::SystemTime();
	lastDrawTime = curTime - startTime;

	// copy to the screen
	view->DrawBitmap(bitmap, updateRect);
	view->Sync();
	bitmap->Unlock();

	// finish timing blit
	lastBlitTime = Timing::SystemTime() - curTime;

	// time the frame rate
	Microseconds now = Timing::SystemTime();
	if (lastScrollStepTime != 0 && drawingWholeDoc)
		lastScrollFrameTime = now - lastScrollStepTime;
	lastScrollStepTime = (scrollStepPending ? now : 0);
}
]]></method>

<method access="public" mod-time="Thu, 06 Apr 2000 01:25:21 PDT"><![CDATA[
void KeyDown(string_slice key)
{
	static const string_slice spaceKey = " ";

	try {

	// give the selection a shot at special keys
	if (selection && selection->HandleSpecialKey(key, this)) {
		// don't do anything else
		}

	// scrolling keys
	else if (key == Keys::PageUpKey)
		SetScrollTarget(scrollTarget - (view->Height() - 2*vMargin - PageScrollOverlap));
	else if (key == spaceKey && selection == NULL) {
		if (docSource->CanCloseOnSpacebar() && scrollPos == LastScrollPos())
			wind->RequestClose();
		else
			SetScrollTarget(scrollTarget + (view->Height() - 2*vMargin - PageScrollOverlap));
		}
	else if (key == Keys::PageDownKey)
		SetScrollTarget(scrollTarget + (view->Height() - 2*vMargin - PageScrollOverlap));
	else if (key == Keys::HomeKey)
		SetScrollTarget(-0.5 * GetDocumentHeight());
	else if (key == Keys::EndKey)
		SetScrollTarget(GetDocumentHeight() * 1.5);
	else if (key == Keys::UpArrowKey)
		SetScrollTarget(scrollTarget - ArrowScrollAmount);
	else if (key == Keys::DownArrowKey)
		SetScrollTarget(scrollTarget + ArrowScrollAmount);

	// ESC => undo/redo
	else if (key == Keys::EscKey) {
		if ((view->CurModifiers() & ShiftModifier) != 0)
			Redo();
		else
			Undo();
		}

	// command keys
	else if ((view->CurModifiers() & CommandModifier) != 0) {
		switch (*key.begin()) {
			case 's':
			case 'S':
				Save();
				break;

			case 'z':
			case 'Z':
				if ((view->CurModifiers() & ShiftModifier) != 0)
					Redo();
				else
					Undo();
				break;

			case 'c':
			case 'C':
				CopyToClipboard();
				break;

			default:
				// give the menu a whack at it
				{
				DocumentSource* menuDocSource = docSource->MakeMenuDocSource();
				if (menuDocSource == NULL)
					break;
				DOMString keyName = MenuDirector::MakeKeyName(key, view->CurModifiers());
				Element* menuDocElement =
					menuDocSource->GetDocument()->DocumentElement();
				DOMString action =
					MenuDirector::FindKeyActionIn(keyName, menuDocElement).detach();
				delete menuDocSource;
				if (!action.empty())
					DoDocAction(action);
				}
				break;
			}
		}

	// let the selection have it
	else if (selection) {
		StartRefreshCycle();
		selection->AcceptKey(key, this);
		FinishRefreshCycle();
		ClearDeletedSelections();
		}

	} catch (DisplayableException& e) {
		e.Display();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(int x, int y)
{
	try {

	CoordPoint mousePoint(x, y);

	// menu
	if (menu) {
		if (menu->DocRect().Contains(mousePoint)) {
			menu->MouseDown(x, y);
			return;
			}
		else if (!menuControl->GetRect().Contains(mousePoint)) {
			// sorta a hack--menuControl is just gonna re-show the menu if 
			// we hide it now; just let it hide it
			HideMenu();
			}
		}

	// controls get it first
	if (scrollerControl && scrollerControl->GetRect().Contains(mousePoint))
		scrollerControl->MouseDown(x, y, this);
	else if (menuControl && menuControl->GetRect().Contains(mousePoint))
		menuControl->MouseDown(x, y, this);
	else if (hMarginControl && hMarginControl->GetRect().Contains(mousePoint))
		hMarginControl->MouseDown(x, y, this);
	else if (vMarginControl && vMarginControl->GetRect().Contains(mousePoint))
		vMarginControl->MouseDown(x, y, this);
	else if (frameRateControl && frameRateControl->GetRect().Contains(mousePoint))
		frameRateControl->MouseDown(x, y, this);

	// hotspot & selection handling
	else
		DisplayDirector::MouseDown(x, y);

	} catch (DisplayableException& e) {
		e.Display();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved()
{
	UpdateHotspot(view->GetMousePoint());
	if (menu)
		menu->MouseMoved();

	// update the display, scrolling if necessary
	if (scrollTarget != scrollPos)
		DoScrollStep();
	else
		Draw(view->Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameChanged(Rectangle newFrame)
{
	// record the change in the document
	Element* docElement = docSource->GetDocument()->DocumentElement();
	docElement->SetAttribute("xmlns:ee2", "http://folta.net/steve/EnglishEditorII");
	docElement->SetAttribute("ee2:wind-left", DOMString(newFrame.left));
	docElement->SetAttribute("ee2:wind-top", DOMString(newFrame.top));
	docElement->SetAttribute("ee2:wind-width", DOMString(newFrame.Width()));
	docElement->SetAttribute("ee2:wind-height", DOMString(newFrame.Height()));
	docElement->SetAttribute("ee2:h-margin", DOMString(hMargin));
	docElement->SetAttribute("ee2:v-margin", DOMString(vMargin));

	// size might have changed, so update bitmap
	ScreenChanged();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScreenChanged()
{
	// get the vital stats
	bitmap->Lock();
	View* bitmapView = bitmap->GetView();
	long newColorSpace = view->GetColorSpace();
	long oldColorSpace = bitmap->GetColorSpace();
	int oldWidth = bitmapView->Width();
	int newWidth = view->Width();
	int oldHeight = bitmapView->Height();
	int newHeight = view->Height();
	bitmap->Unlock();

	// if nothing's changed, kick out
	if (newColorSpace == oldColorSpace && newWidth == oldWidth && newHeight == oldHeight)
		return;

	// rebuild the bitmap
	int maxWidth = oldWidth;
	if (newWidth > maxWidth)
		maxWidth = newWidth;
	int maxHeight = oldHeight;
	if (newHeight > maxHeight)
		maxHeight = newHeight;
	delete bitmap;
	bitmap = new Bitmap(maxWidth, maxHeight, newColorSpace);

	// relayout
	if (newWidth != oldWidth)
		docDisplayNode->BlockLayout(true);

	// refresh
	RefreshViewRect(view->Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CloseRequested()
{
	if (!IsDirty())
		return true;

	// confirm close without saving
	qstring prompt = "\"";
	prompt += docSource->GetWindowTitle();
	prompt += "\" has unsaved changes.  Close it anyway?";
	int choice = Confirmer::Confirm(prompt.c_str(), "Cancel", "Don’t Save", "Save");
	if (choice == 2)
		Save();
	return (choice != 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DoDocAction(DOMString action)
{
	HideMenu();

	Eval(action);
/***
	if (action == "Undo()")
		Undo();
	else if (action == "Redo()")
		Redo();
	else if (action == "Save()")
		Save();
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DocTypeChanged()
{
	// stylesheet & validator
	Document* documentNode = docSource->GetDocument();
	delete stylesheet;
	delete validator;
	stylesheet = new CompositeStylesheet(documentNode->DocumentElement()->TagName());
	validator = new DefaultValidator(this);

	// update display
	// find the document's DisplayNode
	docDisplayNode =
		dynamic_cast<DocumentDisplayNode*>(DisplayNodeFor(docSource->GetDocument()));
	if (docDisplayNode == NULL)
		throw InternalException("WindowDirector::DocTypeChanged: Couldn't get the DocumentDisplayNode!");
	// load
	docDisplayNode->Load(this);
	docDisplayNode->UpdateProperties();
	// layout
	docDisplayNode->BlockLayout();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RequestClose()
{
	wind->RequestClose();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KillControls()
{
	delete scrollerControl;
	scrollerControl = NULL;
	delete statusControl;
	statusControl = NULL;
	delete menuControl;
	menuControl = NULL;
	delete hMarginControl;
	hMarginControl = NULL;
	delete vMarginControl;
	vMarginControl = NULL;
	delete frameRateControl;
	frameRateControl = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Scrolling"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:50:49 PST"><![CDATA[
void SetScrollTarget(float newScrollTarget)		// *must* be called prior to any DoScrollStep() cycle
{
	scrollTarget = (int) newScrollTarget;

	// take this call as the signal that scrolling is about to start...
	// set up scrolling internals
	curAnimatedScrollPos = scrollPos;
//***	lastScrollStepTime = 0;		// signal timing mechanism that last cycle is done
	// start scroll messages
	ContinueScrolling();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool Autoscroll(CoordPoint point)
{
	static const float AutoscrollMultiplier = 5;

	Rectangle pageRect = view->Bounds();
	pageRect.InsetBy(hMargin, vMargin);

	// up
	if (point.y < pageRect.top)
		SetScrollTarget(scrollPos - (pageRect.top - point.y) * AutoscrollMultiplier);

	// down
	else if (point.y > pageRect.bottom)
		SetScrollTarget(scrollPos + (point.y - pageRect.bottom) * AutoscrollMultiplier);

	else
		return false;

	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScrollToSelection()
{
	if (selection == NULL)
		return;

	// if the selection is visible, don't scroll
	Rectangle visibleRect = ViewToDoc(DocRect());
	if (selection->IsVisible(visibleRect))
		return;

	// need to scroll
	// if the selection fits on the screen, scroll it to the middle
	Rectangle selectionRect = selection->Bounds();
	if (selectionRect.Height() <= visibleRect.Height())
		SetScrollTarget((selectionRect.top + selectionRect.bottom - visibleRect.Height()) / 2);
	// otherwise, scroll to the top of the selection
	else
		SetScrollTarget(selectionRect.top);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool DoScrollStep()		// true => still scrolling
{
	static const float CloseEnough = 1;
	static const float MinScrollAmount = 0.5;	// was 0.5, then 1

	static const float XenoFactorPerSecond = 0.8;

	scrollStepPending = false;

	if (scrollPos == scrollTarget)
		return false;

	StartRefreshCycle();

//***	Microseconds startTime = Timing::SystemTime();

	// go a fraction of the distance
	bool scrolling = true;
	float newScrollPos, scrollAmount;
	float frameRate = (lastScrollFrameTime ? 1000000.0/lastScrollFrameTime : 1000000.0/lastDrawTime);
	if (scrollTarget < curAnimatedScrollPos) {
		// up
		newScrollPos = scrollTarget -
			(scrollTarget - curAnimatedScrollPos) * pow((1 - XenoFactorPerSecond), 1 / frameRate);
		scrollAmount = curAnimatedScrollPos - newScrollPos;
		if (scrollAmount < MinScrollAmount)
			newScrollPos = curAnimatedScrollPos - MinScrollAmount;
		if (newScrollPos - scrollTarget <= CloseEnough) {
			newScrollPos = scrollTarget;
			scrolling = false;
			}
		}
	else {
		// t - (t-y)( (1-z)^(1/f) )
		newScrollPos = scrollTarget -
			(scrollTarget - curAnimatedScrollPos) * pow((1 - XenoFactorPerSecond), 1 / frameRate);
		scrollAmount = newScrollPos - curAnimatedScrollPos;
		if (scrollAmount < MinScrollAmount)
			newScrollPos = curAnimatedScrollPos + MinScrollAmount;
		if (scrollTarget - newScrollPos <= CloseEnough) {
			newScrollPos = scrollTarget;
			scrolling = false;
			}
		}
	ScrollDocumentTo(floor(newScrollPos + 0.5));
	curAnimatedScrollPos = newScrollPos;
	if (scrollPos == 0 || scrollPos == LastScrollPos())
		scrolling = false;
	if (!scrolling)
		scrollTarget = scrollPos;
	else
		ContinueScrolling();

	FinishRefreshCycle();

/***
	// time the frame rate
	Microseconds now = Timing::SystemTime();
	if (lastScrollStepTime != 0)
		lastScrollFrameTime = now - lastScrollStepTime;
	lastScrollStepTime = now;
***/

	return scrolling;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:51:16 PST"><![CDATA[
void ContinueScrolling()
{
	// sometimes (eg. during operation of the ScrollerControl) the scrolling happens in
	// a loop before returning the message queue handing.  In that case, if we send a
	// scroll-continuation message every time, we end up "poisoning" our response as the
	// queue fills up (and the GetMouse(..., true) call takes longer and longer to look
	// through the queue?).  Avoid this by making sure we don't send a second scroll-continuation
	// message if there's already in the queue.
	if (!scrollMessagePending) {
		Message scrollStepMessage(ScrollStepMessage);
		view->SendMessage(&scrollStepMessage);
		scrollMessagePending = true;
		}
	scrollStepPending = true;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:51:51 PST"><![CDATA[
void ScrollDocumentTo(int newScrollPos)
{
	// scroll, pinning to beginning and end
//***	StartRefreshCycle();
	scrollPos = newScrollPos;
	if (scrollPos < 0)
		scrollPos = 0;
	else {
		float scrollStop = docDisplayNode->Height() - (view->Height() - 2 * vMargin);
		if (scrollStop < 0)
			scrollStop = 0;
		if (scrollPos > scrollStop)
			scrollPos = (int) scrollStop;
		}
	RefreshViewRect(view->Bounds());
//***	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScrollMessageReceived()
{
	StartRefreshCycle();
	scrollMessagePending = false;
	DoScrollStep();
	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:51:55 PST"><![CDATA[
int LastScrollPos()
{
	float lastScrollPos = docDisplayNode->Height() - (view->Height() - 2 * vMargin);
	if (lastScrollPos < 0)
		lastScrollPos = 0;
	return (int) lastScrollPos;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Actions"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	StartRefreshCycle();

	DisplayDirector::Save();
	RefreshViewRect(statusControl->GetRect());

	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Menu"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ShowMenu()
{
	if (menu)
		return;

	DocumentSource* menuDocSource = docSource->MakeMenuDocSource();
	if (menuDocSource == NULL)
		return;

	StartRefreshCycle();

	Rectangle menuControlRect = menuControl->GetRect();
	CoordPoint stemPoint((menuControlRect.left + menuControlRect.right) / 2,
	                     menuControlRect.bottom);
	menu = new MenuDirector(menuDocSource, stemPoint, this);

	RefreshViewRect(menu->Bounds());
	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HideMenu()
{
	if (menu == NULL)
		return;

	StartRefreshCycle();
	RefreshViewRect(menu->Bounds());

	delete menu;
	menu = NULL;

	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool MenuIsVisible()
{
	return (menu != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Margins"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetHMargin()
{
	return hMargin;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetHMargin(int newHMargin)
{
	hMargin = newHMargin;
	docDisplayNode->BlockLayout(true);
	RefreshViewRect(ViewBounds());

	// record the change
	Element* docElement = docSource->GetDocument()->DocumentElement();
	docElement->SetAttribute("ee2:h-margin", DOMString(hMargin));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetVMargin()
{
	return vMargin;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetVMargin(int newVMargin)
{
	vMargin = newVMargin;
	RefreshViewRect(ViewBounds());

	// record the change
	Element* docElement = docSource->GetDocument()->DocumentElement();
	docElement->SetAttribute("ee2:v-margin", DOMString(vMargin));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* GetStylesheet()
{
	return stylesheet;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Validator* GetValidator()
{
	return validator;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayWidth()
{
	return view->Width() - 2 * hMargin;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ViewBounds()
{
	return view->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* DrawingView()
{
	return bitmap->GetView();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* WindowView()
{
	return view;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds LastScrollFrameTime()
{
	return lastScrollFrameTime;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds LastDrawTime()
{
	return lastDrawTime;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds LastBlitTime()
{
	return lastBlitTime;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetScrollPos()
{
	return scrollPos;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float GetVisibleProportion()
{
	float proportion =
		(view->Bounds().Height() - 2 * vMargin) / docDisplayNode->Height();
	if (proportion > 1.0)
		proportion = 1.0;
	return proportion;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint ViewToDoc(CoordPoint viewPoint)
{
	return CoordPoint(viewPoint.x - hMargin, viewPoint.y - vMargin + scrollPos);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DocToView(CoordPoint docPoint)
{
	return CoordPoint(docPoint.x + hMargin, docPoint.y + vMargin - scrollPos);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ViewToDoc(Rectangle rect)
{
	Rectangle docRect = rect;
	docRect.OffsetBy(-hMargin, -(vMargin - scrollPos));
	return docRect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle DocToView(Rectangle rect)
{
	Rectangle viewRect = rect;
	viewRect.OffsetBy(hMargin, vMargin - scrollPos);
	return viewRect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle DocRect()
{
	Rectangle rect = view->Bounds();
	rect.InsetBy(hMargin, vMargin);
	return rect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StartRefreshCycle()
{
	refreshCycleNesting++;
	if (refreshRegion == NULL)
		refreshRegion = new Region();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishRefreshCycle()
{
	--refreshCycleNesting;
	if (refreshCycleNesting > 0 || refreshRegion == NULL)
		return;

	// refresh controls
/***
	BRegion controlRefreshRegion;
	BPoint mousePoint;
	uint32 buttons;
	GetMouse(&mousePoint, &buttons);
	RefreshControls(mousePoint, &controlRefreshRegion);
	refreshRegion->Include(&controlRefreshRegion);
***/

	// draw
	if (refreshRegion->CountRects() > 0) {
		view->Lock();
		Draw(view->Bounds());
		view->Unlock();
		}

	// clean up
	delete refreshRegion;
	refreshRegion = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshViewRect(Rectangle rect)
{
	if (refreshRegion)
		refreshRegion->Include(rect);
	else {
		view->Lock();
		Draw(rect);
		view->Unlock();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshDocAfter(int y)
{
	Rectangle rect = view->Bounds();
	rect.InsetBy(hMargin, vMargin);
	rect.top += y - scrollPos;
	RefreshViewRect(rect);
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:40:32 PDT"><![CDATA[
void RefreshAll()
{
	RefreshViewRect(view->Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"StyleScriptable virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString FunctionCall(DOMString function, DOMString arg, StyleScriptable* target)
{
	if (function == "actionAllowed") {
		arg = target->Eval(arg).trim();
		if (arg == "SavePosition()")
			return "true";
		else
			return DisplayDirector::FunctionCall(function, arg, target);
		}
	else if (function == "SavePosition") {
		Prefs()->SetRectPref("defaultWindFrame", wind->Frame());
		Prefs()->SetInt32Pref("h-margin", hMargin);
		Prefs()->SetInt32Pref("v-margin", vMargin);
		}
	else
		return DisplayDirector::FunctionCall(function, arg, target);

	return DOMString();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" General"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorView* view;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EnglishEditorWind* wind;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Bitmap* bitmap;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int hMargin;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int vMargin;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* stylesheet;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Validator* validator;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MenuDirector* menu;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" Scrolling"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int scrollPos;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int scrollTarget;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
float curAnimatedScrollPos;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool scrollStepPending;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool scrollMessagePending;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" Refresh"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int refreshCycleNesting;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Region* refreshRegion;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" Timing"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds lastScrollFrameTime;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds lastScrollStepTime;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds lastDrawTime;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Microseconds lastBlitTime;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" Actions"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* lastAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* sentinalAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* lastSaveAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" Controls"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ScrollerControl* scrollerControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
StatusControl* statusControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MenuControl* menuControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
HMarginControl* hMarginControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
VMarginControl* vMarginControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FrameRateControl* frameRateControl;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int DefaultHMargin = 60;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int DefaultVMargin = 60;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int PageScrollOverlap = 30;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int ArrowScrollAmount = 13;
]]></variable>

</class>


<class mod-time="Thu, 20 Apr 2000 00:42:08 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MenuDirector
</name>
<superclasses>
public DisplayDirector
</superclasses>
<hIncludes><![CDATA[
#include "DisplayDirector.h"
#include "Color.h"

class WindowDirector;
class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "DocumentSource.h"
#include "Document.h"
#include "Element.h"
#include "DocumentDisplayNode.h"
#include "Selection.h"
#include "Hotspot.h"
#include "CompositeStylesheet.h"
#include "DefaultValidator.h"
#include "BlockDrawContext.h"
#include "StyleParser.h"
#include "Shape.h"
#include "View.h"
#include "Keys.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MenuDirector(DocumentSource* docSourceIn, CoordPoint stemPointIn,
             WindowDirector* windowDirectorIn)
	: DisplayDirector(docSourceIn), stemPoint(stemPointIn),
	  windowDirector(windowDirectorIn)
{
	// stylesheet & validator
	Document* documentNode = docSource->GetDocument();
	stylesheet = new CompositeStylesheet(documentNode->DocumentElement()->TagName());
	validator = new DefaultValidator(this);

	// create & layout the display nodes at full width
	docWidth = windowDirector->DisplayWidth() - 2 * hMargin - 2 * borderWidth;
	SetupDisplayNodes();

	// relayout at the document's width
	docWidth = docDisplayNode->MaxLineWidth();
	docDisplayNode->BlockLayout(true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~MenuDirector()
{
	delete validator;
	delete stylesheet;
	delete docSource;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayDirector virtuals"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:53:55 PST"><![CDATA[
void Draw(Rectangle updateRect)
{
	View* drawView = DrawingView();
	drawView->PushState();

	// make the outline shape
	Rectangle contentRect = DocRect();
	int lineSpill = borderWidth / 2;
	contentRect.InsetBy(-(hMargin + lineSpill), -(vMargin + lineSpill));
	int shiftBy = (int) ((stemPoint.x - lineSpill) - contentRect.right);
	contentRect.OffsetBy(shiftBy, 0);
	Shape shape;
	shape.MoveTo(stemPoint.x - lineSpill, stemPoint.y);
	shape.LineTo(contentRect.right - stemWidth, contentRect.top - cornerRadius);
	shape.VerticalCornerTo(contentRect.right - stemWidth - cornerRadius, contentRect.top);
	shape.LineTo(contentRect.left + cornerRadius, contentRect.top);
	shape.HorizontalCornerTo(contentRect.left, contentRect.top + cornerRadius);
	shape.LineTo(contentRect.left, contentRect.bottom - cornerRadius);
	shape.VerticalCornerTo(contentRect.left + cornerRadius, contentRect.bottom);
	shape.LineTo(contentRect.right - cornerRadius, contentRect.bottom);
	shape.HorizontalCornerTo(contentRect.right, contentRect.bottom - cornerRadius);
	shape.LineTo(stemPoint.x - lineSpill, stemPoint.y);
	shape.Close();

	// clear the outline
	drawView->MovePenTo(CoordPoint(0, 0));
	drawView->SetDrawingMode(AlphaDrawingMode);
	drawView->SetHighColor(bgndColor);
	drawView->FillShape(&shape);

	// draw the document
	static const Color blackColor = { 0, 0, 0, 255 };
	drawView->SetHighColor(blackColor);
	drawView->SetDrawingMode(CopyDrawingMode);
	contentRect = DocRect();
//***	contentRect.InsetBy(hMargin + lineSpill, vMargin + lineSpill);	// restore it to the DocRect()
	BlockDrawContext
		drawContext(this, drawView, contentRect.left, contentRect.top,
		            0, docDisplayNode->Height());
	docDisplayNode->BlockDraw(&drawContext);

	// draw selection
	CoordPoint origin = contentRect.LeftTop();
	if (selection)
		selection->Draw(drawView, origin);

	// draw hotspot
	if (hotspot)
		hotspot->Draw(drawView, origin);

	// draw the outline
	drawView->MovePenTo(CoordPoint(0, 0));
	drawView->SetDrawingMode(AlphaDrawingMode);
	drawView->SetPenSize(borderWidth);
	drawView->SetHighColor(borderColor);
	drawView->StrokeShape(&shape);

	drawView->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KeyDown(string_slice key)
{
	// not really used...
	if (selection) {
		StartRefreshCycle();
		selection->AcceptKey(key, this);
		FinishRefreshCycle();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved()
{
	StartRefreshCycle();
	UpdateHotspot(WindowView()->GetMousePoint());
	FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScreenChanged()
{
	// nothing to do
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* GetStylesheet()
{
	return stylesheet;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Validator* GetValidator()
{
	return validator;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayWidth()
{
	return docWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* DrawingView()
{
	return windowDirector->DrawingView();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* WindowView()
{
	return windowDirector->WindowView();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint ViewToDoc(CoordPoint viewPoint)
{
	Rectangle docRect = DocRect();
	return CoordPoint(viewPoint.x - docRect.left, viewPoint.y - docRect.top);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DocToView(CoordPoint docPoint)
{
	Rectangle docRect = DocRect();
	return CoordPoint(docPoint.x + docRect.left, docPoint.y + docRect.top);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ViewToDoc(Rectangle rect)
{
	Rectangle docRect = DocRect();
	rect.OffsetBy(-docRect.left, -docRect.top);
	return rect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle DocToView(Rectangle rect)
{
	Rectangle docRect = DocRect();
	rect.OffsetBy(docRect.left, docRect.top);
	return rect;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:05:58 PST"><![CDATA[
Rectangle DocRect()
{
	Rectangle docRect;
//***	int lineSpill = borderWidth / 2;	//*** was I supposed to use this?
	docRect.top = stemPoint.y + stemHeight + cornerRadius + borderWidth + vMargin;
	docRect.bottom = docRect.top + docDisplayNode->Height();
	docRect.right = stemPoint.x - borderWidth - hMargin;
	docRect.left = docRect.right - docDisplayNode->MaxLineWidth();
	return docRect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StartRefreshCycle()
{
	windowDirector->StartRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishRefreshCycle()
{
	windowDirector->FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshViewRect(Rectangle rect)
{
	windowDirector->RefreshViewRect(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshDocAfter(int y)
{
	Rectangle rect = DocRect();
	rect.top += y;
	windowDirector->RefreshViewRect(rect);
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:42:08 PDT"><![CDATA[
void RefreshAll()
{
	windowDirector->RefreshAll();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DoDocAction(DOMString action)
{
	// pass them to the windowDirector
	windowDirector->DoDocAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DocTypeChanged()
{
	// never happens
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"StyleScriptable virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetScriptProperty(DOMString property)
{
	if (property == "window-director")
		return windowDirector->AsString();
	else
		return DisplayDirector::GetScriptProperty(property);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	Rectangle bounds = DocRect();
	bounds.InsetBy(-(hMargin + borderWidth), -(vMargin + borderWidth));
	bounds.top -= stemHeight + cornerRadius;
	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Command-Key Handling"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString MakeKeyName(string_slice key, int modifiers)
{
	DOMString keyName;

	// modifiers
	if ((modifiers & CommandModifier) != 0)
		keyName += "Cmd-";
	if ((modifiers & OptionModifier) != 0)
		keyName += "Opt-";
	if ((modifiers & ShiftModifier) != 0)
		keyName += "Shift-";
	if ((modifiers & ControlModifier) != 0)
		keyName += "Ctrl-";

	// keyname proper
	if (key == Keys::PageUpKey)
		keyName += "PageUp";
	else if (key == Keys::PageDownKey)
		keyName += "PageDown";
	else if (key == Keys::HomeKey)
		keyName += "Home";
	else if (key == Keys::EndKey)
		keyName += "End";
	else if (key == Keys::UpArrowKey)
		keyName += "UpArrow";
	else if (key == Keys::DownArrowKey)
		keyName += "DownArrow";
	else if (key == Keys::LeftArrowKey)
		keyName += "LeftArrow";
	else if (key == Keys::RightArrowKey)
		keyName += "RightArrow";
	else if (key == Keys::EscKey)
		keyName += "Esc";
	else if (key == Keys::DelKey)
		keyName += "Del";
	else if (key == "\b")
		keyName += "Backspace";
	else if (key.length() == 1) {
		char c = key[0];
		if (c >= 'a' && c <= 'z')
			c -= 'a' - 'A';
		char charStr[4];
		charStr[0] = c;
		charStr[1] = 0;
		keyName += charStr;
		}
	else
		keyName += key;

	return keyName;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString FindKeyActionIn(DOMString keyName, Element* element)
{
	for (Node* node = element->FirstChild(); node; node = node->NextSibling()) {
		Element* child = dynamic_cast<Element*>(node);
		if (child == NULL)
			continue;

		DOMString tagName = child->TagName();
		if (tagName == "menu-item" || tagName == "long-menu-item") {
			DOMString actionKey = child->GetAttribute("key");
			if (actionKey == keyName)
				return child->GetAttribute("action");
			}
		else {
			DOMString action = FindKeyActionIn(keyName, child);
			if (!action.empty())
				return action;
			}
		}

	return DOMString();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
" General"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint stemPoint;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* windowDirector;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* stylesheet;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Validator* validator;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int docWidth;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int stemHeight = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int stemWidth = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int cornerRadius = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int borderWidth = 3;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const Color borderColor = StyleParser::ParseColor("rgba(0, 255, 0, 128)");
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color bgndColor = { 255, 255, 255, 192 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int hMargin = 12;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int vMargin = 8;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:54:26 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DocumentSource
</name>
<superclasses>
public StyleScriptable
</superclasses>
<hIncludes><![CDATA[
#include "StyleScriptable.h"
#include "string_slice.h"

class Document;
class DisplayDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "XMLFileSource.h"
#include "System.h"
#include "String.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Document* GetDocument() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual string_slice GetWindowTitle() = 0;
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:54:19 PST"><![CDATA[
virtual DocumentSource* MakeMenuDocSource()
{
	String filePath = System::AppDirectory();
	filePath += "Aux-Docs/window-menu";
	return new XMLFileSource(filePath);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void AttachedToDirector(DisplayDirector* director)
{
	// default: do nothing
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Save() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CanCloseOnSpacebar()
{
	// default: no
	return false;
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 16:37:05 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
XMLFileSource
</name>
<superclasses>
public DocumentSource
</superclasses>
<hIncludes><![CDATA[
#include "DocumentSource.h"
#include "String.h"

class Document;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "XMLParser.h"
#include "XMLFileWriter.h"
#include "DOMUtils.h"
#include "Error.h"
#include "System.h"
#include "OSException.h"
#include <memory>	// for auto_ptr
#include <sys/stat.h>
#include <errno.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:36:18 PST"><![CDATA[
XMLFileSource(const string_slice filePathIn, bool isNewDoc = false)
	: filePath(filePathIn), fileText(NULL), document(NULL)
{
	// set up statics
	InitStatics();

	// read in the file
	// open it
	FILE* file = fopen(filePath.c_str(), "r");
	if (file == NULL)
		throw OSException("Couldn't open file.", errno);
	// find out how big it is
	fpos_t fileLen;
	if (fseek(file, 0, SEEK_END) != 0 || fgetpos(file, &fileLen) != 0) {
		fclose(file);
		throw OSException("Couldn't get size of file.", errno);
		}
	// read it
	rewind(file);
	fileText = new char[fileLen];
	fread(fileText, 1, fileLen, file);
	if (ferror(file)) {
		fclose(file);
		throw OSException("Couldn't read file.", errno);
		}
	fclose(file);

	// parse it
	XMLParser parser(string_slice(fileText, fileText + fileLen));
	document = parser.Parse();

	// if it's new, mark as such by clearing filePath
	if (isNewDoc)
		filePath = "";
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~XMLFileSource()
{
	delete document;
	delete fileText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DocumentSource virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* GetDocument()
{
	return document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetWindowTitle()
{
	if (filePath.empty())
		return "New Document";
	const char* fileName = strrchr(filePath.c_str(), '/');
	return (fileName ? fileName + 1 : "Unknown Document");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	// if it's a new file, get the title
	bool isNewFile = false;
	if (filePath.empty()) {
		isNewFile = true;

		// find the "title" element
		Element* docElement = document->DocumentElement();
		// first check directly
		Element* titleElement = docElement->GetElementByTagName("title");
		// next check in a "head" element
		if (titleElement == NULL) {
			Element* headElement = docElement->GetElementByTagName("head");
			if (headElement)
				titleElement = headElement->GetElementByTagName("title");
			}
		// if no title, kick out
		DOMString title;
		if (titleElement)
			title = DOMUtils::NodeContents(titleElement);
		if (title.empty()) {
			Error::ShowError("You'll need to give your document a title before you can save it.");
			return;
			}

		// create the filePath
		filePath = System::DocumentsDirectory();
		filePath += title;

		// see if there's already a file with that name
		struct stat statBuf;
		if (stat(filePath.c_str(), &statBuf) == 0) {
			Error::ShowError("There's already a document with that title.  You'll have to change the title before saving.");
			filePath = "";
			return;
			}
		}

	// open the file
	FILE* file = fopen(filePath.c_str(), "w+");
	if (file == NULL)
		throw OSException("Couldn't open file.", errno);
	// write the file
	XMLFileWriter writer(document, file);
	writer.Write();
	// close it
	fclose(file);

	// if it was a new file, set its type
	if (isNewFile)
		System::SetFileMimeType(filePath, "text/xml");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void InitStatics()
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Thu, 30 Mar 2000 16:36:59 PST"><![CDATA[
String filePath;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* fileText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

</class>


<class mod-time="Thu, 20 Apr 2000 01:05:42 PDT" wind-frame="77.000000,194.000000,717.000000,724.000000" list-views-height="0.000000">
<name>
MessageFileSource
</name>
<superclasses>
public DocumentSource
</superclasses>
<hIncludes><![CDATA[
#include "DocumentSource.h"
#include "String.h"

class Document;
class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "Text.h"
#include "Attr.h"
#include "CDATASection.h"
#include "EntityReference.h"
#include "NamedNodeMap.h"
#include "MessageParser.h"
#include "MessageFileWriter.h"
#include "XMLFileSource.h"
#include "XMLParser.h"
#include "DisplayDirector.h"
#include "DisplayNode.h"
#include "EnglishEditorWind.h"
#include "DOMUtils.h"
#include "System.h"
#include "Error.h"
#include "OSException.h"
#include "InternalException.h"
#include <memory>	// for auto_ptr
#include <stdio.h>
#include <errno.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:30:06 PST"><![CDATA[
MessageFileSource(const string_slice filePathIn, bool isNewMessageIn = false)
	: filePath(filePathIn), fileText(NULL), document(NULL), director(NULL),
	  isNewMessage(isNewMessageIn), isSent(false)
{
	// set up statics
	InitStatics();

	// read in the file
	// open it
	FILE* file = fopen(filePath.c_str(), "r");
	if (file == NULL)
		throw OSException("Couldn't open file.", errno);
	// find out how big it is
	fpos_t fileLen;
	if (fseek(file, 0, SEEK_END) != 0 || fgetpos(file, &fileLen) != 0) {
		fclose(file);
		throw OSException("Couldn't get size of file.", errno);
		}
	// read it
	rewind(file);
	fileText = new char[fileLen];
	fread(fileText, 1, fileLen, file);
	if (ferror(file)) {
		fclose(file);
		throw OSException("Couldn't read file.", errno);
		}
	fclose(file);

	// parse it
	document = new Document();
	if (!isNewMessage) {
		MessageParser parser(string_slice(fileText, fileText + fileLen), document);
		parser.Parse();
		}
	else {
		// new message--prototype file is XML
		XMLParser parser(string_slice(fileText, fileText + fileLen));
		document = parser.Parse();
		}

	if (isNewMessage)
		filePath = "";

	// mark it as read
	if (!isNewMessage)
		System::MarkMailMessageRead(string_slice(filePath));
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:43:34 PDT"><![CDATA[
MessageFileSource(Document* documentIn, bool isNewMessageIn = false)
	: fileText(NULL), document(documentIn), director(NULL),
	  isNewMessage(isNewMessageIn), isSent(false)
{
	InitStatics();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~MessageFileSource()
{
	delete document;
	delete fileText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DocumentSource virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* GetDocument()
{
	return document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetWindowTitle()
{
	const char* fileName = strrchr(filePath.c_str(), '/');
	return (fileName ? fileName + 1 : "Reply");
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:31:07 PST"><![CDATA[
DocumentSource* MakeMenuDocSource()
{
	// find out if it's mail or news, incoming or outgoing
	bool isNews = false;
	bool isIncoming = false;
	Element* head = document->DocumentElement()->GetElementByTagName("head");
	if (head) {
		if (head->GetElementByTagName("from"))
			isIncoming = true;
		if (head->GetElementByTagName("newsgroups"))
			isNews = true;
		}

	String filePath = System::AppDirectory();
	filePath += "Aux-Docs/";
	filePath += (isIncoming ? "incoming-" : "outgoing-");
	filePath += (isNews ? "news-" : "mail-");
	filePath += "menu";
	return new XMLFileSource(filePath);
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 01:05:42 PDT"><![CDATA[
void AttachedToDirector(DisplayDirector* directorIn)
{
	director = directorIn;

	// if there's no file, its a new message, and we'll want to select something
	if (filePath.empty()) {
		bool haveSelected = false;

		// if the title is empty, select that
		Element* docElement = document->DocumentElement();
		if (docElement) {
			Element* head = docElement->GetElementByTagName("head");
			if (head) {
				Element* title = head->GetElementByTagName("title");
				if (title && DOMUtils::NodeContents(title).trim().empty()) {
					DisplayNode* titleDisplayNode = director->DisplayNodeFor(title);
					if (titleDisplayNode) {
						director->SetSelection(titleDisplayNode->GetSelection());
						haveSelected = true;
						}
					}
				}
			}

		// select the blank paragraph at the end
		if (!haveSelected) {
			DisplayNode* docDisplayNode = director->DisplayNodeFor(document);
			if (docDisplayNode)
				director->SetSelection(docDisplayNode->EndSelection());
			}
		}
}
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 00:25:07 PDT"><![CDATA[
void Save()
{
	char dateStr[128];

	Element* head = document->DocumentElement()->GetElementByTagName("head");
	time_t curTime = time(NULL);

	// if it hasn't been saved yet, create the file
	bool createdFile = false;
	bool isNews = false;
	if (filePath.empty()) {
		// find out if it's mail or news
		if (head && head->GetElementByTagName("newsgroups"))
			isNews = true;

		// get the title
		DOMString title;
		if (head) {
			Element* subjectElement = head->GetElementByTagName("title");
			if (subjectElement) {
				title = DOMUtils::NodeContents(subjectElement);
				}
			}
		if (title.empty()) {
			Error::ShowError("Your message needs a subject before you can save it.");
			return;
			}

		// adjust the title so it's appropriate as a filename
		title = System::AdjustFileName(title.trim());

		// add a timestamp to the title
		strftime(dateStr, 128, " %Y.%m.%d.%H.%M.%S", localtime(&curTime));
		title += dateStr;

		// set up the file path
		filePath = (isNews ? System::OutgoingNewsDirectory() : System::OutgoingMailDirectory());
		filePath += title;

		// see if it already exists
		struct stat statBuf;
		if (stat(filePath.c_str(), &statBuf) == 0) {
			Error::ShowError("Your message has the same subject as one you already created, which is currently not supported.  As a workaround, rename the existing file and save this one again.");
			return;
			}

		createdFile = true;
		}

	// update the date
	strftime(dateStr, 128, "%a, %d %b %Y %X %Z", localtime(&curTime));
	DOMString date(dateStr);
	date.detach();
	Element* dateElement = head->GetElementByTagName("date");
	if (dateElement == NULL) {
		dateElement = document->CreateElement("date");
		dateElement->AppendChild(document->CreateTextNode(date));
		head->AppendChild(dateElement);
		}
	else {
		Text* dateText = dynamic_cast<Text*>(dateElement->FirstChild());
		if (dateText == NULL) {
			dateText = document->CreateTextNode(date);
			dateElement->AppendChild(dateText);
			}
		else
			dateText->SetData(date);
		}

	// write the file
	MessageFileWriter writer(filePath, document);
	writer.Write();

	// if we created the file, set its type
	if (createdFile)
		System::SetFileMimeType(filePath, (isNews ? "text/x-news" : "text/x-email"));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanCloseOnSpacebar()
{
	return true;
}
]]></method>

<method access="public" mod-time="Mon, 28 Feb 2000 00:08:38 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Mon, 28 Feb 2000 00:08:58 PST"><![CDATA[
bool IsSent()
{
	return isSent;
}
]]></method>

<method access="public" mod-time="Mon, 28 Feb 2000 00:09:09 PST"><![CDATA[
bool IsNewMessage()
{
	return isNewMessage;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:46:00 PDT"><![CDATA[
void Reply(bool toNews)
{
	// start creating the reply
	Document* replyDoc = dynamic_cast<Document*>(document->CloneNode(false));
	Element* docElement = replyDoc->CreateElement("message");
	replyDoc->AppendChild(docElement);

	// make the header
	Element* head = replyDoc->CreateElement("head");
	docElement->AppendChild(head);
	Element* origHead = document->DocumentElement()->GetElementByTagName("head");
	// subject
	Node* subject = head->AppendChild(replyDoc->CreateElement("title"));
	Element* origSubjectNode = (origHead ? origHead->GetElementByTagName("title") : NULL);
	if (origSubjectNode) {
		DOMString origSubject = origSubjectNode->FirstChild()->NodeValue().trim();
		if (!origSubject.empty()) {
			DOMString newSubject;
			if (!origSubject.startsWith("Re:") && !origSubject.startsWith("re:"))
				newSubject = "Re: ";
			newSubject += origSubject;
			newSubject.detach();
			subject->AppendChild(replyDoc->CreateTextNode(newSubject));
			}
		}
	// newsgroups
	if (toNews && origHead) {
		Node* newsgroups = head->AppendChild(replyDoc->CreateElement("newsgroups"));
		Element* origGroupsNode = origHead->GetElementByTagName("newsgroups");
		if (origGroupsNode) {
			DOMString groups = origGroupsNode->FirstChild()->NodeValue().detach();
			newsgroups->AppendChild(replyDoc->CreateTextNode(groups));
			}
		}
	// to
	if (!toNews && origHead) {
		DOMString replyTo;
		Element* replyToNode = origHead->GetElementByTagName("reply-to");
		if (replyToNode)
			replyTo = DOMUtils::NodeContents(replyToNode).trim();
		if (replyTo.empty()) {
			Element* fromNode = origHead->GetElementByTagName("from");
			if (fromNode)
				replyTo = DOMUtils::NodeContents(fromNode).trim();
			}
		if (!replyTo.empty()) {
			Node* toNode = head->AppendChild(replyDoc->CreateElement("to"));
			toNode->AppendChild(replyDoc->CreateTextNode(replyTo));
			}
		}
	// references
	if (toNews && origHead) {
		// build the references
		DOMString refsList;
		Element* origRefs = origHead->GetElementByTagName("references");
		if (origRefs) {
			refsList = DOMUtils::NodeContents(origRefs).trim().detach();
			refsList += " ";
			}
		Element* origID = origHead->GetElementByTagName("message-id");
		if (origID)
			refsList += DOMUtils::NodeContents(origID).trim();
		// install the "References" header
		if (!refsList.empty()) {
			Node* newRefs = head->AppendChild(replyDoc->CreateElement("references"));
			newRefs->AppendChild(replyDoc->CreateTextNode(refsList));
			}
		}

	// prepare to attribute
	Element* attributionTemplate = replyDoc->CreateElement("blockquote");
	if (origHead) {
		Element* origFromNode = origHead->GetElementByTagName("from");
		if (origFromNode) {
			DOMString from = origFromNode->FirstChild()->NodeValue().detach();
			from += " wrote:";
			Element* attributionNode = replyDoc->CreateElement("attribution");
			attributionNode->AppendChild(replyDoc->CreateTextNode(from));
			attributionTemplate->AppendChild(attributionNode);
			}
		}

	// copy the body
	Element* body = replyDoc->CreateElement("body");
	docElement->AppendChild(body);
	Element* origBody = document->DocumentElement()->GetElementByTagName("body");
	Element* directQuote = NULL;
	for (Node* origChild = origBody->FirstChild(); origChild; origChild = origChild->NextSibling()) {
		if (origChild->NodeType() != ELEMENT_NODE)
			continue;
		if (origChild->NodeName() == "blockquote") {
			// we've finished a directQuote (if there was one)
			directQuote = NULL;
			// just copy the quote over
			body->AppendChild(CloneNode(origChild, replyDoc));
			}
		else if (origChild->NodeName() == "signature") {
			// don't copy signatures
			}
		else {
			// any other kind of element needs to get quoted
			if (directQuote == NULL) {
				directQuote = dynamic_cast<Element*>(attributionTemplate->CloneNode(true));
				body->AppendChild(directQuote);
				}
			// copy it into the current quote
			directQuote->AppendChild(CloneNode(origChild, replyDoc));
			}
		}

	// finally, add a new blank paragraph at the end
	Element* blankPara = replyDoc->CreateElement("p");
	blankPara->AppendChild(replyDoc->CreateTextNode(""));
	body->AppendChild(blankPara);

	// open the new window
	new EnglishEditorWind(new MessageFileSource(replyDoc, true));
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:33:42 PST"><![CDATA[
Node* CloneNode(Node* origNode, Document* replyDoc)
{
	int i;

	// create the node
	DOMString nodeName = origNode->NodeName();
	nodeName.detach();
	Node* newNode = NULL;
	bool copyChildren = true;
	switch (origNode->NodeType()) {
		case ELEMENT_NODE:
			{
			Element* newElement = replyDoc->CreateElement(nodeName);
			NamedNodeMap* attributes = origNode->Attributes();
			if (attributes) {
				int numAttributes = attributes->Length();
				for (i=0; i<numAttributes; ++i) {
					Node* newAttrNode = CloneNode(attributes->Item(i), replyDoc);
					if (newAttrNode == NULL)
						throw InternalException("MessageFileSource::CloneNode: Failed to clone attribute.");
					if (newAttrNode->NodeType() != ATTRIBUTE_NODE)
						throw InternalException("MessageFileSource::CloneNode: Clone of attribute is not an attribute!");
					Attr* newAttr = dynamic_cast<Attr*>(newAttrNode);
					newElement->SetAttributeNode(newAttr);
					}
				}
			newNode = newElement;
			}
			break;

		case ATTRIBUTE_NODE:
			newNode = replyDoc->CreateAttribute(nodeName);
			break;

		case TEXT_NODE:
			newNode = replyDoc->CreateTextNode(origNode->NodeValue().detach());
			break;

		case CDATA_SECTION_NODE:
			newNode = replyDoc->CreateCDATASection(origNode->NodeValue().detach());
			break;

		case ENTITY_REFERENCE_NODE:
			newNode = replyDoc->CreateEntityReference(nodeName);
			copyChildren = false;
			break;
		}

	// copy the children
	if (copyChildren) {
		for (Node* child = origNode->FirstChild(); child; child = child->NextSibling()) {
			// ignore "signature" elements
			if (child->NodeType() == ELEMENT_NODE && child->NodeName() == "signature")
				continue;
			// copy
			newNode->AppendChild(CloneNode(child, replyDoc));
			}
		}

	return newNode;
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:46:17 PDT"><![CDATA[
void Post()
{
	// make sure it's saved first
	if (director->IsDirty())
		director->Save();
	if (filePath.empty())
		return;

	// post it
	System::PostNewsMessage(filePath);

	// mark as sent (& display it)
	isSent = true;
	director->RefreshAll();
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:46:14 PDT"><![CDATA[
void Send()
{
	// make sure it's saved first
	if (director->IsDirty())
		director->Save();
	if (filePath.empty())
		return;

	// post it
	Element* header = document->DocumentElement()->GetElementByTagName("head");
	System::SendMailMessage(filePath, header);

	// mark as sent (& display it)
	isSent = true;
	director->RefreshAll();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:33:59 PST"><![CDATA[
void Trash()
{
	String filePath = this->filePath;	// in case closing the window makes "this" go away
	director->RequestClose();
	System::TrashFile(filePath);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"StyleScriptable virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString FunctionCall(DOMString function, DOMString arg, StyleScriptable* target)
{
	if (function == "actionAllowed") {
		bool result = false;
		arg = target->Eval(arg).trim();
		if (arg == "EmailReply()")
			result = true;	/***/
		else if (arg == "PostReply()")
			result = true;	/***/
		else if (arg == "Send()" || arg == "Post()" || arg == "Trash()")
			result = true;
		return (result ? "true" : "");
		}
	else if (function == "Send")
		Send();
	else if (function == "Post")
		Post();
	else if (function == "EmailReply")
		Reply(false);
	else if (function == "PostReply")
		Reply(true);
	else if (function == "Trash")
		Trash();
	else
		return StyleScriptable::FunctionCall(function, arg, target);

	return DOMString();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void InitStatics()
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Thu, 30 Mar 2000 16:32:15 PST"><![CDATA[
String filePath;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* fileText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* director;
]]></variable>

<variable access="protected" mod-time="Mon, 28 Feb 2000 00:07:22 PST"><![CDATA[
bool isNewMessage;
]]></variable>

<variable access="protected" mod-time="Mon, 28 Feb 2000 00:07:45 PST"><![CDATA[
bool isSent;
]]></variable>

</class>


<class mod-time="Thu, 20 Apr 2000 13:20:18 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MessageParser
</name>
<hIncludes><![CDATA[
#include "string_slice.h"

class Document;
class Element;
class LinesList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "Text.h"
#include "Attr.h"
#include "QuoterDict.h"
#include "InternalException.h"
#include <vector>

class LinesList : public vector<string_slice> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MessageParser(string_slice textIn, Document* documentIn)
	: text(textIn), document(documentIn)
{
	p = text.begin();

	// set up the document
	Element* docElement = document->CreateElement("message");
	document->AppendChild(docElement);
	docElement->AppendChild(document->CreateElement("head"));
	docElement->AppendChild(document->CreateElement("body"));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 13:20:18 PDT"><![CDATA[
void Parse()
{
	string_slice line;

	// get the parts of the document
	Element* docElement = document->DocumentElement();
	Element* head = docElement->GetElementByTagName("head");
	Element* body = docElement->GetElementByTagName("body");

	// read header
	string_slice headerName, headerText;
	Text* lastHeaderText = NULL;
	Element* lastHeader = NULL;
	while (!AtEOF()) {
		// get next line and check for end of headers
		line = GetLine();
		if (IsBlank(line))
			break;

		// handle continuation of headers
		if (line[0] == ' ' || line[0] == '\t') {
			if (lastHeaderText) {
				lastHeaderText->AppendData("\n");
				lastHeaderText->AppendData(line);
				}
			else if (lastHeader) {
				lastHeaderText = document->CreateTextNode(line);
				lastHeader->AppendChild(lastHeaderText);
				}
			continue;
			}

		// handle certain headers
		ParseHeader(line, &headerName, &headerText);
		string_slice headerTag = "";
		if (headerName == "Subject")
			headerTag = "title";
		else if (headerName == "From")
			headerTag = "from";
		else if (headerName == "Date")
			headerTag = "date";
		else if (headerName == "Newsgroups")
			headerTag = "newsgroups";
		else if (headerName == "To")
			headerTag = "to";
		else if (headerName == "Message-ID")
			headerTag = "message-id";
		else if (headerName == "References")
			headerTag = "references";
		if (!headerTag.empty()) {
			Element* header = document->CreateElement(headerTag);
			if (!headerText.trim().empty()) {
				lastHeaderText = document->CreateTextNode(headerText);
				header->AppendChild(lastHeaderText);
				}
			else
				lastHeaderText = NULL;
			if (headerTag == "title") {
				// always put the title first
				head->InsertBefore(header, head->FirstChild());
				}
			else
				head->AppendChild(header);
			lastHeader = header;
			}
		else {
			lastHeaderText = NULL;
			lastHeader = NULL;
			}
		}

	// read the message body
	string_slice curQuoter;
	Element* receptacle = body;
	Element* curQuote = NULL;
	LinesList curParaLines;
	QuoterDict quoterDict;
	while (!AtEOF()) {
		line = GetLine();

		// check quoting
		string_slice quoter, lineBody;
		ParseQuote(line, &quoter, &lineBody);
		if (quoter != curQuoter && !IsBlank(lineBody)) {
			// starting a new quote
			if (!quoter.empty()) {
				// check for attribution
				Node* attribution = NULL;
				if (quoter.substr(0, curQuoter.length()) == curQuoter)
					attribution = StripAttribution(&curParaLines);
				// finish off current block
				HandleParas(&curParaLines, receptacle);
				// finish off current quote
				FinishQuote(curQuote, body);
				// start new quote
				Element* newQuote = document->CreateElement("blockquote");
				if (attribution) {
					newQuote->AppendChild(attribution);
					quoterDict.SetAttributionFor(quoter, attribution->CloneNode(true));
					}
				else {
					attribution = quoterDict.GetAttributionFor(quoter);
					if (attribution)
						attribution = attribution->CloneNode(true);
					else {
						attribution = document->CreateElement("attribution");
						attribution->AppendChild(document->CreateTextNode("Somebody wrote:"));
						}
					newQuote->AppendChild(attribution);
					}
				receptacle = newQuote;
				curQuote = newQuote;
				}
			// end of quotes
			else {
				// finish off current block
				HandleParas(&curParaLines, receptacle);
				// finish off current quote
				FinishQuote(curQuote, body);
				// get out of the quote
				receptacle = body;
				curQuote = NULL;
				}
			curQuoter = quoter;
			}

		// add line
		curParaLines.push_back(lineBody);
		}
	// finish off current block
	HandleParas(&curParaLines, receptacle);
	// finish off current quote
	FinishQuote(curQuote, body);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline bool AtEOF()
{
	return (p >= text.end());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetLine()
{
	const char* start = p;
	const char* stopper = text.end();
	while (p < stopper) {
		char c = *p++;
		if (c == '\n' || c == '\r') {
//***			string_slice line(start, p - 1);	// strip the '\n' too
			if (p < stopper &&
			    ((c == '\n' && *p == '\r') ||
			     (c == '\r' && *p == '\n'))) {
				// CRLF or LFCR--skip the second char
				p++;
				}
			string_slice line(start, p);
			return line;
			break;
			}
		}

	// last line
	return string_slice(start, p);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsBlank(string_slice line)
{
	if (line.empty())
		return true;

	const char* stopper = line.end();
	for (const char* p = line.begin(); p != stopper; p++) {
		char c = *p;
		if (c != ' ' && c != '\t' && c != '\n' && c != '\r')
			return false;
		}

	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ParseHeader(string_slice line, string_slice* headerNameOut,
                 string_slice* headerTextOut)
{
	const char* p = line.begin();
	const char* stopper = line.end();
	char c;

	// get the name
	for (; p < stopper; p++) {
		if (*p == ':') {
			*headerNameOut = string_slice(line.begin(), p);
			p++;
			break;
			}
		}

	// skip whitespace
	for (; p < stopper; p++) {
		c = *p;
		if (c != ' ' && c != '\t')
			break;
		}

	// return the text
	*headerTextOut = string_slice(p, stopper);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ParseQuote(string_slice line, string_slice* quoter, string_slice* lineBody)
{
	const char* p = line.begin();
	const char* stopper = line.end();

	bool haveQuoter = false;
	const char* quoterEnd = p;	// prevent trailing whitespace from becoming part of the "quoter"
	for (; p < stopper; p++) {
		char c = *p;
		if (c == '>' || c == '|' || c == ':') {
			haveQuoter = true;
			quoterEnd = p + 1;
			}
		else if (c != ' ' && c != '\t')
			break;
		}
	if (haveQuoter) {
		*quoter = string_slice(line.begin(), quoterEnd);
		*lineBody = string_slice(p, stopper);
		}
	else {
		*quoter = string_slice();
		*lineBody = line;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsAttribution(string_slice line)
{
	// trim trailing whitespace
	int len = line.length();
	while (true) {
		char c = line[len-1];
		if (c != ' ' && c != '\t' && c != '\n' && c != '\r')
			break;
		--len;
		line.resize(len);
		}

	// check end of line for telltale ":" or "writes"
	if (line[len-1] == ':')
		return true;
	else if (len >= 5 && line.substr(len-5) == "writes")
		return true;

	// check for '@' anywhere in the line
	for (const char* p = line.begin(); p != line.end(); p++) {
		if (*p == '@')
			return true;
		}

	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* StripAttribution(LinesList* lines)
{
	bool haveAttribution = false;
	bool haveLines = false;
	int lastLine = lines->size() - 1;
	int firstLine;
	for (firstLine=lastLine; firstLine>=0; --firstLine) {
		string_slice line = (*lines)[firstLine];

		// skip blank lines at the end, but if we've already seen non-blank lines
		// a blank line means the start of the paragraph
		if (IsBlank(line)) {
			if (haveLines)
				break;
			else {
				lastLine = firstLine - 1;	// trim trailing blank lines while we're at it
				continue;
				}
			}

		// if it's the last line, check the end of the line
		if (!haveLines) {
			haveLines = true;

			// trim trailing whitespace
			int len = line.length();
			while (true) {
				char c = line[len-1];
				if (c != ' ' && c != '\t' && c != '\n' && c != '\r')
					break;
				--len;
				}
			
			// check end of line for telltale ":" or "writes" or "wrote"
			if (line[len-1] == ':')
				haveAttribution = true;
			else if (len >= 6 && line.substr(len-6) == "writes")
				haveAttribution = true;
			else if (len >= 5 && line.substr(len-5) == "wrote")
				haveAttribution = true;
			}

		// check for '@' anywhere in the line, which will also take to indicate attribution
		if (!haveAttribution) {
			for (const char* p = line.begin(); p != line.end(); p++) {
				if (*p == '@') {
					haveAttribution = true;
					break;
					}
				}
			}
		}
	firstLine += 1;		// point at first line of paragraph

	if (!haveAttribution)
		return NULL;

	// move attribution lines to new list
	LinesList attribLines;
	for (int i=firstLine; i<=lastLine; i++)
		attribLines.push_back((*lines)[i]);
	lines->resize(firstLine);

	// get rid of common boring garbage
	// (like "In article <lsdklskd>," or "On 7 Dec 1941 0700 GMT,")
	for (LinesList::iterator l = attribLines.begin(); l != attribLines.end(); ++l) {
		string_slice line = *l;
		if (line.startsWith("In ") || line.startsWith("On ")) {
			// search for a ','
			int commaPos = -1;
			const char* p = line.begin();
			const char* stopper = line.end();
			for (; p < stopper; ++p) {
				if (*p == ',') {
					commaPos = p - line.begin();
					break;
					}
				}
			// if there is one, we wanna kill the text up thru it
			if (commaPos > 0)
				*l = line.substr(commaPos + 1);
			}
		}

	// build paragraph
	Element* attribution = document->CreateElement("attribution");
	FillBlock(attribution, &attribLines);

	return attribution;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FillBlock(Element* element, LinesList* lines)
{
	Text* text;
	Element* newElement;
	char c;

	DOMString linesText;
	for (LinesList::iterator l = lines->begin(); l != lines->end(); ++l) {
//***		linesText += *l;
		string_slice line = *l;

		// split the line into words and handle them one at a time
		const char* p = line.begin();
		const char* stopper = line.end();
		while (p < stopper) {
			// skip whitespace
			const char* glyphStart = p;
			for (; p < stopper; ++p) {
				c = *p;
				if (c != ' ' && c != '\t' && c != '\n' && c != '\r')
					break;
				}
			if (p > glyphStart)
				linesText += string_slice(glyphStart, p);

			if (p >= stopper)
				break;

			// find the word
			glyphStart = p;
			for (; p < stopper; ++p) {
				c = *p;
				if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
					break;
				}
			// get rid of trailing punctuation
			const char* punctStart = p - 1;
			for (; punctStart >= glyphStart; --punctStart) {
				c = *punctStart;
				if (c != '.' && c != ',' && c != '?' && c != '!' &&
						c != ':' && c != ';' && c != '"' && c != '\'') {
					++punctStart;
					break;
					}
				}
			string_slice word(glyphStart, punctStart);
			string_slice trailingPunct(punctStart, p);

			// special handling of words
			if (!word.empty()) {
				string_slice trimmedWord = word;
				if (trimmedWord.startsWith("<") && trimmedWord.endsWith(">"))
					trimmedWord = trimmedWord.substr(1, trimmedWord.length() - 2);
				bool isEmailAddress = IsEmailAddress(trimmedWord);
				if (trimmedWord.startsWith("http:") || trimmedWord.startsWith("URL:") || 
						trimmedWord.startsWith("ftp:") || isEmailAddress) {
					// it's a URL, make a <a>
					// finish off the current text
					if (!linesText.empty()) {
						text = document->CreateTextNode(linesText);
						element->AppendChild(text);
						linesText.erase();
						}
					// build the URL
					DOMString url;
					if (isEmailAddress && !trimmedWord.startsWith("mailto:")) {
						url = "mailto:";
						url += trimmedWord;
						}
					else
						url = trimmedWord;
					// add the <a>
					// (Element::SetAttribute() doesn't work, especially if not attached to a document)
					newElement = document->CreateElement("a");
					Attr* newAttr = document->CreateAttribute("href");
					text = document->CreateTextNode(trimmedWord);
					newAttr->AppendChild(text);
					newElement->SetAttributeNode(newAttr);
					text = document->CreateTextNode(word);
					newElement->AppendChild(text);
					element->AppendChild(newElement);
					}
				else if ((word.startsWith("*") && word.endsWith("*")) ||
				         (word.startsWith("_") && word.endsWith("_"))) {
					// finish off the current text
					if (!linesText.empty()) {
						text = document->CreateTextNode(linesText);
						element->AppendChild(text);
						linesText.erase();
						}
					// make an <i>
					word = word.substr(1, word.length() - 2);
					newElement = document->CreateElement("i");
					text = document->CreateTextNode(word);
					newElement->AppendChild(text);
					element->AppendChild(newElement);
					}

				else
					linesText += word;
				}

			// add the trailingPunct
			if (!trailingPunct.empty())
				linesText += trailingPunct;
			}
		}

	if (!linesText.empty()) {
		text = document->CreateTextNode(linesText);
		element->AppendChild(text);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HandleParas(LinesList* lines, Element* receptacle)
{
	int i;

	// add the paragraphs
	LinesList curParaLines;
	int numLines = lines->size();
	for (i=0; i<numLines; i++) {
		string_slice line = (*lines)[i];
		if (IsBlank(line)) {
			// end of paragraph
			if (!curParaLines.empty())
				receptacle->AppendChild(BuildParagraph(&curParaLines));
			curParaLines.clear();
			}
		else if (line.startsWith("-- ") && line.trim() == "--") {
			// sigdash
			if (!curParaLines.empty())
				receptacle->AppendChild(BuildParagraph(&curParaLines));
			curParaLines.clear();
			Element* signature = document->CreateElement("signature");
			receptacle->AppendChild(signature);
			receptacle = signature;
			}
		else
			curParaLines.push_back(line);
		}
	// finish last paragraph
	if (!curParaLines.empty())
		receptacle->AppendChild(BuildParagraph(&curParaLines));

	// reset lines for the next go-round
	lines->clear();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* BuildParagraph(LinesList* lines)
{
	Element* para = document->CreateElement("p");
	FillBlock(para, lines);
	return para;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* BuildParagraph(string_slice text)
{
	Element* para = document->CreateElement("p");
	LinesList lines;
	lines.push_back(text);
	FillBlock(para, &lines);
	return para;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishQuote(Element* quote, Element* receptacle)
{
	// see if there really is anything in the quote
	if (quote == NULL)
		return;
	if (quote->GetElementByTagName("p") == NULL) {
		delete quote;
		return;
		}

	// yes there is, add it to the receptacle
	receptacle->AppendChild(quote);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsEmailAddress(string_slice word)
{
	// if there's an '@' followed by a '.', we consider it an email address.
	const char* p = word.begin();
	const char* stopper = word.end();
	bool hadAt = false;
	for (; p < stopper; ++p) {
		char c = *p;
		if (c == '@') {
			if (hadAt)
				return false;
			else
				hadAt = true;
			}
		else if (c == '.') {
			if (hadAt)
				return true;
			}
		}
	return false;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
const char* p;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
QuoterDict
</name>
<hIncludes><![CDATA[
#include "string_slice.h"

class Node;
class QuoterList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include <vector>

/*
	We don't expect there to be too many different quoters in a message, so
	we just use linear search for this instead of trying to be clever.
*/

struct QuoterItem {
	string_slice	quoter;
	Node*       	attribution;

	QuoterItem(string_slice quoterIn, Node* attributionIn)
		: quoter(quoterIn), attribution(attributionIn) {}
	~QuoterItem()
		{ delete attribution; }
	void	SetAttribution(Node* newAttribution)
				{ delete attribution; attribution = newAttribution; }
};

class QuoterList : public vector<QuoterItem*> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
QuoterDict()
{
	dict = new QuoterList();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~QuoterDict()
{
	for (QuoterList::iterator q = dict->begin(); q != dict->end(); ++q)
		delete *q;
	delete dict;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetAttributionFor(string_slice quoter, Node* attribution)
{
	// see if it's in the dict yet
	int numQuoters = dict->size();
	for (int i=0; i<numQuoters; i++) {
		QuoterItem* item = (*dict)[i];
		if (item->quoter == quoter) {
			item->SetAttribution(attribution);
			return;
			}
		}

	// not there; add it
	dict->push_back(new QuoterItem(quoter, attribution));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* GetAttributionFor(string_slice quoter)
{
	// find it
	int numQuoters = dict->size();
	for (int i=0; i<numQuoters; i++) {
		QuoterItem* item = (*dict)[i];
		if (item->quoter == quoter)
			return item->attribution;
		}

	// didn't find it
	return NULL;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
QuoterList* dict;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:23:50 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MessageFileWriter
</name>
<hIncludes><![CDATA[
#include "string_slice.h"

class Document;
class TextFileWriter;
class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextFileWriter.h"
#include "Document.h"
#include "Element.h"
#include "Text.h"
#include "DOMUtils.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MessageFileWriter(string_slice filePath, Document* documentIn)
	: document(documentIn)
{
	out = new TextFileWriter(filePath);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~MessageFileWriter()
{
	delete out;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Write()
{
	Node* childNode;

	Element* docElement = document->DocumentElement();
	Element* head = docElement->GetElementByTagName("head");
	Element* body = docElement->GetElementByTagName("body");

	// write the header
	for (childNode = head->FirstChild(); childNode; childNode = childNode->NextSibling()) {
		Element* header = dynamic_cast<Element*>(childNode);
		if (header == NULL)
			continue;

		DOMString tagName = header->TagName();
		DOMString headerName;
		if (tagName == "from")
			headerName = "From: ";
		else if (tagName == "title")
			headerName = "Subject: ";
		else if (tagName == "date")
			headerName = "Date: ";
		else if (tagName == "newsgroups")
			headerName = "Newsgroups: ";
		else if (tagName == "to")
			headerName = "To: ";
		else if (tagName == "message-id")
			headerName = "Message-ID: ";
		else if (tagName == "references")
			headerName = "References: ";

		if (!headerName.empty()) {
			out->WriteRawText(headerName);
			out->WriteRawText(DOMUtils::NodeContents(header).trim());
			out->NewLine();
			}
		}

	// write the divider
	out->NewLine();

	// write the body
	bool started = false;
	for (childNode = body->FirstChild(); childNode; childNode = childNode->NextSibling()) {
		Element* element = dynamic_cast<Element*>(childNode);
		if (element == NULL)
			continue;
		DOMString tagName = element->TagName();

		// put space after the last block
		if (started)
			out->NewLine();
		else
			started = true;

		// quotes are special
		if (tagName == "blockquote") {
			// first, write the attribution if there is one
			Element* attribution = element->GetElementByTagName("attribution");
			if (attribution) {
				WriteContents(attribution);
				out->NewLine();
				}
			// write the contents, quoted
			out->SetLinePrefix("> ");
			bool startedQuote = false;
			for (Node* quotedBlock = element->FirstChild(); quotedBlock; quotedBlock = quotedBlock->NextSibling()) {
				Element* quotedElement = dynamic_cast<Element*>(quotedBlock);
				if (quotedElement == NULL || quotedElement->TagName() == "attribution")
					continue;

				// add space if needed
				if (startedQuote)
					out->NewLine();
				else
					startedQuote = true;

				// write the element at a paragraph
				WriteContents(quotedElement);
				out->NewLine();
				}
			out->SetLinePrefix("");
			}

		// treat all others as paragraphs
		else {
			WriteContents(element);
			out->NewLine();
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:23:50 PST"><![CDATA[
void WriteContents(Node* node)
{
	for (Node* childNode = node->FirstChild(); childNode; childNode = childNode->NextSibling()) {
		switch (childNode->NodeType()) {
			case ELEMENT_NODE:
				{
				Element* element = dynamic_cast<Element*>(childNode);
				DOMString tagName = element->TagName();
				bool italicize = (tagName == "i" || tagName == "cite");
				if (italicize)
					out->WriteText("_");
				WriteContents(element);
				if (italicize)
					out->WriteText("_");
				}
				break;

			case TEXT_NODE:
			case CDATA_SECTION_NODE:
				{
				CharacterData* textNode = dynamic_cast<CharacterData*>(childNode);
				out->WriteText(textNode->Data());
				}
				break;

			case ENTITY_REFERENCE_NODE:
				{
				if (childNode->HasChildNodes())
					WriteContents(childNode);
				else {
					out->WriteText("&");
					out->WriteText(childNode->NodeName());
					out->WriteText(";");
					}
				}
				break;
			}
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextFileWriter* out;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:20:25 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TextFileWriter
</name>
<hIncludes><![CDATA[
#include "DOMString.h"
#include "string_slice.h"
#include <stdio.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include "OSException.h"
#include <errno.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextFileWriter(string_slice filePathIn)
	: whitespaceAtEndOfLine(false)
{
	// open the file
	qstring filePath(filePathIn);
	file = fopen(filePath.c_str(), "w");
	if (file == NULL)
		throw OSException("Couldn't open file.", errno);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TextFileWriter()
{
	if (!curLine.empty())
		fwrite(curLine.begin(), 1, curLine.length(), file);
	fclose(file);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:20:04 PST"><![CDATA[
void WriteText(DOMString text)
{
	char c;

	// write the text, wrapping lines
	const char* p = text.begin();
	const char* stopper = text.end();
	while (true) {
		// skip whitespace
		while (p < stopper) {
			c = *p;
			if (c != ' ' && c != '\t' && c != '\n' && c != '\r')
				break;
			whitespaceAtEndOfLine = true;
			++p;
			}
		if (p >= stopper)
			break;

		// get the next character run
		const char* charsStart = p;
		while (p < stopper) {
			c = *p;
			if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
				break;
			p++;
			}
		string_slice chars(charsStart, p);

		// check if we need a newline or a space
		if (!AtLineStart()) {
			unsigned int neededChars = chars.length() + (whitespaceAtEndOfLine ? 1 : 0);
			if (curLine.length() + neededChars > lineLength)
				NewLine();
			else if (whitespaceAtEndOfLine)
				curLine += " ";
			}

		// write the character run
		curLine += chars;
		whitespaceAtEndOfLine = false;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteRawText(DOMString text)
{
	// finish any pending text
	if (whitespaceAtEndOfLine) {
		curLine += " ";
		whitespaceAtEndOfLine = false;
		}
	if (!curLine.empty()) {
		fwrite(curLine.begin(), 1, curLine.length(), file);
		curLine = linePrefix;
		}

	// write the new text
	fwrite(text.begin(), 1, text.length(), file);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NewLine()
{
	if (!curLine.empty())
		fwrite(curLine.begin(), curLine.length(), 1, file);
	fputs("\n", file);
	curLine = linePrefix;
	whitespaceAtEndOfLine = false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetLinePrefix(DOMString newPrefix)
{
	bool lineWasEmpty = (curLine == linePrefix || curLine.empty());
	linePrefix = newPrefix;
	if (lineWasEmpty)
		curLine = linePrefix;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool AtLineStart()
{
	return (curLine == linePrefix);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FILE* file;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString curLine;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool whitespaceAtEndOfLine;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString linePrefix;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Thu, 30 Mar 2000 16:20:25 PST"><![CDATA[
static const unsigned int lineLength = 72;
]]></variable>

</class>


<class mod-time="Thu, 20 Apr 2000 01:24:50 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
IntroDocSource
</name>
<superclasses>
public DocumentSource
</superclasses>
<hIncludes><![CDATA[
#include "DocumentSource.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "Text.h"
#include "XMLParser.h"
#include "System.h"
#include "qstring.h"
#include "OSException.h"
#include <stdio.h>
#include <errno.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 01:24:50 PDT"><![CDATA[
IntroDocSource()
{
	// read in the file
	// figure out the path
	qstring filePath = string_slice(System::AppDirectory());
	filePath += "Aux-Docs/intro-window";
	// open it
	FILE* file = fopen(filePath.c_str(), "r");
	if (file == NULL)
		throw OSException("Couldn't open intro-window file.", errno);
	// find out how big it is
	fpos_t fileLen;
	if (fseek(file, 0, SEEK_END) != 0 || fgetpos(file, &fileLen) != 0) {
		fclose(file);
		throw OSException("Couldn't get size of file.", errno);
		}
	// read it
	rewind(file);
	fileText = new char[fileLen];
	fread(fileText, 1, fileLen, file);
	if (ferror(file)) {
		fclose(file);
		throw OSException("Couldn't read intro-window file.", errno);
		}
	fclose(file);
	// parse it
	XMLParser parser(string_slice(fileText, fileText + fileLen));
	document = parser.Parse();

	// build the "about" section of the document
	Element* docElement = document->DocumentElement();
	Element* aboutElement = document->CreateElement("about-section");
	docElement->InsertBefore(aboutElement, docElement->FirstChild());
	// app-name
	Element* appNameElement = document->CreateElement("app-name");
	appNameElement->AppendChild(document->CreateTextNode("The English Editor II"));
	aboutElement->AppendChild(appNameElement);
	// version
	Element* versionElement = document->CreateElement("pre-version");
	versionElement->AppendChild(document->CreateTextNode("Pre-release"));
	aboutElement->AppendChild(versionElement);
	// copyright
	Element* copyrightElement = document->CreateElement("copyright");
	copyrightElement->AppendChild(document->CreateTextNode("© 1999 Steve Folta"));
	aboutElement->AppendChild(copyrightElement);
	// credits
	Element* creditsElement = document->CreateElement("credits");
	creditsElement->AppendChild(document->CreateTextNode("Math by Drew Folta"));
	aboutElement->AppendChild(creditsElement);
	// build-date
	const char* buildDate = "Build date: " __DATE__ " " __TIME__;
	Element* buildDateElement = document->CreateElement("build-date");
	buildDateElement->AppendChild(document->CreateTextNode(buildDate));
	aboutElement->AppendChild(buildDateElement);

/***
	// create the "new document" links
	qstring protosDirName = System::AppDirectory();
	protosDirName += "Prototype Documents";
	DIR* protosDir = opendir(protosDirName.c_str());
	if (protosDir) {
		while (true) {
			struct dirent* dirEntry = readdir(protosDir);
			if (dirEntry == NULL)
				break;

			DOMString fileName = dirEntry->d_name;
			if (fileName.startsWith("."))
				continue;
			fileName.detach();
			Element* newDocElement = document->CreateElement("new-document");
			newDocElement->AppendChild(document->CreateTextNode(fileName));
			docElement->AppendChild(newDocElement);
			}

		closedir(protosDir);
		}
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~IntroDocSource()
{
	delete document;
	delete fileText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DocumentSource virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* GetDocument()
{
	return document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetWindowTitle()
{
	return "Create New Document";
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	// nothing to do
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
char* fileText;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Display Nodes"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 17:01:20 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayNode
</name>
<hIncludes><![CDATA[
#include "DisplayType.h"
#include "DOMString.h"
#include "string_slice.h"

class Font;
class DisplayDirector;
class BlockableDisplayNode;
class Selection;
class Hotspot;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DocumentDisplayNode.h"
#include "EditStylesheet.h"
#include "DisplayDirector.h"
#include "Font.h"
#include "InternalException.h"
#include "DOMStringIter.h"
#include "qstring.h"
#include <memory>	// for auto_ptr
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode(DisplayNode* parentIn = NULL)
	: parent(parentIn), prevSibling(NULL), nextSibling(NULL),
	  needsLoad(true), needsLayout(true)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual ~DisplayNode()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DisplayType GetDisplayType() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DisplayType DeclaredDisplayType() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsLeafBlock() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsDisposable() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Load(DisplayDirector* director)
{
	/* default - just clear "needsLoad" */
	needsLoad = false;
	needsLayout = true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void UpdateProperties() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DOMString GetProperty(string_slice propertyName)
{
	return "";
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetInheritedProperty(string_slice propertyName)
{
	for (DisplayNode* node = this; node; node = node->Parent()) {
		DOMString property = node->GetProperty(propertyName);
		if (property.length() > 0)
			return property;
		}

	return DOMString();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:01:20 PST"><![CDATA[
virtual int GetPropertyInPixels(string_slice propertyName, bool inherited)
{
	DOMString propStr = GetProperty(propertyName);
	if (propStr.length() == 0)
		return (inherited ? parent->GetPropertyInPixels(propertyName, true) : 0);
	DOMString suffix = propStr.substr(propStr.length() - 2, 2);
	double multiplier = 1;
	if (suffix == "px" || suffix == "pt")
		multiplier = 1;
	else if (suffix == "in")
		multiplier = 72;
	else if (suffix == "cm")
		multiplier = (2.54 / 72);
	else if (suffix == "mm")
		multiplier = (25.4 / 72);
	else if (suffix == "pc")
		multiplier = 12;
	else if (suffix == "em") {
		DisplayNode* node = (propertyName == "font-size" ? parent : this);
//***		auto_ptr<Font> font(node->GetFont());
		Font* font = node->CurFont();
		multiplier = font->Size();
		}
	else if (suffix == "ex") {
		/***/
		}
	else if (suffix == "sp") {
		DisplayNode* node = (propertyName == "font-size" ? parent : this);
		Font* font = node->CurFont();
		multiplier = font->SpaceWidth();
		}

	// read the number
	double num = 0;
	bool negative = false;
	DOMString numStr = propStr.substr(0, propStr.length() - 2);
	for (DOMStringIter p = numStr.begin(); p != numStr.end(); ++p) {
		char c = *p;
		int digit;
		if (c == '-')
			negative = true;
		else if (c == '.') {
			// read the post-. portion
			double factor = 0.1;
			++p;	// skip '.'
			for (; p != numStr.end(); ++p) {
				digit = (*p - '0');
				if (digit >= 0 && digit <= 9) {
					num += digit * factor;
					factor /= 10;
					}
				}
			break;
			}
		else {
			digit = c - '0';
			if (digit >= 0 && digit <= 9) {
				num *= 10;
				num += digit;
				}
			}
		}
	if (negative)
		num *= -1;

	return (int) (num * multiplier);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual BlockableDisplayNode* AsBlockableDisplayNode() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* StartSelection() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* EndSelection() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DisplayNode* FirstChild() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DisplayNode* LastChild() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* GetSelection()
{
	// default: none (for non-selectable nodes)
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Hotspot* GetHotspot(DisplayDirector* director)
{
	// default: none
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Font* CurFont() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* Parent()
{
	return parent;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* PreviousSibling()
{
	return prevSibling;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* NextSibling()
{
	return nextSibling;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool DescendsFrom(DisplayNode* otherNode)
{
	for (DisplayNode* node = parent; node; node = node->Parent()) {
		if (node == otherNode)
			return true;
		}
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* PrevNodeInDoc()
{
	DisplayNode* node = this;
	DisplayNode* prevNode = node->PreviousSibling();
	while (prevNode == NULL) {
		node = node->Parent();
		if (node == NULL)
			break;
		prevNode = node->PreviousSibling();
		}
	return prevNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* NextNodeInDoc()
{
	DisplayNode* node = this;
	DisplayNode* nextNode = node->NextSibling();
	while (nextNode == NULL) {
		node = node->Parent();
		if (node == NULL)
			break;
		nextNode = node->NextSibling();
		}
	return nextNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* GetDisplayDirector()
{
	// find the DocumentDisplayNode
	for (DisplayNode* node = this; node; node = node->parent) {
		DocumentDisplayNode* docNode = dynamic_cast<DocumentDisplayNode*>(node);
		if (docNode)
			return docNode->Director();
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
/* makes */ Font* GetFont()
{
	// get the family name
	DOMString familyName = GetInheritedProperty("font-family");
	if (familyName.length() == 0)
		throw InternalException("Couldn't find font-family.");

/***
	// turn it into a string_slice
	qstring familyStr;
	for (DOMStringSliceIter s = familyName.beginSlices(); s != familyName.endSlices(); ++s)
		familyStr += *s;
***/

	// get the size
	int size = GetPropertyInPixels("font-size", true);

	// get the style
	int style = 0;
	if (GetInheritedProperty("font-style") == "italic")
		style |= Font::Italic;
	if (GetInheritedProperty("font-weight") == "bold")
		style |= Font::Bold;

	// return the font
	return new Font(familyName, size, style);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsLoad()
{
	return needsLoad;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsLayout()
{
	return needsLayout;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"For subclasses"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetPrevSibling(DisplayNode* newPrevSibling)
{
	prevSibling = newPrevSibling;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetNextSibling(DisplayNode* newNextSibling)
{
	nextSibling = newNextSibling;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetParent(DisplayNode* newParent)
{
	parent = newParent;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* parent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* prevSibling;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* nextSibling;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool needsLoad;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool needsLayout;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BlockableDisplayNode
</name>
<superclasses>
virtual public DisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "DisplayNode.h"

class BlockDrawContext;
class FindSelectionContext;
class FindDestinationContext;
class FindHotspotContext;
class Selection;
class Destination;
class Hotspot;
class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode(DisplayNode* parentIn)
	: DisplayNode(parentIn), height(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int Width()
{
	BlockableDisplayNode* parentNode = dynamic_cast<BlockableDisplayNode*>(parent);
	if (parentNode == NULL)
		throw InternalException("BlockableDisplayNode has non-block parent.");
	return
		parentNode->Width()
			- GetPropertyInPixels("margin-left", false)
			- GetPropertyInPixels("margin-right", false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int LeftSpace()
{
	BlockableDisplayNode* parentNode = dynamic_cast<BlockableDisplayNode*>(parent);
	if (parentNode == NULL)
		throw InternalException("BlockableDisplayNode has non-block parent.");
	return
		parentNode->LeftSpace()
			+ GetPropertyInPixels("margin-left", false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void BlockLayout(bool force = false) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void BlockDraw(BlockDrawContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* BlockFindSelection(FindSelectionContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Destination* BlockFindDestination(FindDestinationContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Hotspot* BlockFindHotspot(FindHotspotContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int TopMargin() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int BottomMargin() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int GetChildTop(DisplayNode* child) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void CalcVerticalMargins() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int MaxLineWidth() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Node* FirstNode() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Node* LastNode() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual BlockableDisplayNode* AsBlockableDisplayNode()
{
	return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Properties"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int Height()
{
	return height;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Top()
{
	return (parent ? dynamic_cast<BlockableDisplayNode*>(parent)->GetChildTop(this) : 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Bottom()
{
	return Top() + Height();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayWidth()
{
	int width = Width();
	int textIndent = GetPropertyInPixels("text-indent", true);
	if (textIndent < 0)
		width += -textIndent;
	return width;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayLeft()
{
	int left = LeftSpace();
	int textIndent = GetPropertyInPixels("text-indent", true);
	if (textIndent < 0)
		left -= -textIndent;
	return left;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Property Management"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HeightChangedBy(int heightDelta)
{
	height += heightDelta;

	// pass it on up the tree
	BlockableDisplayNode* parentBlock = dynamic_cast<BlockableDisplayNode*>(parent);
	if (parentBlock)
		parentBlock->HeightChangedBy(heightDelta);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HeightChangedTo(int newHeight)
{
	HeightChangedBy(newHeight - height);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void VerticalMarginsChanged()
{
	CalcVerticalMargins();

	if (parent && (this == parent->FirstChild() || this == parent->LastChild())) {
		BlockableDisplayNode* blockParent = dynamic_cast<BlockableDisplayNode*>(parent);
		if (blockParent)
			blockParent->VerticalMarginsChanged();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helper Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshAfter()
{
	DisplayDirector* director = GetDisplayDirector();
	if (director == NULL)
		throw InternalException("BlockableDisplayNode::RefreshDocAfter(): not attached to director.");
	director->RefreshDocAfter(Top());
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int height;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InlineableDisplayNode
</name>
<superclasses>
virtual public DisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "DisplayNode.h"
#include "GlyphRef.h"

class InlineLayoutContext;
class InlineDrawContext;
class FindSelectionContext;
class FindDestinationContext;
class FindHotspotContext;
class Selection;
class Destination;
class Hotspot;
class BlockableDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlockableDisplayNode.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void InlineLayout(InlineLayoutContext* layoutContext) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void InlineDraw(InlineDrawContext* drawContext) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* InlineFindSelection(FindSelectionContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Destination* InlineFindDestination(FindDestinationContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Hotspot* InlineFindHotspot(FindHotspotContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CanSelectAcross() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual GlyphRef FirstSelectableGlyph() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual GlyphRef LastSelectableGlyph() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual GlyphRef LastGlyph() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers for subclasses"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* EnclosingLeafBlock()
{
	for (DisplayNode* node = this; node; node = node->Parent()) {
		if (node->GetDisplayType() == Block)
			return dynamic_cast<BlockableDisplayNode*>(node);
		}
	return NULL;
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 17:02:36 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
CompositeDisplayNode
</name>
<superclasses>
public BlockableDisplayNode, public InlineableDisplayNode, public DOMChangeClient
</superclasses>
<hIncludes><![CDATA[
#include "BlockableDisplayNode.h"
#include "InlineableDisplayNode.h"
#include "DOMChangeClient.h"

#include "Timing.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Text.h"
#include "GeneratedLeafBlock.h"
#include "TextDisplayNode.h"
#include "DisplayTextNode.h"
#include "DisplayElementNode.h"
#include "PlaceholderTextDisplayNode.h"
#include "DisplayDirector.h"
#include "BlocksSelection.h"
#include "BlockElementSelection.h"
#include "BetweenBlocksSelection.h"
#include "BetweenBlocksDestination.h"
#include "InlineLayoutContext.h"
#include "InlineDrawContext.h"
#include "BlockDrawContext.h"
#include "FindSelectionContext.h"
#include "FindDestinationContext.h"
#include "FindHotspotContext.h"
#include "EditStylesheet.h"
#include "GlyphLoc.h"
#include "InternalException.h"
#include <typeinfo>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CompositeDisplayNode(DisplayNode* parentIn)
	: BlockableDisplayNode(parentIn), firstChild(NULL), lastChild(NULL),
	  isBlock(false), isLeafBlock(false),
	  topMargin(0), bottomMargin(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~CompositeDisplayNode()
{
	ClearChildren();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType GetDisplayType()
{
	return (isBlock ? Block : Inline);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsLeafBlock()
{
	return isLeafBlock;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateProperties()
{
	// have all children update properties--must do this before updating margins
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling())
		childNode->UpdateProperties();

	CalcVerticalMargins();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* StartSelection()
{
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("CompositeDisplayNode::StartSelection: Child is not inline.");
		Selection* startSelection = child->StartSelection();
		if (startSelection)
			return startSelection;
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* EndSelection()
{
	for (DisplayNode* childNode = lastChild; childNode; childNode = childNode->PreviousSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("CompositeDisplayNode::EndSelection: Child is not inline.");
		Selection* endSelection = child->EndSelection();
		if (endSelection)
			return endSelection;
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* FirstChild()
{
	return firstChild;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* LastChild()
{
	return lastChild;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BlockableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void BlockLayout(bool force = false)
{
	if (isLeafBlock)
		LayoutInlineChildren();
	else
		LayoutChildBlocks(force);
	needsLayout = false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void BlockDraw(BlockDrawContext* context)
{
	if (isLeafBlock)
		DrawInlineChildren(context);
	else
		DrawChildBlocks(context);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* BlockFindSelection(FindSelectionContext* context)
{
	if (isLeafBlock)
		return FindSelectionInInlineChildren(context);
	else
		return FindSelectionInChildBlocks(context);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* BlockFindDestination(FindDestinationContext* context)
{
	if (isLeafBlock)
		return FindDestinationInInlineChildren(context);
	else
		return FindDestinationInChildBlocks(context);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* BlockFindHotspot(FindHotspotContext* context)
{
	// first, see if this block has a hotspot
	Hotspot* hotspot = GetHotspot(context->director);
	if (hotspot)
		return hotspot;

	// otherwise, check the children
	if (isLeafBlock)
		return FindHotspotInInlineChildren(context);
	else
		return FindHotspotInChildBlocks(context);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int TopMargin()
{
	return topMargin;

/***
	int topMargin = GetPropertyInPixels("margin-top", false);
	if (isBlock && !isLeafBlock && firstChild) {
		BlockableDisplayNode* topChild =
			dynamic_cast<BlockableDisplayNode*>(firstChild);
		if (topChild == NULL)
			throw InternalException("Non-leaf block has non-block child.");
		int childTopMargin = topChild->TopMargin();
		if (childTopMargin > topMargin)
			topMargin = childTopMargin;
		}
	return topMargin;
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int BottomMargin()
{
	return bottomMargin;

/***
	int bottomMargin = GetPropertyInPixels("margin-bottom", false);
	if (isBlock && !isLeafBlock && lastChild) {
		BlockableDisplayNode* bottomChild =
			dynamic_cast<BlockableDisplayNode*>(lastChild);
		if (bottomChild == NULL)
			throw InternalException("Non-leaf block has non-block child.");
		int childBottomMargin = bottomChild->BottomMargin();
		if (childBottomMargin > bottomMargin)
			bottomMargin = childBottomMargin;
		}
	return bottomMargin;
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetChildTop(DisplayNode* child)
{
	int interBlockSpace = 0;
	int childTop = Top();
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(childNode);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		// add inter-block space
		if (childBlock != firstChild) {
			// use the max of the last child's bottom margin and the current child's
			// top margin, but this block's top margin isn't counted as part of
			// its height (which is why we don't do this on the first child block,
			// which contributes to this block's top margin)
			int childTopMargin = childBlock->TopMargin();
			if (childTopMargin > interBlockSpace)
				interBlockSpace = childTopMargin;
			}
		childTop += interBlockSpace;

		// check if we're done
		if (childNode == child)
			return childTop;

		// add to the height
		childTop += childBlock->Height();
		interBlockSpace = childBlock->BottomMargin();
		}

	return childTop;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void CalcVerticalMargins()
{
	// top margin
	topMargin = GetPropertyInPixels("margin-top", false);
	if (isBlock && !isLeafBlock && firstChild) {
		BlockableDisplayNode* topChild =
			dynamic_cast<BlockableDisplayNode*>(firstChild);
		if (topChild == NULL)
			throw InternalException("Non-leaf block has non-block child.");
		int childTopMargin = topChild->TopMargin();
		if (childTopMargin > topMargin)
			topMargin = childTopMargin;
		}

	// bottom margin
	bottomMargin = GetPropertyInPixels("margin-bottom", false);
	if (isBlock && !isLeafBlock && lastChild) {
		BlockableDisplayNode* bottomChild =
			dynamic_cast<BlockableDisplayNode*>(lastChild);
		if (bottomChild == NULL)
			throw InternalException("Non-leaf block has non-block child.");
		int childBottomMargin = bottomChild->BottomMargin();
		if (childBottomMargin > bottomMargin)
			bottomMargin = childBottomMargin;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int MaxLineWidth()
{
	// if this is a leaf block, we saved the maxLineWidth after the last layout
	if (isLeafBlock)
		return maxLineWidth;

	// otherwise, get the max of the children's line widths
	maxLineWidth = 0;
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(childNode);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		int childLineWidth = childBlock->MaxLineWidth();
		if (childLineWidth > maxLineWidth)
			maxLineWidth = childLineWidth;
		}
	return maxLineWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InlineLayout(InlineLayoutContext* layoutContext)
{
	// layout the children
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("Attempt to layout non-InlineableDisplayNode.");

		child->InlineLayout(layoutContext);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InlineDraw(InlineDrawContext* context)
{
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("Attempt to draw non-InlineableDisplayNode.");

		child->InlineDraw(context);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* InlineFindSelection(FindSelectionContext* context)
{
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("Attempt to find selection in non-InlineableDisplayNode.");

		Selection* selection = child->InlineFindSelection(context);
		if (selection)
			return selection;
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* InlineFindDestination(FindDestinationContext* context)
{
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("Attempt to find destination in non-InlineableDisplayNode.");

		Destination* destination = child->InlineFindDestination(context);
		if (destination)
			return destination;
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* InlineFindHotspot(FindHotspotContext* context)
{
	// if the mouse is in this node, see if there's a hotspot for it
	CoordPoint mousePoint(context->mouseX - context->xIndent,
	                      context->mouseY - context->curY);
	GlyphRef firstGlyph = FirstSelectableGlyph();
	GlyphRef lastGlyph = LastSelectableGlyph();
	if (!firstGlyph.IsValid() || !lastGlyph.IsValid() ||
			GlyphLoc(firstGlyph) > mousePoint)
		return NULL;
	if (GlyphLoc(lastGlyph) >= mousePoint) {
		Hotspot* hotspot = GetHotspot(context->director);
		if (hotspot)
			return hotspot;
		}

	// otherwise, check children
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("Attempt to find hotspot in non-InlineableDisplayNode.");

		Hotspot* hotspot = child->InlineFindHotspot(context);
		if (hotspot)
			return hotspot;
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef FirstSelectableGlyph()
{
	for (DisplayNode* childNode = firstChild; childNode; childNode = childNode->NextSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("CompositeDisplayNode::FirstGlyph: Child is not inline.");
		GlyphRef firstGlyph = child->FirstSelectableGlyph();
		if (firstGlyph.IsValid())	
			return firstGlyph;
		}

	return GlyphRef();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef LastSelectableGlyph()
{
	for (DisplayNode* childNode = lastChild; childNode; childNode = childNode->PreviousSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("CompositeDisplayNode::FirstGlyph: Child is not inline.");
		GlyphRef lastGlyph = child->LastSelectableGlyph();
		if (lastGlyph.IsValid())	
			return lastGlyph;
		}

	return GlyphRef();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef LastGlyph()
{
	for (DisplayNode* childNode = lastChild; childNode; childNode = childNode->PreviousSibling()) {
		InlineableDisplayNode* child = dynamic_cast<InlineableDisplayNode*>(childNode);
		if (child == NULL)
			throw InternalException("CompositeDisplayNode::FirstGlyph: Child is not inline.");
		GlyphRef lastGlyph = child->LastGlyph();
		if (lastGlyph.IsValid())	
			return lastGlyph;
		}

	return GlyphRef();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DOMChangeClient virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ChildInsertedBefore(Node* newChild, Node* refChild)
{
	// don't bother if we're not currently attached
	DisplayDirector* director = GetDisplayDirector();
	if (director == NULL) {
		// mark as needing a load, so we'll get one if added back into a document
		needsLoad = true;
		return;
		}

	// load
	Load(director);

	// get the child set up
	DisplayNode* childDisplayNode = director->DisplayNodeFor(newChild, false);
	if (childDisplayNode) {
		childDisplayNode->UpdateProperties();
		if (childDisplayNode == firstChild || childDisplayNode == lastChild)
			VerticalMarginsChanged();
		if (childDisplayNode->NeedsLoad())
			childDisplayNode->Load(director);
		}

	// layout & refresh
	BlockableDisplayNode* block = (GetDisplayType() == Block ? this : EnclosingLeafBlock());
	if (block == NULL)
		throw InternalException("ElementDisplayNode::ChildInsertedBefore: No block.");
	block->BlockLayout();
	block->RefreshAfter();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ChildRemoved(Node* oldChild)
{
	// don't bother if we're not currently attached
	DisplayDirector* director = GetDisplayDirector();
	if (director == NULL) {
		// mark as needing a load, so we'll get one if added back into a document
		needsLoad = true;
		return;
		}

	// load
	Load(director);
	VerticalMarginsChanged();

	// layout & refresh
	BlockableDisplayNode* block = (GetDisplayType() == Block ? this : EnclosingLeafBlock());
	if (block == NULL)
		throw InternalException("ElementDisplayNode::ChildInsertedBefore: No block.");
	block->BlockLayout();
	block->RefreshAfter();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ChildReplaced(Node* newChild, Node* oldChild)
{
	// don't bother if we're not currently attached
	DisplayDirector* director = GetDisplayDirector();
	if (director == NULL) {
		// mark as needing a load, so we'll get one if added back into a document
		needsLoad = true;
		return;
		}

	// load
	Load(director);

	// get the child set up
	DisplayNode* childDisplayNode = director->DisplayNodeFor(newChild, false);
	if (childDisplayNode) {
		childDisplayNode->UpdateProperties();
		if (childDisplayNode == firstChild || childDisplayNode == lastChild)
			VerticalMarginsChanged();
		if (childDisplayNode->NeedsLoad())
			childDisplayNode->Load(director);
		}

	// layout & refresh
	BlockableDisplayNode* block = (GetDisplayType() == Block ? this : EnclosingLeafBlock());
	if (block == NULL)
		throw InternalException("ElementDisplayNode::ChildReplaced: No block.");
	block->BlockLayout();
	block->RefreshAfter();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ClearChildren()
{
	DisplayNode* nextNode = NULL;
	for (DisplayNode* curNode = firstChild; curNode; curNode = nextNode) {
		nextNode = curNode->NextSibling();
		curNode->SetParent(NULL);
		curNode->SetPrevSibling(NULL);
		curNode->SetNextSibling(NULL);
		if (curNode->IsDisposable())
			delete curNode;
		}
	firstChild = lastChild = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LoadFromElement(Element* element, DisplayDirector* director)
{
	bool hadChildren = false;
	EditStylesheet* stylesheet = director->GetStylesheet();
	for (Node* child = element->FirstChild(); child; child = child->NextSibling()) {
		if (child->NodeType() == ELEMENT_NODE &&
		         stylesheet->PropertyForElement("display", child->NodeName()) == "none")
			continue;
		DisplayNode* displayNode = director->DisplayNodeFor(child);
		if (displayNode) {
			AppendChild(displayNode);
			hadChildren = true;
			}
		}

	// if empty, use placeholder text
	if (!hadChildren) {
		DOMString placeholderText =
			stylesheet->PropertyForElement("placeholder-text", element->NodeName());
		if (true /*** !placeholderText.empty() ***/) {
			PlaceholderTextDisplayNode* placeholderNode =
				new PlaceholderTextDisplayNode(placeholderText);
			AppendChild(placeholderNode);
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LoadFromContentsTemplate(Element* templateElement, Element* sourceElement, DisplayDirector* director)
{
	for (Node* child = templateElement->FirstChild(); child; child = child->NextSibling()) {
		DisplayNode* newDisplayNode = NULL;
		if (child->NodeType() == TEXT_NODE)
			newDisplayNode = new DisplayTextNode(dynamic_cast<Text*>(child));
		else if (child->NodeType() == ELEMENT_NODE) {
			DOMString tagName = child->NodeName();
			if (tagName == "display-element") {
				newDisplayNode =
					new DisplayElementNode(dynamic_cast<Element*>(child), sourceElement);
				}
			else if (tagName == "all-contents")
				LoadFromElement(sourceElement, director);
			}
		if (newDisplayNode)
			AppendChild(newDisplayNode);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LoadChildren(DisplayDirector* director)
{
	for (DisplayNode* child = firstChild; child; child = child->NextSibling()) {
		if (child->NeedsLoad())
			child->Load(director);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LayoutChildBlocks(bool force)
{
	int interBlockSpace = 0;
	int totalHeight = 0;
	for (DisplayNode* child = firstChild; child; child = child->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(child);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		if (force || childBlock->NeedsLayout())
			childBlock->BlockLayout(force);

		// calc the total height, accounting for space between the blocks
		totalHeight += childBlock->Height();
		if (childBlock != firstChild) {
			// use the max of the last child's bottom margin and the current child's
			// top margin, but this block's top margin isn't counted as part of
			// its height (which is why we don't do this on the first child block,
			// which contributes to this block's top margin
			int childTopMargin = childBlock->TopMargin();
			if (childTopMargin > interBlockSpace)
				interBlockSpace = childTopMargin;
			}
		totalHeight += interBlockSpace;
		interBlockSpace = childBlock->BottomMargin();
		}
	// note that we ignore the last interBlockSpace, since the bottom margin (including
	// the effect of the last child's bottom margin) doesn't count towards this
	// block's total height

	// finish setting up the total height
	HeightChangedTo(totalHeight);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LayoutInlineChildren()
{
	InlineLayoutContext layoutContext(Width(),
	                                  GetPropertyInPixels("text-indent", true),
	                                  GetInheritedProperty("text-align"));
	InlineLayout(&layoutContext);
	layoutContext.Finish();
	HeightChangedTo(layoutContext.TotalHeight());
	maxLineWidth = layoutContext.MaxLineWidth() + LeftSpace();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawChildBlocks(BlockDrawContext* context)
{
	int interBlockSpace = 0;
	for (DisplayNode* child = firstChild; child; child = child->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(child);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		// handle inter-block spacing (see LayoutChildBlocks() for a lengthier explanation)
		if (childBlock != firstChild) {
			int childTopMargin = childBlock->TopMargin();
			if (childTopMargin > interBlockSpace)
				interBlockSpace = childTopMargin;
			context->curY += interBlockSpace;
			}

		// check if we're done
		if (context->curY > context->endY) {
			return;
			}

		// draw or skip the child
		int childHeight = childBlock->Height();
		if (context->curY + childHeight < context->startY)
			context->curY += childHeight;
		else {
			childBlock->BlockDraw(context);
			}

		// set up to handle next inter-block space
		interBlockSpace = childBlock->BottomMargin();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawInlineChildren(BlockDrawContext* context)
{
	InlineDrawContext inlineDrawContext(context, LeftSpace());
	InlineDraw(&inlineDrawContext);
	context->curY += height;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* FindSelectionInChildBlocks(FindSelectionContext* context)
{
	int interBlockSpace = 0;
	for (DisplayNode* child = firstChild; child; child = child->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(child);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		// handle inter-block spacing (see LayoutChildBlocks() for a lengthier explanation)
		if (childBlock != firstChild) {
			int childTopMargin = childBlock->TopMargin();
			if (childTopMargin > interBlockSpace)
				interBlockSpace = childTopMargin;
			context->curY += interBlockSpace;
			}

		// check if we're done
		if (context->curY > context->mouseY) {
			// select between blocks
			return new BetweenBlocksSelection(this, childBlock);
			}

		// check or skip the child
		int childHeight = childBlock->Height();
		if (context->curY + childHeight < context->mouseY)
			context->curY += childHeight;
		else {
			Selection* selection = childBlock->BlockFindSelection(context);
			if (selection)
				return selection;
			}

		// set up to handle next inter-block space
		interBlockSpace = childBlock->BottomMargin();
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* FindSelectionInInlineChildren(FindSelectionContext* context)
{
	context->xIndent = LeftSpace();
	Selection* selection = InlineFindSelection(context);
	context->curY += height;
	return (selection ? selection : EndSelection());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* FindDestinationInChildBlocks(FindDestinationContext* context)
{
	int interBlockSpace = 0;
	BlockableDisplayNode* prevBlock = NULL;
	for (DisplayNode* child = firstChild; child; child = child->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(child);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		// handle inter-block spacing (see LayoutChildBlocks() for a lengthier explanation)
		if (childBlock != firstChild) {
			int childTopMargin = childBlock->TopMargin();
			if (childTopMargin > interBlockSpace)
				interBlockSpace = childTopMargin;
			context->curY += interBlockSpace;
			}

		// check if we're done
		if (context->mouseY < context->curY) {
			// destination is between blocks
			if (typeid(*context->source) == typeid(BlocksSelection) ||
					typeid(*context->source) == typeid(BlockElementSelection))
				return new BetweenBlocksDestination(context->source, this, prevBlock);
			else
				return NULL;
			}

		// check or skip the child
		int childHeight = childBlock->Height();
		if (context->curY + childHeight < context->mouseY)
			context->curY += childHeight;
		else {
			// check within the child
			Destination* destination = childBlock->BlockFindDestination(context);
			if (destination)
				return destination;
			// no destination within the child; check before and after
			// note that context->curY now include the childHeight
			if (context->mouseY < context->curY - childHeight / 2) {
				// destination is before the block
				if (typeid(*context->source) == typeid(BlocksSelection) ||
						typeid(*context->source) == typeid(BlockElementSelection))
					return new BetweenBlocksDestination(context->source, this, prevBlock);
				else
					return NULL;
				}
			else {
				// destination is after the block
				if (typeid(*context->source) == typeid(BlocksSelection) ||
						typeid(*context->source) == typeid(BlockElementSelection))
					return new BetweenBlocksDestination(context->source, this, childBlock);
				else
					return NULL;
				}
			}

		// set up to handle next inter-block space
		interBlockSpace = childBlock->BottomMargin();
		prevBlock = childBlock;
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* FindDestinationInInlineChildren(FindDestinationContext* context)
{
	context->xIndent = LeftSpace();
	Destination* destination = InlineFindDestination(context);
	context->curY += height;
	return destination;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* FindHotspotInChildBlocks(FindHotspotContext* context)
{
	int interBlockSpace = 0;
	for (DisplayNode* child = firstChild; child; child = child->NextSibling()) {
		BlockableDisplayNode* childBlock = dynamic_cast<BlockableDisplayNode*>(child);
		if (childBlock == NULL)
			throw InternalException("Non-leaf block has inline child.");

		// handle inter-block spacing (see LayoutChildBlocks() for a lengthier explanation)
		if (childBlock != firstChild) {
			int childTopMargin = childBlock->TopMargin();
			if (childTopMargin > interBlockSpace)
				interBlockSpace = childTopMargin;
			context->curY += interBlockSpace;
			}

		// check if we're done
		if (context->curY > context->mouseY)
			break;

		// check or skip the child
		int childHeight = childBlock->Height();
		if (context->curY + childHeight < context->mouseY)
			context->curY += childHeight;
		else {
			Hotspot* hotspot = childBlock->BlockFindHotspot(context);
			if (hotspot)
				return hotspot;
			}

		// set up to handle next inter-block space
		interBlockSpace = childBlock->BottomMargin();
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* FindHotspotInInlineChildren(FindHotspotContext* context)
{
	context->xIndent = LeftSpace();
	Hotspot* hotspot = InlineFindHotspot(context);
	context->curY += height;
	return hotspot;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void CheckIfBlock()
{
	DisplayNode* child;

	// check children
	bool hasBlockChildren = false;
	bool hasGeneratedLeafBlocks = false;
	bool hasDirectInlines = false;
	for (child = firstChild; child; child = child->NextSibling()) {
		if (typeid(*child) == typeid(GeneratedLeafBlock))
			hasGeneratedLeafBlocks = true;
		else if (child->GetDisplayType() == Block)
			hasBlockChildren = true;
		else
			hasDirectInlines = true;
		}

	// set block status
	isBlock = (hasBlockChildren || DeclaredDisplayType() == Block);
	isLeafBlock = (isBlock && !hasBlockChildren);

	// if we're a non-leaf block, we need to get rid of any nodes for ignorable whitespace
	if (isBlock && !isLeafBlock) {
		DisplayNode* nextChild;
		for (child = firstChild; child; child = nextChild) {
			nextChild = child->NextSibling();
			TextDisplayNode* textChild = dynamic_cast<TextDisplayNode*>(child);
			if (textChild && textChild->GetText()->IsIgnorableWhitespace()) {
				UnlinkChildren(child, child);
				delete child;
				}
			}
		}

	// if we're a non-leaf block, we need GeneratedLeafBlocks on any inline children
	if (isBlock && !isLeafBlock && hasDirectInlines) {
		GeneratedLeafBlock* curGenLeafBlock = NULL;
		for (child = firstChild; child; child = child->NextSibling()) {
			if (child->GetDisplayType() == Inline) {
				if (curGenLeafBlock == NULL) {
					// make the GeneratedLeafBlock & link it in
					curGenLeafBlock = new GeneratedLeafBlock(this);
					LinkChildrenBefore(curGenLeafBlock, curGenLeafBlock, child->NextSibling());
					}
				// add "child" to "curGenLeafBlock"
				UnlinkChildren(child, child);
				curGenLeafBlock->AppendChildren(child, child);
				child = curGenLeafBlock;	// keep the loop going
				}
			else if (curGenLeafBlock) {
				// close out the current GeneratedLeafBlock
				curGenLeafBlock = NULL;
				}
			}
		}

	// if we're inline, or a leaf block, we need to ablate any GeneratedLeafBlocks
	else if ((!isBlock || isLeafBlock) && hasGeneratedLeafBlocks) {
		for (child = firstChild; child; child = child->NextSibling()) {
			if (child->GetDisplayType() != Inline) {
				// ablate the GeneratedLeafBlock
				GeneratedLeafBlock* genLeafBlock = dynamic_cast<GeneratedLeafBlock*>(child);
				DisplayNode* firstToPromote = genLeafBlock->FirstChild();
				DisplayNode* lastToPromote = genLeafBlock->LastChild();
				genLeafBlock->UnlinkChildren(firstToPromote, lastToPromote);
				LinkChildrenBefore(firstToPromote, lastToPromote, genLeafBlock);
				UnlinkChildren(genLeafBlock, genLeafBlock);
				child = lastToPromote;	// keep the loop going
				}
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UnlinkChildren(DisplayNode* firstToUnlink, DisplayNode* lastToUnlink)
{
	// unlink
	if (firstToUnlink == firstChild)
		firstChild = firstToUnlink->NextSibling();
	if (lastToUnlink == lastChild)
		lastChild = lastToUnlink->PreviousSibling();
	DisplayNode* prevChild = firstToUnlink->PreviousSibling();
	DisplayNode* nextChild = lastToUnlink->NextSibling();
	if (prevChild)
		prevChild->SetNextSibling(nextChild);
	if (nextChild)
		nextChild->SetPrevSibling(prevChild);
	firstToUnlink->SetPrevSibling(NULL);
	lastToUnlink->SetNextSibling(NULL);

	// set parents
	for (DisplayNode* node = firstToUnlink; node; node = node->NextSibling())
		node->SetParent(NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LinkChildrenBefore(DisplayNode* firstToLink, DisplayNode* lastToLink, DisplayNode* beforeChild)
{
	if (beforeChild == NULL) {
		AppendChildren(firstToLink, lastToLink);
		return;
		}

	// link
	if (beforeChild == firstChild)
		firstChild = firstToLink;
	DisplayNode* prevChild = beforeChild->PreviousSibling();
	if (prevChild)
		prevChild->SetNextSibling(firstToLink);
	firstToLink->SetPrevSibling(prevChild);
	lastToLink->SetNextSibling(beforeChild);
	beforeChild->SetPrevSibling(lastToLink);

	// set parents
	for (DisplayNode* child = firstToLink; ; child = child->NextSibling()) {
		child->SetParent(this);
		if (child == lastToLink)
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendChildren(DisplayNode* firstToLink, DisplayNode* lastToLink)
{
	// link
	if (lastChild)
		lastChild->SetNextSibling(firstToLink);
	firstToLink->SetPrevSibling(lastChild);
	lastChild = lastToLink;
	if (firstChild == NULL)
		firstChild = firstToLink;

	// set parents
	for (DisplayNode* child = firstToLink; ; child = child->NextSibling()) {
		child->SetParent(this);
		if (child == lastToLink)
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendChild(DisplayNode* newChild)
{
	// link
	if (lastChild)
		lastChild->SetNextSibling(newChild);
	newChild->SetPrevSibling(lastChild);
	lastChild = newChild;
	if (firstChild == NULL)
		firstChild = newChild;

	// set parent
	newChild->SetParent(this);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* firstChild;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* lastChild;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isBlock;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isLeafBlock;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int topMargin;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int bottomMargin;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int maxLineWidth;	// valid only for leaf blocks
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GeneratedLeafBlock
</name>
<superclasses>
public CompositeDisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "CompositeDisplayNode.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "TextDisplayNode.h"
#include "Element.h"
#include "Text.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GeneratedLeafBlock(DisplayNode* parentIn)
	: CompositeDisplayNode(parentIn)
{
	// set these now, since we know what they are and CheckIfBlock() (which usually
	// sets them up) is not gonna get called.
	isBlock = true;
	isLeafBlock = true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType DeclaredDisplayType()
{
	return Block;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsLeafBlock()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDisposable()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width()
{
	return dynamic_cast<CompositeDisplayNode*>(parent)->Width();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* CurFont()
{
	return parent->CurFont();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BlockableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* FirstNode()
{
	ElementDisplayNode* elementNode = dynamic_cast<ElementDisplayNode*>(firstChild);
	if (elementNode)
		return elementNode->GetElement();
	TextDisplayNode* textNode = dynamic_cast<TextDisplayNode*>(firstChild);
	if (textNode)
		return textNode->GetText();
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* LastNode()
{
	ElementDisplayNode* elementNode = dynamic_cast<ElementDisplayNode*>(lastChild);
	if (elementNode)
		return elementNode->GetElement();
	TextDisplayNode* textNode = dynamic_cast<TextDisplayNode*>(lastChild);
	if (textNode)
		return textNode->GetText();
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanSelectAcross()
{
	// not really meaningful, since this is never an inline node
	return false;
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DocumentDisplayNode
</name>
<superclasses>
public CompositeDisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "CompositeDisplayNode.h"

class Document;
class DisplayDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "DisplayDirector.h"
#include "EditStylesheet.h"
#include "Font.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DocumentDisplayNode(Document* documentIn, DisplayDirector* directorIn)
	: CompositeDisplayNode(NULL), document(documentIn), displayDirector(directorIn),
	  font(NULL)
{
	document->AddChangeClient(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~DocumentDisplayNode()
{
	document->RemoveChangeClient(this);
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType DeclaredDisplayType()
{
	return Block;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDisposable()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Load(DisplayDirector* director)
{
	// remove children
	ClearChildren();

	// add the documentElement
	DisplayNode* docElementNode =
		director->DisplayNodeFor(document->DocumentElement());
	AppendChildren(docElementNode, docElementNode);

	LoadChildren(director);
	CheckIfBlock();

	CompositeDisplayNode::Load(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateProperties()
{
	// this is its own method to get better profiling results

	// ...plus it has to clear the cached font
	delete font;
	font = NULL;

	CompositeDisplayNode::UpdateProperties();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetProperty(string_slice propertyName)
{
	// try "#default"
	EditStylesheet* stylesheet = displayDirector->GetStylesheet();
	if (stylesheet == NULL)
		throw InternalException("DocumentDisplayNode::GetProperty: DisplayDirector has no stylesheet.");
	return stylesheet->PropertyForElement(propertyName, "#default");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* CurFont()
{
	if (font == NULL)
		font = GetFont();
	return font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BlockableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width()
{
	return displayDirector->DisplayWidth();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int LeftSpace()
{
	return 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void BlockLayout(bool force = false)
{
	// this is its own method to get better profile results
	CompositeDisplayNode::BlockLayout(force);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* FirstNode()
{
	return document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* LastNode()
{
	return document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanSelectAcross()
{
	// not really meaningful, since this is never an inline node
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DOMChangeClient virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ChildReplaced(Node* newChild, Node* oldChild)
{
	if (newChild == document->DocumentElement())
		displayDirector->DocTypeChanged();	// this'll take care of everything...
	else
		CompositeDisplayNode::ChildReplaced(newChild, oldChild);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* Director()
{
	return displayDirector;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* displayDirector;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ElementDisplayNode
</name>
<superclasses>
public CompositeDisplayNode, public StyleScriptable
</superclasses>
<hIncludes><![CDATA[
#include "CompositeDisplayNode.h"
#include "StyleScriptable.h"
#include "qstring.h"	//*** REMOVE FOR FINAL

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "DisplayDirector.h"
#include "EditStylesheet.h"
#include "Text.h"
#include "DisplayElementNode.h"
#include "PlaceholderTextDisplayNode.h"
#include "InlineElementSelection.h"
#include "BlockElementSelection.h"
#include "InlineElementHotspot.h"
#include "BlockElementHotspot.h"
#include "EmptyPlaceholderSelection.h"
#include "DOMUtils.h"
#include "Font.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode(Element* elementIn)
	: CompositeDisplayNode(NULL), element(elementIn), font(NULL)
{
	element->AddChangeClient(this);

	//*** REMOVE FOR FINAL
	// what's this all about?  The MW debugger craps out if you try to look deep enough
	// into an ElementDisplayNode to see the element name (I think it's that you
	// can't see into an STL list).  Since it's often helpful to see this when
	// debugging, we pull the tagName up here where it's visible and easy to get to
	debugTagName = element->TagName();
	debugTagName.c_str();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ElementDisplayNode()
{
	element->RemoveChangeClient(this);
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType DeclaredDisplayType()
{
	if (GetProperty("display") == "inline")
		return Inline;
	else
		return Block;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDisposable()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Load(DisplayDirector* director)
{
	// clear current children
	ClearChildren();

	// load immediate children
	Element* contentsTemplate =
		director->GetStylesheet()->ContentsTemplateForElement(element->NodeName());
	if (contentsTemplate)
		LoadFromContentsTemplate(contentsTemplate, element, director);
//***		AppendChild(new DisplayElementNode(contentsTemplate, element));
	else
		LoadFromElement(element, director);

#ifdef MOVED_TO_CompositeDisplayNode
	// if empty, use placeholder text
	if (firstChild == NULL) {
		DOMString placeholderText = GetProperty("placeholder-text");
		if (true /*** !placeholderText.empty() ***/) {
			PlaceholderTextDisplayNode* placeholderNode =
				new PlaceholderTextDisplayNode(placeholderText);
			AppendChildren(placeholderNode, placeholderNode);
			}
		}
#endif

	LoadChildren(director);
	CheckIfBlock();

	CompositeDisplayNode::Load(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateProperties()
{
	// clear the cached font
	delete font;
	font = NULL;

	CompositeDisplayNode::UpdateProperties();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetProperty(string_slice propertyName)
{
	DisplayDirector* director = GetDisplayDirector();
	if (director == NULL)
		throw InternalException("An ElementDisplayNode couldn't find its Director");
	EditStylesheet* stylesheet = director->GetStylesheet();
	if (stylesheet == NULL)
		throw InternalException("DisplayDirector has no stylesheet.");
	return Eval(stylesheet->PropertyForElement(propertyName, element->TagName()));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* GetElement()
{
	return element;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* GetSelection()
{
	if (GetDisplayType() == Inline) {
		// handle empty placeholder specially
		if (!element->HasChildNodes()) {
			PlaceholderTextDisplayNode* placeholder =
				dynamic_cast<PlaceholderTextDisplayNode*>(firstChild);
			if (useAssertions && placeholder == NULL)
				throw InternalException("ElementDisplayNode::GetSelection: Couldn't get placeholder.");
			if (placeholder->IsEmpty())
				return new EmptyPlaceholderSelection(placeholder);
			}

		return new InlineElementSelection(this);
		}
	else
		return new BlockElementSelection(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* GetHotspot(DisplayDirector* director)
{
	// first, make sure it's really hot
	EditStylesheet* stylesheet = director->GetStylesheet();
	string_slice tagName = element->TagName();
	DOMString linkProperty = stylesheet->PropertyForElement("link", tagName);
	if (!linkProperty.empty()) {
		if (linkProperty.startsWith("attr(")) {
			DOMString attrName = linkProperty.substr(5, linkProperty.length() - 6);
			if (element->GetAttribute(attrName).empty())
				return NULL;
			}
		}
	else {
		DOMString actionProperty = Eval(stylesheet->PropertyForElement("action", tagName));
		if (actionProperty.empty())
			return NULL;
		if (actionProperty.startsWith("attr(")) {
			DOMString attrName = actionProperty.substr(5, actionProperty.length() - 6);
			if (element->GetAttribute(attrName).empty())
				return NULL;
			}
		}

	// return the hotspot
	if (GetDisplayType() == Inline)
		return new InlineElementHotspot(this);
	else
		return new BlockElementHotspot(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* CurFont()
{
	if (font == NULL)
		font = GetFont();
	return font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BlockableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* FirstNode()
{
	return element;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* LastNode()
{
	return element;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanSelectAcross()
{
	/*** ??? ***/
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"StyleScriptable virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetScriptProperty(DOMString property)
{
	if (property == "tag-name")
		return element->TagName();
	else if (property == "director")
		return GetDisplayDirector()->AsString();
	else if (property == "contents")
		return DOMUtils::NodeContents(element);
	else
		return StyleScriptable::GetScriptProperty(property);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString FunctionCall(DOMString function, DOMString arg, StyleScriptable* target)
{
	if (function == "attr")
		return element->GetAttribute(arg);
	else
		return StyleScriptable::FunctionCall(function, arg, target);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* element;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring debugTagName;	//*** REMOVE FOR FINAL, this is just because MW debugger won't go deep enuf to see the tagName
]]></variable>

</class>


<class mod-time="Sun, 02 Apr 2000 18:18:25 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TextDisplayNode
</name>
<superclasses>
public InlineableDisplayNode, public DOMChangeClient
</superclasses>
<hIncludes><![CDATA[
#include "InlineableDisplayNode.h"
#include "DOMChangeClient.h"
#include "CoordPoint.h"
#include "Color.h"

class Text;
class Text;
class GlyphList;
class Glyph;
class Selection;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "Word.h"
#include "SmartenedWord.h"
#include "Space.h"
#include "PreSpace.h"
#include "LineBreak.h"
#include "Tab.h"
#include "SmartMDash.h"
#include "SmartSingleQuote.h"
#include "SmartDoubleQuote.h"
#include "InlineLayoutContext.h"
#include "InlineDrawContext.h"
#include "GlyphDrawContext.h"
#include "FindSelectionContext.h"
#include "FindDestinationContext.h"
#include "CharacterSelection.h"
#include "BetweenGlyphsSelection.h"
#include "BetweenWordsSelection.h"
#include "GlyphsSelection.h"
#include "InlineElementSelection.h"
#include "SpaceDestination.h"
#include "BetweenGlyphsDestination.h"
#include "BlockableDisplayNode.h"
#include "StyleParser.h"
#include "View.h"
#include "Font.h"
#include "UTF8Utils.h"
#include "InternalException.h"
#include <vector>
#include <typeinfo>

class GlyphList : public vector<Glyph*> {};

enum {
	NoGlyphType,
	WhitespaceGlyph,
	PreSpaceGlyph,
	LineBreakGlyph,
	TabGlyph,
	WordGlyph,
	SmartenedWordGlyph,
	PunctGlyph,
	MDashGlyph,
	SingleQuoteGlyph,
	DoubleQuoteGlyph,
	OpenParenGlyph,
	EndGlyphType
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextDisplayNode(Text* textIn)
	: text(textIn), font(NULL), isPreSpace(false)
{
	glyphs = new GlyphList();
	text->AddChangeClient(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TextDisplayNode()
{
	text->RemoveChangeClient(this);
	ClearGlyphs();
	delete glyphs;
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType GetDisplayType()
{
	return Inline;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsLeafBlock()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDisposable()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Load(DisplayDirector* director)
{
	UpdatePreSpace();
	ClearGlyphs();
	CreateGlyphs();

	InlineableDisplayNode::Load(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdateProperties()
{
	// font
	delete font;
	font = GetFont();
	for (GlyphList::iterator g = glyphs->begin(); g != glyphs->end(); ++g)
		(*g)->UncacheWidth();

	// color
	DOMString colorStr = GetInheritedProperty("color");
	color = StyleParser::ParseColor(colorStr);

	// pre-space
	UpdatePreSpace();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType DeclaredDisplayType()
{
	return Inline;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* AsBlockableDisplayNode()
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* StartSelection()
{
	Glyph* firstGlyph = (glyphs->empty() ? NULL : glyphs->front());
	return new BetweenGlyphsSelection(this, NULL, firstGlyph, false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* EndSelection()
{
	Glyph* lastGlyph = (glyphs->empty() ? NULL : glyphs->back());
	return new BetweenGlyphsSelection(this, lastGlyph, NULL, true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* FirstChild()
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* LastChild()
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* CurFont()
{
	return font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InlineLayout(InlineLayoutContext* layoutContext)
{
	// sanity clause
	if (font == NULL) {
		UpdateProperties();
		if (NeedsLoad())
			Load(GetDisplayDirector());
		}
/***
	if (font == NULL)
		throw InternalException("TextDisplayNode::UpdateProperties() not called before layout.");
***/

	layoutContext->SetFont(font);
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;
		layoutContext->AddGlyph(glyph);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InlineDraw(InlineDrawContext* context)
{
	// sanity clause
	if (font == NULL)
		throw InternalException("TextDisplayNode::UpdateProperties() not called before draw.");

	View* view = context->view;
	view->SetFont(font);
	view->SetHighColor(color);
	GlyphDrawContext
		glyphDrawContext(context->originX, context->originY, view, font,
		                 context->startY, context->endY);
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp)
		(*gp)->Draw(&glyphDrawContext);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* InlineFindSelection(FindSelectionContext* context)
{
	int mouseY = context->mouseY - context->curY;
	int mouseX = context->mouseX - context->xIndent;
	int lineHeight = font->LineHeight();
	int lineBottom = 0;
	Glyph* prevGlyph = NULL;
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); prevGlyph = *gp, ++gp) {
		Glyph* glyph = *gp;

		// see if we're even on the right line
		int glyphY = glyph->GetY();
		if (glyphY >= lineBottom) {
			// we're on a new line
			lineBottom = glyphY + lineHeight;
			if (mouseY < glyphY) {
				// clicked at end of line, presumably after a space
				Space* prevSpace = dynamic_cast<Space*>(prevGlyph);
				if (prevSpace)
					return new BetweenWordsSelection(this, prevSpace);
				else {
					// ...probably should never happen...
					return new BetweenGlyphsSelection(this, prevGlyph, glyph, false);
					}
				}
			}
		if (mouseY > lineBottom)
			continue;

		// see if the mouse is in the current glyph
		int glyphX = glyph->GetX();
		if (mouseX >= glyphX && mouseX < glyphX + glyph->Width(font)) {
			// we've found it!
			// is it a word?
			Word* word = dynamic_cast<Word*>(glyph);
			if (word) {
				// find out what character it's at
				int charIndex = font->CharIndexAtX(mouseX - glyphX, word->GetDisplayWord());
				charIndex = word->DisplayToDocOffset(charIndex);
				if (charIndex == 0)
					return new BetweenGlyphsSelection(this, prevGlyph, glyph, false);
				else if (charIndex == word->NumCharsInText()) {
					Glyph* nextGlyph = NULL;
					if (++gp != glyphs->end())
						nextGlyph = *gp;
					return new BetweenGlyphsSelection(this, glyph, nextGlyph, false);
					}
				else
					return new CharacterSelection(this, word, charIndex);				
				}
			// ... a space?
			Space* space = dynamic_cast<Space*>(glyph);
			if (space)
				return new BetweenWordsSelection(this, space);
			// otherwise, we've got a problem...
			return NULL;
			}
		}

	// didn't find anything
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* InlineFindDestination(FindDestinationContext* context)
{
	// only GlyphsSelections are allowed here
	Selection* source = context->source;
	if (typeid(*source) != typeid(GlyphsSelection) && typeid(*source) != typeid(InlineElementSelection))
		return NULL;

	// search for a destination
	int mouseY = context->mouseY - context->curY;
	int mouseX = context->mouseX - context->xIndent;
	int lineHeight = font->LineHeight();
	int lineBottom = 0;
	Glyph* prevGlyph = NULL;
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); prevGlyph = *gp, ++gp) {
		Glyph* glyph = *gp;

		// see if we're even on the right line
		int glyphY = glyph->GetY();
		if (glyphY >= lineBottom) {
			// we're on a new line
			lineBottom = glyphY + lineHeight;
			if (mouseY < glyphY) {
				// clicked at end of line, presumably after a space
				Space* prevSpace = dynamic_cast<Space*>(prevGlyph);
				if (prevSpace)
					return new SpaceDestination(source, this, prevSpace);
				else {
					// probably should never happen...
					return new BetweenGlyphsDestination(source, this, prevGlyph, glyph);
					}
				}
			}
		if (mouseY > lineBottom)
			continue;

		// see if the mouse is in the current glyph
		int glyphX = glyph->GetX();
		if (mouseX >= glyphX && mouseX < glyphX + glyph->Width(font)) {
			// we've found it!
			// is it a space?
			Space* space = dynamic_cast<Space*>(glyph);
			if (space)
				return new SpaceDestination(source, this, space);
			// is it before or after?
			if (mouseX > glyphX + glyph->Width(font) / 2) {
				// it's after
				++gp;
				Glyph* nextGlyph = (gp != glyphs->end() ? *gp : NULL);
				if (nextGlyph) {
					Space* nextSpace = dynamic_cast<Space*>(nextGlyph);
					if (nextSpace)
						return new SpaceDestination(source, this, nextSpace);
					}
				return new BetweenGlyphsDestination(source, this, glyph, nextGlyph);
				}
			else {
				// it's before
				Space* prevSpace = dynamic_cast<Space*>(prevGlyph);
				if (prevSpace)
					return new SpaceDestination(source, this, prevSpace);
				else
					return new BetweenGlyphsDestination(source, this, prevGlyph, glyph);
				}
			}
		}

	// didn't find anything
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Hotspot* InlineFindHotspot(FindHotspotContext* context)
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanSelectAcross()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef FirstSelectableGlyph()
{
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;
		if (!glyph->IsWhitespace())
			return GlyphRef(this, glyph);
		}

	return GlyphRef();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef LastSelectableGlyph()
{
	for (GlyphList::reverse_iterator gp = glyphs->rbegin(); gp != glyphs->rend(); ++gp) {
		Glyph* glyph = *gp;
		if (!glyph->IsWhitespace())
			return GlyphRef(this, glyph);
		}

	return GlyphRef();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef FirstGlyph()
{
	if (glyphs->empty())
		return GlyphRef();

	return GlyphRef(this, glyphs->front());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef LastGlyph()
{
	if (glyphs->empty())
		return GlyphRef();

	return GlyphRef(this, glyphs->back());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DOMChangeClient virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DataInserted(unsigned long offset, DOMString arg)
{
	ClearGlyphs();
	CreateGlyphs();
	BlockableDisplayNode* enclosingLeafBlock = EnclosingLeafBlock();
	if (enclosingLeafBlock) {
		enclosingLeafBlock->BlockLayout();
		enclosingLeafBlock->RefreshAfter();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DataDeleted(unsigned long offset, unsigned long count)
{
	ClearGlyphs();
	CreateGlyphs();
	BlockableDisplayNode* enclosingLeafBlock = EnclosingLeafBlock();
	if (enclosingLeafBlock) {
		enclosingLeafBlock->BlockLayout();
		enclosingLeafBlock->RefreshAfter();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DataSet(DOMString newData)
{
	ClearGlyphs();
	CreateGlyphs();
	BlockableDisplayNode* enclosingLeafBlock = EnclosingLeafBlock();
	if (enclosingLeafBlock) {
		enclosingLeafBlock->BlockLayout();
		enclosingLeafBlock->RefreshAfter();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NodeDying()
{
	delete this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access & Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* GetText()
{
	return text;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long TextOffset()
{
	// eventually, when sentence handling is added, one Text node will potentially
	// have several associated TextDisplayNodes.  When that happens, this method
	// will change.
	return 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int OffsetOfGlyph(Glyph* whichGlyph)
{
	int offset = TextOffset();
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;
		if (glyph == whichGlyph)
			return offset;
		offset += glyph->NumCharsInText();
		}
	return -1;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* GlyphBefore(Glyph* whichGlyph)
{
	Glyph* prevGlyph = NULL;
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;
		if (glyph == whichGlyph)
			return prevGlyph;
		prevGlyph = glyph;
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* GlyphAfter(Glyph* whichGlyph)
{
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;
		if (glyph == whichGlyph) {
			++gp;
			if (gp == glyphs->end())
				return NULL;
			return *gp;
			}
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsPreSpace()
{
	return isPreSpace;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Other Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* GetSelectionAtOffset(int offset)
{
	Glyph* prevGlyph = NULL;
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end() && offset >= 0; ++gp) {
		Glyph* glyph = *gp;
		if (offset == 0)
			return new BetweenGlyphsSelection(this, prevGlyph, glyph, true);
		int numChars = glyph->NumCharsInText();
		if (offset < numChars) {
			// it's in this glyph
			// is it a word?
			Word* word = dynamic_cast<Word*>(glyph);
			if (word)
				return new CharacterSelection(this, word, offset);
			// ...a space?
			Space* space = dynamic_cast<Space*>(glyph);
			if (space)
				return new BetweenWordsSelection(this, space);
			// ...otherwise we don't know what it is
			return NULL;
			}
		offset -= numChars;
		prevGlyph = glyph;
		}
	return new BetweenGlyphsSelection(this, prevGlyph, NULL, true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* GlyphAtPoint(CoordPoint point)
	// NOTE: returns the NON-WHITESPACE glyph nearest the point
{
	int lineHeight = font->LineHeight();
	int lineBottom = 0;
	Glyph* prevGlyph = NULL;
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;

		// see if we're even on the right line
		int glyphY = glyph->GetY();
		if (glyphY >= lineBottom) {
			// we're on a new line
			lineBottom = glyphY + lineHeight;
			if (point.y < glyphY) {
				// clicked at end of line
				return prevGlyph;
				}
			}
		if (point.y > lineBottom) {
			if (!glyph->IsWhitespace())
				prevGlyph = glyph;
			continue;
			}

		// see if the point is in the current glyph
		int glyphX = glyph->GetX();
		if (point.x >= glyphX && point.x < glyphX + glyph->Width(font)) {
			// we've found it!  return it, unless it's whitespace, in which case
			// return the previous non-whitespace glyph
			return (glyph->IsWhitespace() ? prevGlyph : glyph);
			}

		// continue
		if (!glyph->IsWhitespace())
			prevGlyph = glyph;
		}

	return prevGlyph;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* GlyphAtOffset(unsigned long offset)
{
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp) {
		Glyph* glyph = *gp;
		unsigned long glyphLen = glyph->NumCharsInText();

		if (offset < glyphLen)
			return glyph;

		offset -= glyphLen;
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Sun, 02 Apr 2000 18:18:25 PDT"><![CDATA[
void CreateGlyphs()
{
	DOMString data = text->Data();
	const char* p = data.begin();
	const char* stopper = data.end();
	const char* glyphStart = p;
	int glyphType = NoGlyphType;
	int prevGlyphType = NoGlyphType;
	bool smartenWord = false;
	for (; ; ++p) {
		// get the next character
		int charGlyphType;
		if (p == stopper)
			charGlyphType = EndGlyphType;

		else {
			char c = *p;
			switch (c) {
				case ' ':
					charGlyphType = WhitespaceGlyph;
					break;

				case '\t':
					charGlyphType = (isPreSpace ? TabGlyph : WhitespaceGlyph);
					break;

				case '\n':
				case '\r':
					charGlyphType = (isPreSpace ? LineBreakGlyph : WhitespaceGlyph);
					break;

				case '.':
				case ',':
				case '!':
				case '?':
				case ')':
				case ']':
				case ';':
				case ':':
					charGlyphType = PunctGlyph;
					break;

				case '(':
				case '[':
					charGlyphType = OpenParenGlyph;
					break;

				case '"':
					charGlyphType = DoubleQuoteGlyph;
					break;

				case '\'':
					if (glyphType == NoGlyphType || glyphType == WhitespaceGlyph ||
							glyphType == OpenParenGlyph) {
						charGlyphType = SingleQuoteGlyph;
						}
					else {
						charGlyphType = WordGlyph;
						smartenWord = true;
						}
					break;

				case '-':
					++p;
					if (p < stopper && *p == '-') {
						// double-hyphen--smarten it into an m-dash
						charGlyphType = MDashGlyph;
						--p;
						}
					else {
						--p;
						charGlyphType = WordGlyph;
						}
					break;

				default:
					charGlyphType = WordGlyph;
					break;
				}
			}

		if (charGlyphType != glyphType && glyphType != NoGlyphType) {
			if (glyphType == WordGlyph && smartenWord)
				glyphType = SmartenedWordGlyph;
			else if (glyphType == WhitespaceGlyph && isPreSpace)
				glyphType = PreSpaceGlyph;
			AddGlyph(string_slice(glyphStart, p), glyphType, prevGlyphType);
			prevGlyphType = glyphType;
			glyphType = NoGlyphType;
			smartenWord = false;
			}
		switch (charGlyphType) {
			case EndGlyphType:
				return;
			case WordGlyph:
			case WhitespaceGlyph:
				// accumulate characters into the glyph
				if (glyphType == NoGlyphType)
					glyphStart = p;
				glyphType = charGlyphType;
				break;
			case MDashGlyph:
				// handle this a little specially, since "p" is pointing at two
				// characters instead of just one
				AddGlyph(string_slice(p, p + 2), charGlyphType, prevGlyphType);
				prevGlyphType = MDashGlyph;
				p++;	// consume second '-'
				break;
			default:
				AddGlyph(string_slice(p, p + 1), charGlyphType, prevGlyphType);
				prevGlyphType = charGlyphType;
				break;
			}
		}
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:07:18 PST"><![CDATA[
void AddGlyph(string_slice glyphText, int glyphType, int prevGlyphType)
{
	if (glyphType == NoGlyphType || glyphText.empty())
		return;

	bool opening;
	switch (glyphType) {
		case WordGlyph:
		case PunctGlyph:
		case OpenParenGlyph:
			glyphs->push_back(new Word(glyphText, (glyphType != WordGlyph)));
			break;

		case WhitespaceGlyph:
			glyphs->push_back(new Space(glyphText));
			break;

		case PreSpaceGlyph:
			glyphs->push_back(new PreSpace(glyphText));
			break;

		case LineBreakGlyph:
			glyphs->push_back(new LineBreak(glyphText));
			break;

		case TabGlyph:
			glyphs->push_back(new Tab());
			break;

		case SmartenedWordGlyph:
			{
			bool trailingSingleQuote = false;
			if (glyphText[glyphText.length() - 1] == '\'') {
				// trailing "'" is a single-quote, not an apostrophe
				glyphText.resize(glyphText.length() - 1);
				trailingSingleQuote = true;
				}
			if (!glyphText.empty())
				glyphs->push_back(new SmartenedWord(glyphText));
			if (trailingSingleQuote)
				glyphs->push_back(new SmartSingleQuote(false));
			}
			break;

		case MDashGlyph:
			glyphs->push_back(new SmartMDash());
			break;

		case SingleQuoteGlyph:
			opening =
				(prevGlyphType == NoGlyphType || prevGlyphType == WhitespaceGlyph ||
				 prevGlyphType == OpenParenGlyph);
			glyphs->push_back(new SmartSingleQuote(opening));
			break;

		case DoubleQuoteGlyph:
			opening =
				(prevGlyphType == NoGlyphType || prevGlyphType == WhitespaceGlyph ||
				 prevGlyphType == OpenParenGlyph);
			glyphs->push_back(new SmartDoubleQuote(opening));
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ClearGlyphs()
{
	for (GlyphList::iterator gp = glyphs->begin(); gp != glyphs->end(); ++gp)
		delete *gp;
	glyphs->clear();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UpdatePreSpace()
{
	bool newPreSpace = (GetInheritedProperty("white-space") == "pre");
	if (isPreSpace != newPreSpace)
		needsLoad = true;
	isPreSpace = newPreSpace;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphList* glyphs;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Color color;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isPreSpace;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
PlaceholderTextDisplayNode
</name>
<superclasses>
public TextDisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "TextDisplayNode.h"

class ElementDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "DisplayDirector.h"
#include "EditStylesheet.h"
#include "ElementDisplayNode.h"
#include "EmptyPlaceholderSelection.h"
#include "FindSelectionContext.h"
#include "GlyphLoc.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PlaceholderTextDisplayNode(DOMString placeholderText)
	: TextDisplayNode(new Text(placeholderText))
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~PlaceholderTextDisplayNode()
{
	delete text;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsEmpty()
{
	return (text->Length() == 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetProperty(string_slice propertyName)
{
	DisplayDirector* director = GetDisplayDirector();
	if (director == NULL)
		throw InternalException("An ElementDisplayNode couldn't find its Director");
	EditStylesheet* stylesheet = director->GetStylesheet();
	if (stylesheet == NULL)
		throw InternalException("DisplayDirector has no stylesheet.");
	return stylesheet->PropertyForElement(propertyName, "#placeholder-text");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* StartSelection()
{
	ElementDisplayNode* elementNode = ParentElementNode();
	if (text->Length() == 0)
		return new EmptyPlaceholderSelection(this);
	else
		return elementNode->GetSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* EndSelection()
{
	ElementDisplayNode* elementNode = ParentElementNode();
	if (text->Length() == 0)
		return new EmptyPlaceholderSelection(this);
	else
		return elementNode->GetSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InlineLayout(InlineLayoutContext* layoutContext)
{
	// sometimes UpdateProperties() doesn't get called (eg. after deleting an elements nodes)
	if (font == NULL)
		UpdateProperties();

	TextDisplayNode::InlineLayout(layoutContext);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* InlineFindSelection(FindSelectionContext* context)
{
	// see if we should select the element
	GlyphRef firstGlyph = FirstGlyph();
	if (!firstGlyph.IsValid())
		return NULL;
	GlyphRef lastGlyph = LastGlyph();
	CoordPoint mousePoint(context->mouseX - context->xIndent,
	                      context->mouseY - context->curY);
	if (GlyphLoc(firstGlyph) > mousePoint || GlyphLoc(lastGlyph) < mousePoint)
		return NULL;

	// select the element
	return ParentElementNode()->GetSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination* InlineFindDestination(FindDestinationContext* context)
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode* ParentElementNode()
{
	for (DisplayNode* node = Parent(); node; node = node->Parent()) {
		ElementDisplayNode* elementNode = dynamic_cast<ElementDisplayNode*>(node);
		if (elementNode)
			return elementNode;
		}
	throw InternalException("PlaceholderTextDisplayNode::ParentElementNode: no parent Element.");
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayTextNode
</name>
<superclasses>
public TextDisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "TextDisplayNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayTextNode(Text* textIn)
	: TextDisplayNode(textIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDisposable()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* StartSelection()
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* EndSelection()
{
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"InlineableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanSelectAcross()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* InlineFindSelection(FindSelectionContext* context)
{
	return NULL;
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayElementNode
</name>
<superclasses>
public CompositeDisplayNode
</superclasses>
<hIncludes><![CDATA[
#include "CompositeDisplayNode.h"

class Element;
class Font;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Text.h"
#include "DisplayTextNode.h"
#include "Font.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayElementNode(Element* templateElementIn, Element* sourceElementIn)
	: CompositeDisplayNode(NULL),
	  templateElement(templateElementIn), sourceElement(sourceElementIn),
	  font(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~DisplayElementNode()
{
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayType DeclaredDisplayType()
{
	if (GetProperty("display") == "inline")
		return Inline;
	else
		return Block;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsDisposable()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetProperty(string_slice propertyName)
{
	return templateElement->GetAttribute(propertyName);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Load(DisplayDirector* director)
{
	// load immediate children
	ClearChildren();
	LoadFromContentsTemplate(templateElement, sourceElement, director);
/***
	for (Node* child = templateElement->FirstChild(); child; child = child->NextSibling()) {
		DisplayNode* newDisplayNode = NULL;
		if (child->NodeType() == TEXT_NODE)
			newDisplayNode = new DisplayTextNode(dynamic_cast<Text*>(child));
		else if (child->NodeType() == ELEMENT_NODE) {
			DOMString tagName = child->NodeName();
			if (tagName == "display-element") {
				newDisplayNode =
					new DisplayElementNode(dynamic_cast<Element*>(child), sourceElement);
				}
			else if (tagName == "all-contents")
				LoadFromElement(sourceElement, director);
			}
		if (newDisplayNode)
			AppendChild(newDisplayNode);
		}
***/

	LoadChildren(director);
	CheckIfBlock();

	CompositeDisplayNode::Load(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanSelectAcross()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* CurFont()
{
	if (font == NULL)
		font = GetFont();
	return font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BlockableDisplayNode virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* FirstNode()
{
	//*** ???
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* LastNode()
{
	//*** ???
	return NULL;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* templateElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* sourceElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

</class>


<class mod-time="Wed, 12 Apr 2000 20:01:18 PDT" wind-frame="64.000000,67.000000,704.000000,597.000000" list-views-height="0.000000">
<name>
Glyph
</name>
<hIncludes><![CDATA[

class Font;
class GlyphDrawContext;
class TextDisplayNode;
class Selection;
class Action;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphDrawContext.h"
#include "Font.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph()
{
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:03:25 PST"><![CDATA[
virtual ~Glyph()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline void SetPosition(int newX, int newY, int newLine)
{
	x = newX;
	y = newY;
	line = newLine;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AdjustX(int xDelta)
{
	x += xDelta;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AdjustY(int yDelta)
{
	y += yDelta;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int Width(Font* font) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void UncacheWidth()
{
	// default: do nothing--not every Glyph actually does cache its width
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(GlyphDrawContext* context) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsWhitespace()
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsPunctuation()
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsLineBreak()
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsPreSpace()
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsTab()
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int NumCharsInText() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Action* DeleteFrontAction(TextDisplayNode* textNode) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Action* DeleteBackAction(TextDisplayNode* textNode) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* SelectionIntoFront(TextDisplayNode* textNode) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* SelectionIntoBack(TextDisplayNode* textNode) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool ShouldBindBefore() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool ShouldBindAfter() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int GetX()
{
	return x;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int GetY()
{
	return y;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetLine()
{
	return line;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helper"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldDraw(GlyphDrawContext* context)
{
	int top = y + context->originY;
	Font* font = context->font;
	return (top >= context->startY && top + font->LineHeight() <= context->endY);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int x;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int y;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int line;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:09:21 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Word
</name>
<superclasses>
public Glyph
</superclasses>
<hIncludes><![CDATA[
#include "Glyph.h"
#include "DOMString.h"

class qstring;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphDrawContext.h"
#include "TextDisplayNode.h"
#include "Text.h"
#include "BackCharsAction.h"
#include "View.h"
#include "Font.h"
#include "UTF8Utils.h"
#include "qstring.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:09:21 PST"><![CDATA[
Word(DOMString wordIn, bool isPunctuationIn = false)
	: word(wordIn), width(0), isPunctuation(isPunctuationIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	if (width == 0)
		width = font->WidthOf(word);
	return width;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UncacheWidth()
{
	width = 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	// see if we really should draw
	int top = y + context->originY;
	Font* font = context->font;
	if (top < context->startY || top + font->LineHeight() > context->endY)
		return;

	View* view = context->view;
	view->MovePenTo(x + context->originX, top + font->Ascent());
	view->DrawString(word);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumCharsInText()
{
	return word.length();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteFrontAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteBackAction(TextDisplayNode* textNode)
{
	// find the offset, making sure we've got the first byte of the character
	int offset = word.length() - 1;
	const char* wordStr = word.begin();
	while (offset > 0 && !UTF8Utils::IsFirstByte(wordStr[offset]))
		--offset;

	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this) + offset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoFront(TextDisplayNode* textNode)
{
	// find the start of the second character, accounting for UTF8
	int offset = 1;
	const char* str = word.begin();
	int len = word.length();
	while (offset < len && !UTF8Utils::IsFirstByte(str[offset]))
		++offset;
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this) + offset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoBack(TextDisplayNode* textNode)
{
	// find the start of the last character, accounting for UTF8
	int offset = word.length() - 1;
	const char* str = word.begin();
	while (offset > 0 && !UTF8Utils::IsFirstByte(str[offset]))
		--offset;
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this) + offset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsPunctuation()
{
	return isPunctuation;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindBefore()
{
	return (word == "." ||
	        word == "..." ||
	        word == "\'" || word == "\"" ||		//*** these will go away when we do smart quotes
	        word == "," ||
	        word == "?" ||
	        word == "!" ||
	        word == ")" ||
	        word == "]" ||
	        word == ";" ||
	        word == ":");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindAfter()
{
	return (word == "(" || word == "[" ||
	        word == "\'" || word == "\""		//*** these will go away when we do smart quotes
	        );
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual string_slice GetDisplayWord()
{
	return word;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int DocToDisplayOffset(int docOffset)
{
	return docOffset;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int DisplayToDocOffset(int displayOffset)
{
	return displayOffset;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString word;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
short width;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool isPunctuation;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SmartenedWord
</name>
<superclasses>
public Word
</superclasses>
<hIncludes><![CDATA[
#include "Word.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphDrawContext.h"
#include "Font.h"
#include "View.h"
#include "UTF8Utils.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SmartenedWord(DOMString wordIn)
	: Word(wordIn)
{
	// smarten the displayWord
	const char* p = word.begin();
	const char* charsStart = p;
	for (; p != word.end(); ++p) {
		if (*p == '\'') {
			if (p > charsStart)
				displayWord += string_slice(charsStart, p);
			displayWord += "’";
			charsStart = p + 1;
			}
		}
	if (p > charsStart)
		displayWord += string_slice(charsStart, p);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	if (width == 0)
		width = font->WidthOf(displayWord);
	return width;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	// see if we really should draw
	int top = y + context->originY;
	Font* font = context->font;
	if (top < context->startY || top + font->LineHeight() > context->endY)
		return;

	View* view = context->view;
	view->MovePenTo(x + context->originX, top + font->Ascent());
	view->DrawString(displayWord);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Word virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetDisplayWord()
{
	return displayWord;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int DocToDisplayOffset(int docOffset)
{
	int numChars = UTF8Utils::CharsInString(word.substr(0, docOffset));
	return UTF8Utils::BytesForNChars(displayWord, numChars);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual int DisplayToDocOffset(int displayOffset)
{
	int numChars = UTF8Utils::CharsInString(displayWord.substr(0, displayOffset));
	return UTF8Utils::BytesForNChars(word, numChars);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString displayWord;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Space
</name>
<superclasses>
public Glyph
</superclasses>
<hIncludes><![CDATA[
#include "Glyph.h"
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Text.h"
#include "BackCharsAction.h"
#include "BetweenWordsSelection.h"
#include "Font.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Space(string_slice text)
	: numCharsInText(text.length())
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	return font->SpaceWidth();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	// don't have to do anything...
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsWhitespace()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumCharsInText()
{
	return numCharsInText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteFrontAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this), numCharsInText);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteBackAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this), numCharsInText);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoFront(TextDisplayNode* textNode)
{
	return new BetweenWordsSelection(textNode, this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoBack(TextDisplayNode* textNode)
{
	return new BetweenWordsSelection(textNode, this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindBefore()
{
	// not really meaningful
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindAfter()
{
	// not really meaningful
	return false;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int numCharsInText;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SmartMDash
</name>
<superclasses>
public Glyph
</superclasses>
<hIncludes><![CDATA[
#include "Glyph.h"
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphDrawContext.h"
#include "TextDisplayNode.h"
#include "Text.h"
#include "BackCharsAction.h"
#include "View.h"
#include "Font.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SmartMDash()
	: width(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	if (width == 0)
		width = font->WidthOf(mDash);
	return width;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UncacheWidth()
{
	width = 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	// see if we really should draw
	int top = y + context->originY;
	Font* font = context->font;
	if (top < context->startY || top + font->LineHeight() > context->endY)
		return;

	View* view = context->view;
	view->MovePenTo(x + context->originX, top + font->Ascent());
	view->DrawString(mDash);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumCharsInText()
{
	// always came from "--"
	return 2;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteFrontAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this), 2);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteBackAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this), 2);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoFront(TextDisplayNode* textNode)
{
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this) + NumCharsInText());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoBack(TextDisplayNode* textNode)
{
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsPunctuation()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindBefore()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindAfter()
{
	return true;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
short width;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const string_slice mDash = "—";
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SmartQuote
</name>
<superclasses>
public Glyph
</superclasses>
<hIncludes><![CDATA[
#include "Glyph.h"
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphDrawContext.h"
#include "TextDisplayNode.h"
#include "BackCharsAction.h"
#include "Text.h"
#include "Font.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SmartQuote(bool openingIn)
	: opening(openingIn), width(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual string_slice DisplayString() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	if (width == 0)
		width = font->WidthOf(DisplayString());
	return width;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void UncacheWidth()
{
	width = 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	if (!ShouldDraw(context))
		return;

	View* view = context->view;
	view->MovePenTo(x + context->originX, y + context->originY + context->font->Ascent());
	view->DrawString(DisplayString());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsPunctuation()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumCharsInText()
{
	return 1;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteFrontAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteBackAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoFront(TextDisplayNode* textNode)
{
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this) + NumCharsInText());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoBack(TextDisplayNode* textNode)
{
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindBefore()
{
	return !opening;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindAfter()
{
	return opening;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool opening;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
short width;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SmartSingleQuote
</name>
<superclasses>
public SmartQuote
</superclasses>
<hIncludes><![CDATA[
#include "SmartQuote.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SmartSingleQuote(bool openingIn)
	: SmartQuote(openingIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"SmartQuote virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice DisplayString()
{
	return (opening ? "‘" : "’");
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SmartDoubleQuote
</name>
<superclasses>
public SmartQuote
</superclasses>
<hIncludes><![CDATA[
#include "SmartQuote.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SmartDoubleQuote(bool openingIn)
	: SmartQuote(openingIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"SmartQuote virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice DisplayString()
{
	return (opening ? "“" : "”");
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
PreSpace
</name>
<superclasses>
public Word
</superclasses>
<hIncludes><![CDATA[
#include "Word.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PreSpace(DOMString textIn)
	: Word(textIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsWhitespace()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsPreSpace()
{
	return true;
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LineBreak
</name>
<superclasses>
public Glyph
</superclasses>
<hIncludes><![CDATA[
#include "Glyph.h"
#include "DOMString.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "BackCharsAction.h"
#include "BetweenGlyphsSelection.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
LineBreak(DOMString text)
	: numCharsInText(text.length())
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	return 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	// nothing to do
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsWhitespace()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsLineBreak()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumCharsInText()
{
	return numCharsInText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteFrontAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this), numCharsInText);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteBackAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this), numCharsInText);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoFront(TextDisplayNode* textNode)
{
	return new BetweenGlyphsSelection(textNode, this, textNode->GlyphAfter(this), false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoBack(TextDisplayNode* textNode)
{
	return new BetweenGlyphsSelection(textNode, textNode->GlyphBefore(this), this, true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindBefore()
{
	// not really meaningful
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindAfter()
{
	// not really meaningful
	return false;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int numCharsInText;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Tab
</name>
<superclasses>
public Glyph
</superclasses>
<hIncludes><![CDATA[
#include "Glyph.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "BackCharsAction.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Tab()
	: width(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetWidth(int newWidth)
{
	width = newWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Glyph virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Width(Font* font)
{
	return width;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(GlyphDrawContext* context)
{
	// nothing to draw
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsWhitespace()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsTab()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumCharsInText()
{
	return 1;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteFrontAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteBackAction(TextDisplayNode* textNode)
{
	return new BackCharsAction(textNode->GetText(), textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoFront(TextDisplayNode* textNode)
{
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this) + NumCharsInText());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* SelectionIntoBack(TextDisplayNode* textNode)
{
	return textNode->GetSelectionAtOffset(textNode->OffsetOfGlyph(this));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindBefore()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ShouldBindAfter()
{
	return false;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int width;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Live DOM"
</name>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DOMChangeClient
</name>
<hIncludes><![CDATA[
#include "DOMString.h"

class Node;
class Attr;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals for Node ops -- all default to doing nothing"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ChildInsertedBefore(Node* newChild, Node* refChild)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ChildReplaced(Node* newChild, Node* oldChild)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void ChildRemoved(Node* oldChild)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void NodeDying()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals for CharacterData ops -- all default to doing nothing"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DataInserted(unsigned long offset, DOMString arg)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DataDeleted(unsigned long offset, unsigned long count)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DataSet(DOMString newData)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals for Element ops -- all default to doing nothing"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void AttributeSet(Attr* newAttr)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void AttributeRemoved(Attr* oldAttr)
{
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DOMLiveNode
</name>
<superclasses>
virtual public Node
</superclasses>
<hIncludes><![CDATA[
#include "Node.h"

class DOMChangeClient;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMLiveNode()
	: changeClient(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~DOMLiveNode()
{
	if (changeClient)
		changeClient->NodeDying();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddChangeClient(DOMChangeClient* newChangeClient)
{
	/*** someday support multiple clients through DOMChangeSplitter ***/
	changeClient = newChangeClient;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RemoveChangeClient(DOMChangeClient* oldChangeClient)
{
	/*** someday support multiple clients through DOMChangeSplitter ***/
	if (changeClient == oldChangeClient)
		changeClient = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMChangeClient* GetChangeClient()
{
	return changeClient;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMChangeClient* changeClient;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveDocument
</name>
<superclasses>
virtual public Document, public DOMLiveNode
</superclasses>
<hIncludes><![CDATA[
#include "Document.h"
#include "DOMLiveNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline LiveDocument()
{
	// just to trick CY into generating class def
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveElement
</name>
<superclasses>
virtual public Element, public DOMLiveNode
</superclasses>
<hIncludes><![CDATA[
#include "Element.h"
#include "DOMLiveNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline LiveElement()
{
	// just to trick CY into generating
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveAttr
</name>
<superclasses>
virtual public Attr, public DOMLiveNode
</superclasses>
<hIncludes><![CDATA[
#include "Attr.h"
#include "DOMLiveNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline LiveAttr()
{
	// just to trick CY into generating class def
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveText
</name>
<superclasses>
virtual public Text, public DOMLiveNode
</superclasses>
<hIncludes><![CDATA[
#include "Text.h"
#include "DOMLiveNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline LiveText()
{
	// not need for C++; just to trick CY into generating
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveCDATASection
</name>
<superclasses>
public CDATASection, public DOMLiveNode
</superclasses>
<hIncludes><![CDATA[
#include "CDATASection.h"
#include "DOMLiveNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline LiveCDATASection()
{
	// just for CY
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveEntityReference
</name>
<superclasses>
virtual public EntityReference, public DOMLiveNode
</superclasses>
<hIncludes><![CDATA[
#include "EntityReference.h"
#include "DOMLiveNode.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline LiveEntityReference()
{
	// just to trick CY into generating class ref
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BasicLiveDocument
</name>
<superclasses>
public LiveDocument, public BasicDocument
</superclasses>
<hIncludes><![CDATA[
#include "LiveDocument.h"
#include "BasicDocument.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveDocument(XMLNodeFactory* nodeFactoryIn)
	: BasicDocument(nodeFactoryIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveDocument(const BasicLiveDocument& other, bool deep)
	: BasicDocument(other, deep)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations (virtual)"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* InsertBefore(Node* newChild, Node* refChild)
{
	Node* result = BasicDocument::InsertBefore(newChild, refChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, refChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* ReplaceChild(Node* newChild, Node* oldChild)
{
	Node* result = BasicDocument::ReplaceChild(newChild, oldChild);
	if (changeClient)
		changeClient->ChildReplaced(newChild, oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* RemoveChild(Node* oldChild)
{
	Node* result = BasicDocument::RemoveChild(oldChild);
	if (changeClient)
		changeClient->ChildRemoved(oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* AppendChild(Node* newChild)
{
	Node* result = BasicDocument::AppendChild(newChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, NULL);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* CloneNode(bool deep)
{
	return new BasicLiveDocument(*this, deep);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BasicLiveElement
</name>
<superclasses>
public LiveElement, public BasicElement
</superclasses>
<hIncludes><![CDATA[
#include "LiveElement.h"
#include "BasicElement.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveElement(DOMString name)
	: BasicElement(name)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveElement(const BasicLiveElement& other, bool deep)
	: BasicElement(other, deep)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations (virtual)"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* InsertBefore(Node* newChild, Node* refChild)
{
	Node* result = BasicElement::InsertBefore(newChild, refChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, refChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* ReplaceChild(Node* newChild, Node* oldChild)
{
	Node* result = BasicElement::ReplaceChild(newChild, oldChild);
	if (changeClient)
		changeClient->ChildReplaced(newChild, oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* RemoveChild(Node* oldChild)
{
	Node* result = BasicElement::RemoveChild(oldChild);
	if (changeClient)
		changeClient->ChildRemoved(oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* AppendChild(Node* newChild)
{
	Node* result = BasicElement::AppendChild(newChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, NULL);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Attr* SetAttributeNode(Attr* newAttr)
{
	Attr* result = BasicElement::SetAttributeNode(newAttr);
	if (changeClient)
		changeClient->AttributeSet(newAttr);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Attr* RemoveAttributeNode(Attr* oldAttr)
{
	Attr* result = BasicElement::RemoveAttributeNode(oldAttr);
	if (changeClient)
		changeClient->AttributeRemoved(oldAttr);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* CloneNode(bool deep)
{
	return new BasicLiveElement(*this, deep);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BasicLiveAttr
</name>
<superclasses>
public LiveAttr, public BasicAttr
</superclasses>
<hIncludes><![CDATA[
#include "LiveAttr.h"
#include "BasicAttr.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveAttr(DOMString nameIn)
	: BasicAttr(nameIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveAttr(const BasicLiveAttr& other, bool deep)
	: BasicAttr(other, deep)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations (virtual)"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* InsertBefore(Node* newChild, Node* refChild)
{
	Node* result = BasicAttr::InsertBefore(newChild, refChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, refChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* ReplaceChild(Node* newChild, Node* oldChild)
{
	Node* result = BasicAttr::ReplaceChild(newChild, oldChild);
	if (changeClient)
		changeClient->ChildReplaced(newChild, oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* RemoveChild(Node* oldChild)
{
	Node* result = BasicAttr::RemoveChild(oldChild);
	if (changeClient)
		changeClient->ChildRemoved(oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* AppendChild(Node* newChild)
{
	Node* result = BasicAttr::AppendChild(newChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, NULL);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* CloneNode(bool deep)
{
	return new BasicLiveAttr(*this, deep);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BasicLiveText
</name>
<superclasses>
public LiveText, public BasicText
</superclasses>
<hIncludes><![CDATA[
#include "BasicText.h"
#include "LiveText.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveText(DOMString textIn, bool isIgnorableWhitespace = false)
	: BasicText(textIn, isIgnorableWhitespace)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveText(const BasicLiveText& other)
	: BasicText(other)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations (virtual)"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendData(DOMString arg)
{
	unsigned long position = Length();
	BasicText::AppendData(arg);
	if (changeClient)
		changeClient->DataInserted(position, arg);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InsertData(unsigned long offset, DOMString arg)
{
	BasicText::InsertData(offset, arg);
	if (changeClient)
		changeClient->DataInserted(offset, arg);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeleteData(unsigned long offset, unsigned long count)
{
	BasicText::DeleteData(offset, count);
	if (changeClient)
		changeClient->DataDeleted(offset, count);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetData(DOMString arg)
{
	BasicText::SetData(arg);
	if (changeClient)
		changeClient->DataSet(arg);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* SplitText(unsigned long offset)
{
	return BasicText::SplitText(offset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsIgnorableWhitespace()
{
	return BasicText::IsIgnorableWhitespace();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* CloneNode(bool deep)
{
	return new BasicLiveText(*this);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BasicLiveCDATASection
</name>
<superclasses>
public LiveCDATASection, public BasicLiveText
</superclasses>
<hIncludes><![CDATA[
#include "LiveCDATASection.h"
#include "BasicLiveText.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveCDATASection(DOMString textIn)
	: BasicLiveText(textIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveCDATASection(const BasicLiveCDATASection& other)
	: BasicLiveText(other)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Text virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* SplitText(unsigned long offset)
{
	return BasicLiveText::SplitText(offset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsIgnorableWhitespace()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* CloneNode(bool deep)
{
	return new BasicLiveCDATASection(*this);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BasicLiveEntityReference
</name>
<superclasses>
public LiveEntityReference, public BasicEntityReference
</superclasses>
<hIncludes><![CDATA[
#include "LiveEntityReference.h"
#include "BasicEntityReference.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DOMChangeClient.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveEntityReference(DOMString nameIn)
	: BasicEntityReference(nameIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BasicLiveEntityReference(const BasicLiveEntityReference& other)
	: BasicEntityReference(other)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations (virtual)"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* InsertBefore(Node* newChild, Node* refChild)
{
	Node* result = BasicEntityReference::InsertBefore(newChild, refChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, refChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* ReplaceChild(Node* newChild, Node* oldChild)
{
	Node* result = BasicEntityReference::ReplaceChild(newChild, oldChild);
	if (changeClient)
		changeClient->ChildReplaced(newChild, oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* RemoveChild(Node* oldChild)
{
	Node* result = BasicEntityReference::RemoveChild(oldChild);
	if (changeClient)
		changeClient->ChildRemoved(oldChild);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* AppendChild(Node* newChild)
{
	Node* result = BasicEntityReference::AppendChild(newChild);
	if (changeClient)
		changeClient->ChildInsertedBefore(newChild, NULL);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* CloneNode(bool deep)
{
	return new BasicLiveEntityReference(*this);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
LiveXMLNodeFactory
</name>
<superclasses>
public StandardXMLNodeFactory
</superclasses>
<hIncludes><![CDATA[
#include "StandardXMLNodeFactory.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BasicLiveDocument.h"
#include "BasicLiveElement.h"
#include "BasicLiveAttr.h"
#include "BasicLiveText.h"
#include "BasicLiveCDATASection.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"XMLNodeFactory virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* MakeDocument()
{
	return new BasicLiveDocument(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* MakeElement(DOMString name)
{
	return new BasicLiveElement(name);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Attr* MakeAttr(DOMString name)
{
	return new BasicLiveAttr(name);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* MakeText(DOMString value)
{
	return new BasicLiveText(value);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CDATASection* MakeCDATASection(DOMString value)
{
	return new BasicLiveCDATASection(value);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* MakeIgnorableWhitespace(DOMString value)
{
	return new BasicLiveText(value, true);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"DOM Extras"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 17:12:25 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
XMLWriter
</name>
<hIncludes><![CDATA[
#include "string_slice.h"

class Document;
class Node;
class Element;
class Attr;
class Text;
class CDATASection;
class EntityReference;
class ProcessingInstruction;
class Comment;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "Attr.h"
#include "Text.h"
#include "CDATASection.h"
#include "EntityReference.h"
#include "ProcessingInstruction.h"
#include "Comment.h"
#include "NamedNodeMap.h"
#include "DOMStringIter.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
XMLWriter(Node* rootNodeIn)
	: rootNode(rootNodeIn)
{
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:12:25 PST"><![CDATA[
virtual ~XMLWriter()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Write()
{
	WriteNode(rootNode);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Pure virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Write(const string_slice str) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteNode(Node* node)
{
	switch (node->NodeType()) {
		case DOCUMENT_NODE:
			WriteChildren(node);
			break;

		case ELEMENT_NODE:
			WriteElement(dynamic_cast<Element*>(node));
			break;

		case TEXT_NODE:
			WriteText(dynamic_cast<Text*>(node));
			break;

		case CDATA_SECTION_NODE:
			WriteText(dynamic_cast<CDATASection*>(node));
			break;

		case ENTITY_REFERENCE_NODE:
			WriteEntityReference(dynamic_cast<EntityReference*>(node));
			break;

		case PROCESSING_INSTRUCTION_NODE:
			WriteProcessingInstruction(dynamic_cast<ProcessingInstruction*>(node));
			break;

		case COMMENT_NODE:
			WriteComment(dynamic_cast<Comment*>(node));
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteChildren(Node* node)
{
	for (Node* child = node->FirstChild(); child; child = child->NextSibling())
		WriteNode(child);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteElement(Element* element)
{
	if (element == NULL)
		throw InternalException("DOMWriter: NodeType doesn't match node type.");

	// begin the start tag
	Write("<");
	Write(element->TagName());

	// attributes
	NamedNodeMap* attributes = element->Attributes();
	int numAttrs = attributes->Length();
	for (int i = 0; i < numAttrs; ++i) {
		Attr* attr = dynamic_cast<Attr*>(attributes->Item(i));
		if (attr == NULL) {
			qstring msg = "XMLWriter::WriteElement: Element's attributes contains non-attribute (node-type=";
			Node* attrNode = attributes->Item(i);
			if (attrNode)
				msg += qstring(attrNode->NodeType());
			else
				msg += "NULL";
			msg += ").";
			qstring* leaky = new qstring(msg);
			throw InternalException(*leaky);
			}
		if (!attr->Specified())
			continue;
		Write(" ");
		Write(attr->Name());
		Write("=\"");
		WriteChildren(attr);
		Write("\"");
		}

	// end of start tag
	bool hasChildren = element->HasChildNodes();
	if (hasChildren)
		Write(">");
	else
		Write("/>");

	// children
	if (hasChildren)
		WriteChildren(element);

	// end tag
	if (hasChildren) {
		Write("</");
		Write(element->TagName());
		Write(">");
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteText(Text* text)
{
	DOMString data = text->Data();
	DOMStringIter p = data.begin();
	DOMStringIter stopper = data.end();
	int startPos = 0;
	int curPos = 0;
	const char* entity;
	for (; p != stopper; ++p) {
		char c = *p;
		switch (c) {
			case '&':
				entity = "&amp;";
				goto useEntity;
			case '<':
				entity = "&lt;";
				goto useEntity;
			case '>':
				entity = "&gt;";
				goto useEntity;
			case '\'':
				entity = "&apos;";
				goto useEntity;
			case '\"':
				entity = "&quot;";
				goto useEntity;
			useEntity:
				if (curPos > startPos)
					Write(data.substr(startPos, curPos - startPos));
				Write(entity);
				curPos += 1;
				startPos = curPos;
				break;

			default:
				curPos += 1;
				break;
			}
		}

	if (startPos == 0)
		Write(data);	// slight optimization
	else if (curPos > startPos)
		Write(data.substr(startPos, curPos - startPos));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteCDATASection(CDATASection* cdata)
{
	static const char cdataEnd[] = { ']', ']', '>', 0 };	// don't put these together so Castle Yankee doesn't get confused

	Write("<![CDATA[");
	Write(cdata->Data());
	Write(cdataEnd);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteEntityReference(EntityReference* entityRef)
{
	Write("&");
	Write(entityRef->NodeName());
	Write(";");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteProcessingInstruction(ProcessingInstruction* pi)
{
	Write("<?");
	Write(pi->Target());
	Write(" ");
	Write(pi->Data());
	Write("?>");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void WriteComment(Comment* comment)
{
	Write("<!--");
	Write(comment->Data());
	Write("-->");
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* rootNode;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:34:48 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
XMLFileWriter
</name>
<superclasses>
public XMLWriter
</superclasses>
<hIncludes><![CDATA[
#include "XMLWriter.h"
#include <stdio.h>

class Document;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
XMLFileWriter(Document* documentIn, FILE* fileIn)
	: XMLWriter(documentIn), file(fileIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"XMLWriter virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Write(const string_slice str)
{
	fwrite(str.begin(), 1, str.length(), file);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Write()
{
	rewind(file);
	XMLWriter::Write();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FILE* file;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
XMLStringWriter
</name>
<superclasses>
public XMLWriter
</superclasses>
<hIncludes><![CDATA[
#include "XMLWriter.h"
#include "DOMString.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
XMLStringWriter(Node* rootNodeIn)
	: XMLWriter(rootNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetString()
{
	return string;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendNode(Node* extraNode)
{
	WriteNode(extraNode);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendString(string_slice str)
{
	Write(str);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"XMLWriter virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Write(const string_slice str)
{
	string += str;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Write()
{
	string = "";
	XMLWriter::Write();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString string;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DOMUtils
</name>
<hIncludes><![CDATA[
#include "DOMString.h"

class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include "Element.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString NodeContents(Node* node)
{
	if (node->NodeType() == TEXT_NODE)
		return node->NodeValue();

	DOMString contents;
	for (Node* child = node->FirstChild(); child; child = child->NextSibling()) {
		if (child->NodeType() == TEXT_NODE)
			contents += child->NodeValue();
		else
			contents += NodeContents(child);
		}
	return contents;
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Validation"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 17:13:49 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NodeTypeList
</name>
<hIncludes><![CDATA[
#include "DOMString.h"

class Node;
class NodeTypeInternalList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include "Text.h"
#include "InternalException.h"
#include <vector>

class NodeTypeInternalList : public vector<DOMString> {
public:
	int	refCount;
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NodeTypeList()
	: curIndex(-1)
{
	nodeTypes = new NodeTypeInternalList();
	nodeTypes->refCount = 1;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NodeTypeList(const NodeTypeList& other)
{
	nodeTypes = other.nodeTypes;
	nodeTypes->refCount += 1;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NodeTypeList()
{
	if (--nodeTypes->refCount == 0)
		delete nodeTypes;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendNode(DOMString nodeType)
{
	nodeTypes->push_back(nodeType);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AppendNode(Node* node)
{
	DOMString nodeName;
	switch (node->NodeType()) {
		case ELEMENT_NODE:
			nodeName = node->NodeName();
			break;
		case TEXT_NODE:
			// don't add it if it's ignoreable whitespace
			if (!dynamic_cast<Text*>(node)->IsIgnorableWhitespace())
				nodeName = "#text";
			break;
		case CDATA_SECTION_NODE:
		case ENTITY_REFERENCE_NODE:
			nodeName = "#text";
			break;
		case PROCESSING_INSTRUCTION_NODE:
		case COMMENT_NODE:
			// don't add these
			break;
		default:
			// all others mean there's something wrong
			throw InternalException("NodeTypeList::AppendNode:  Attempt to add illegal node type.");
			break;
		}

	if (!nodeName.empty())
		AppendNode(nodeName);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumNodeTypes()
{
	return nodeTypes->size();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString NodeTypeAt(int index)
{
	return (*nodeTypes)[index];
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Iteration"

Note that there is not a separate iterator class; a NodeTypeList contains an
iterator of its own.  This is not as flexible as the usual Iterator scheme,
but it more convenient for how we're doing things.
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Rewind()
{
	curIndex = (nodeTypes->size() > 0 ? 0 : -1);
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:13:49 PST"><![CDATA[
void Step()
{
	if (curIndex >= 0) {
		curIndex += 1;
		if (((unsigned int) curIndex) >= nodeTypes->size())
			curIndex = -1;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IteratorValid()
{
	return (curIndex >= 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString CurNodeType()
{
	if (curIndex < 0)
		throw InternalException("Attempt to access NodeTypeList::CurNodeType() with invalid iterator.");
	return (*nodeTypes)[curIndex];
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NodeTypeInternalList* nodeTypes;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curIndex;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Validator
</name>
<hIncludes><![CDATA[
#include "NodeTypeList.h"
#include "DOMString.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool AllowsContents(Element* parentNode, NodeTypeList nodeTypes) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanInsertBefore(Element* parent, NodeTypeList newNodeTypes, Node* refChild)
{
	NodeTypeList allNodeTypes;

	// build "allNodeTypes" up to the insertion
	Node* curChild = NULL;
	for (curChild = parent->FirstChild(); curChild; curChild = curChild->NextSibling()) {
		if (curChild == refChild)
			break;
		allNodeTypes.AppendNode(curChild);
		}

	// add in the insertion
	for (newNodeTypes.Rewind(); newNodeTypes.IteratorValid(); newNodeTypes.Step())
		allNodeTypes.AppendNode(newNodeTypes.CurNodeType());

	// copy the remainder of the node types
	for (; curChild; curChild = curChild->NextSibling())
		allNodeTypes.AppendNode(curChild);

	// validate
	return AllowsContents(parent, allNodeTypes);
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DefaultValidator
</name>
<superclasses>
public Validator
</superclasses>
<hIncludes><![CDATA[
#include "Validator.h"

class DisplayDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DisplayDirector.h"
#include "EditStylesheet.h"
#include "Element.h"
#include "ElementDisplayNode.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DefaultValidator(DisplayDirector* directorIn)
	: director(directorIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Validator virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool AllowsContents(Element* parentNode, NodeTypeList nodeTypes)
{
	// allow blocks within non-leaf-blocks; inlines within inlines and leaf-blocks

	// set up
	ElementDisplayNode* displayNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(parentNode));
	if (displayNode == NULL)
		throw InternalException("DefaultValidator::AllowsContents: parent has no DisplayNode.");
	bool allowInline = (displayNode->GetDisplayType() == Inline ||
	                    displayNode->IsLeafBlock());
	bool allowBlock = !allowInline;
	EditStylesheet* stylesheet = director->GetStylesheet();

	// check
	for (nodeTypes.Rewind(); nodeTypes.IteratorValid(); nodeTypes.Step()) {
		DOMString curNodeType = nodeTypes.CurNodeType();
		DOMString curDisplayType;
		if (curNodeType == "#text")
			curDisplayType = "inline";
		else
			curDisplayType = stylesheet->PropertyForElement("display", curNodeType);
		if (curDisplayType == "inline") {
			if (!allowInline)
				return false;
			}
		else if (curDisplayType == "block") {
			if (!allowBlock)
				return false;
			}
		else
			return false;
		}

	// all passed; go ahead
	return true;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* director;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Selections"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 16:56:01 PST" wind-frame="132.000000,87.000000,772.000000,617.000000" list-views-height="0.000000">
<name>
Selection
</name>
<hIncludes><![CDATA[
#include "CoordPoint.h"
#include "Rectangle.h"
#include "Color.h"
#include "DOMString.h"
#include "string_slice.h"

class DisplayDirector;
class DisplayNode;
class View;
class Action;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlockableDisplayNode.h"
#include "Tweex.h"
]]></cppIncludes>
<method access="public" mod-time="Thu, 30 Mar 2000 16:55:54 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:56:01 PST"><![CDATA[
virtual ~Selection()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Actions - Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(View* view, CoordPoint origin) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void AcceptKey(string_slice key, DisplayDirector* director) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Promote(DisplayDirector* director)
{
	/* virtual.  Default: do nothing */
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* ExtendTo(CoordPoint point) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Action* GetRestoreAction() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool HandleSpecialKey(string_slice key, DisplayDirector* director)
{
	// default: don't handle
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CanCopy()
{
	// default: false
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DOMString GetXMLCopy()
{
	return DOMString();
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 21:21:55 PST"><![CDATA[
virtual bool CanPaste()
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 21:24:32 PST"><![CDATA[
virtual void Paste(String pasteText, DisplayDirector * director)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting - Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle Bounds() = 0;
	// for invalidate on erase
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsVisible(Rectangle pageRect) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool NeedsClip() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool ContainsPoint(CoordPoint point)
{
	return Bounds().Contains(point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual CoordPoint DragStartPoint(CoordPoint destPoint)
{
	/** pure virtual, but only for selections that can be dragged **/
	return CoordPoint();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers for subclasses"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint BlockOrigin(DisplayNode* node)
{
	// find the enclosing block
	for (; node; node = node->Parent()) {
		if (node->GetDisplayType() == Block)
			break;
		}
	if (node == NULL)	// shouldn't happen
		return CoordPoint(0, 0);

	// return the block's origin
	BlockableDisplayNode* blockNode = dynamic_cast<BlockableDisplayNode*>(node);
	return CoordPoint(blockNode->LeftSpace(), blockNode->Top());
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const Color selectionColor = { 0, 0xBB, 255, 128 };
]]></variable>

</class>


<class mod-time="Wed, 12 Apr 2000 20:19:59 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TagSelection
</name>
<superclasses>
public Selection
</superclasses>
<hIncludes><![CDATA[
#include "Selection.h"
#include "DOMString.h"
#include "Rectangle.h"

class TagEditor;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TagEditor.h"
#include "WindowDirector.h"
#include "Keys.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TagSelection()
	: tagEditor(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TagSelection()
{
	delete tagEditor;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tag operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ShowTag(DisplayDirector* director)
{
	if (tagEditor)
		return;

	WindowDirector* windowDirector = dynamic_cast<WindowDirector*>(director);
	if (windowDirector) {
		tagEditor = new TagEditor(TagName(), this, windowDirector);
		director->RefreshDocRect(Bounds());
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HideTag(DisplayDirector* director)
{
	if (tagEditor == NULL)
		return;

	Rectangle biggerBounds = Bounds();	// before the tag goes away

	delete tagEditor;
	tagEditor = NULL;

	director->RefreshDocRect(biggerBounds);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectTag(DisplayDirector* director)
{
	ShowTag(director);
	tagEditor->Select();
	director->RefreshDocRect(Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeselectTag(DisplayDirector* director)
{
	if (tagEditor) {
		tagEditor->Deselect();
		director->RefreshDocRect(Bounds());
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool TagIsSelected()
{
	return (tagEditor && tagEditor->IsSelected());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RestoreTag(DisplayDirector* director)
{
	if (tagEditor) {
		director->StartRefreshCycle();
		director->RefreshDocRect(Bounds());
		tagEditor->SetSelection(NULL);
		tagEditor->SetTagName(TagName());
		director->RefreshDocRect(Bounds());
		director->FinishRefreshCycle();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DOMString TagName() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle TagSpecRect() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void TagNameChanged(DOMString newTagName, DisplayDirector* director) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void TagEditDone(DisplayDirector* director)
{
	// default: deselect, but don't hide
	DeselectTag(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals (call from subclasses for certain things)"
]]></method>

<method access="public" mod-time="Wed, 12 Apr 2000 20:19:59 PDT"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	// handle keys for the tagEditor
	if (tagEditor && tagEditor->IsSelected()) {
		if (key == "\n" || key == "\t") {
			DOMString newTagName = tagEditor->TagName();
			if (newTagName.empty()) {
				RestoreTag(director);
				TagEditDone(director);
				}
			else if (newTagName != TagName()) {
				// in this case, we *don't* call TagEditDone, since the selection
				// (and the tag) will have gone away.
				TagNameChanged(newTagName, director);
				}
			else
				TagEditDone(director);
			}
		else
			tagEditor->KeyDown(key);
		}

	// tag key opens/selects the tagEditor
	else if (key == "\t") {
		SelectTag(director);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool HandleSpecialKey(string_slice key, DisplayDirector* director)
{
	if (key == Keys::EscKey && TagIsSelected()) {
		director->StartRefreshCycle();
		RestoreTag(director);
		TagEditDone(director);
		director->FinishRefreshCycle();
		return true;
		}

	return false;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TagEditor* tagEditor;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:31:07 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
PointSelection
</name>
<superclasses>
public TagSelection
</superclasses>
<hIncludes><![CDATA[
#include "TagSelection.h"

class TextDisplayNode;
class Action;
class Element;
class Glyph;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "CompositeDisplayNode.h"
#include "ElementDisplayNode.h"
#include "Space.h"
#include "Text.h"
#include "Element.h"
#include "TagEditor.h"
#include "WindowDirector.h"
#include "EditStylesheet.h"
#include "BetweenWordsSelection.h"
#include "BetweenGlyphsSelection.h"
#include "BetweenBlocksSelection.h"
#include "CompositeAction.h"
#include "NewLeafBlockAction.h"
#include "SplitTextAction.h"
#include "SplitElementAction.h"
#include "AddCharsAction.h"
#include "RestoreSelectionAction.h"
#include "Font.h"
#include "View.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PointSelection(TextDisplayNode* textNodeIn)
	: textNode(textNodeIn)
{
	const Font* font = textNode->CurFont();
	ascent = font->Ascent();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~PointSelection()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Pure Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual CoordPoint Point() = 0;
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:31:07 PDT"><![CDATA[
virtual void InsertTag(DOMString tagName, DisplayDirector* director) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CaretOutLeft()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CaretOutRight()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:14:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	view->PushState();
	view->SetPenSize(2);
	view->SetHighColor(selectionColor);

	CoordPoint point = Point() + origin;
	int xPoint = (int) point.x;
	if (CaretOutLeft())
		xPoint -= caretWidth;
	view->StrokeLine(point, CoordPoint(xPoint, point.y + caretHeight + 1));
	xPoint = (int) point.x;
	if (CaretOutRight())
		xPoint += caretWidth;
	view->StrokeLine(point, CoordPoint(xPoint, point.y + caretHeight));

	if (tagEditor) {
		Rectangle tagBounds = tagEditor->Bounds();
		view->SetPenSize(1);
		view->StrokeLine(point, CoordPoint(point.x, tagBounds.bottom + origin.y));
		tagEditor->Draw(view->Bounds());
		}

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	TagSelection::AcceptKey(key, director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	CoordPoint point = Point();
	Rectangle bounds(point.x - caretWidth - 1, point.y - ascent,
	                 point.x + caretWidth + 1, point.y + caretHeight + 1);
	if (tagEditor)
		bounds = bounds | tagEditor->Bounds();
	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	CoordPoint point = Point();
	pageRect.top += ascent;		// the line won't show if it can't show the top
	                       		// of the characters, so don't show this either
	return pageRect.Contains(point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsClip()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"TagSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return "";
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:15:05 PST"><![CDATA[
Rectangle TagSpecRect()
{
	CoordPoint point = Point();
	int tagX = (int) point.x + tagXOffset;
	return Rectangle(tagX, 0, tagX, point.y - ascent + tagYOffset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagNameChanged(DOMString newTagName, DisplayDirector* director)
{
	InsertTag(newTagName, director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagEditDone(DisplayDirector* director)
{
	HideTag(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers for subclasses"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectPastText(DisplayDirector* director)
{
	DisplayNode* node = textNode;
	while (true) {
		// find the next node to check
		node = node->NextNodeInDoc();
		if (node == NULL)
			break;

		// if it's a block, use a BetweenBlocksSelection
		if (node->GetDisplayType() == Block) {
			BlockableDisplayNode* nodeBlock = dynamic_cast<BlockableDisplayNode*>(node);
			BlockableDisplayNode* parentBlock =
				dynamic_cast<BlockableDisplayNode*>(node->Parent());
			director->SetSelection(new BetweenBlocksSelection(parentBlock, nodeBlock));
			break;
			}

		// see if it has a selection
		Selection* startSelection = node->StartSelection();
		if (startSelection) {
			director->SetSelection(startSelection);
			break;
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectBeforeText(DisplayDirector* director)
{
	DisplayNode* node = textNode;
	while (true) {
		// find the next node to check
		node = node->PrevNodeInDoc();
		if (node == NULL)
			break;

		// if it's a block, use a BetweenBlocksSelection
		if (node->GetDisplayType() == Block) {
			BlockableDisplayNode* nextBlock =
				dynamic_cast<BlockableDisplayNode*>(node->NextSibling());
			BlockableDisplayNode* parentBlock =
				dynamic_cast<BlockableDisplayNode*>(node->Parent());
			director->SetSelection(new BetweenBlocksSelection(parentBlock, nextBlock));
			break;
			}

		// see if it has a selection
		Selection* endSelection = node->EndSelection();
		if (endSelection) {
			director->SetSelection(endSelection);
			break;
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectPastWord(Glyph* word, DisplayDirector* director)
{
	Glyph* nextGlyph = textNode->GlyphAfter(word);
	Space* nextSpace = dynamic_cast<Space*>(nextGlyph);
	if (nextSpace)
		director->SetSelection(new BetweenWordsSelection(textNode, nextSpace));
	else {
		director->SetSelection(new BetweenGlyphsSelection(textNode,
		                                                  word, nextGlyph,
		                                                  true));
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectBeforeWord(Glyph* word, DisplayDirector* director)
{
	Glyph* prevGlyph = textNode->GlyphBefore(word);
	Space* prevSpace = dynamic_cast<Space*>(prevGlyph);
	if (prevSpace)
		director->SetSelection(new BetweenWordsSelection(textNode, prevSpace));
	else {
		director->SetSelection(new BetweenGlyphsSelection(textNode,
		                                                  prevGlyph, word,
		                                                  false));
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HandleReturn(unsigned long offset, DisplayDirector* director)
{
	Text* text = textNode->GetText();
	unsigned long textLen = text->Length();

	// handle "pre" sections specially
	if (textNode->IsPreSpace()) {
		director->DoAction(new AddCharsAction("\n", text, offset));
		return;
		}

	// split the paragraph
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());

	// start setting up the split
	Element* splittingElement = EnclosingLeafBlockElement();
	Node* afterNode = text;

	// split the text
	if (offset < textLen)
		action->AddAction(new SplitTextAction(text, offset));

	// if not splitting the text, adjust afterNode
	else {
		while (afterNode != splittingElement) {
			if (afterNode->NextSibling() != NULL) {
				// this is where we want to split
				break;
				}

			// nothing after the afterNode, so move up a level
			afterNode = afterNode->ParentNode();
			}
		}

	// look for special-split
	EditStylesheet* stylesheet = director->GetStylesheet();
	DOMString specialSplitSpec;
	for (Node* specialNode = splittingElement; specialNode; specialNode = specialNode->ParentNode()) {
		if (specialNode->NodeType() != ELEMENT_NODE)
			continue;
		specialSplitSpec =
			stylesheet->PropertyForElement("special-split", specialNode->NodeName());
		if (!specialSplitSpec.empty()) {
			splittingElement = dynamic_cast<Element*>(specialNode);
			break;
			}
		}

	// split the element
	if (afterNode != splittingElement)
		action->AddAction(new SplitElementAction(splittingElement, afterNode));

	// insert a new paragraph when appropriate
	if (afterNode == splittingElement || !specialSplitSpec.empty())
		action->AddAction(new NewLeafBlockAction(splittingElement, specialSplitSpec));

	director->DoAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteCharBefore(/***/)
{
	/*** TO BE DONE, or not ***/
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* DeleteCharAfter(/***/)
{
	/*** TO BE DONE, or not ***/
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsInFirstTextOfBlock()
{
	for (DisplayNode* node = textNode; node; node = node->Parent()) {
		// if we've reached the enclosing block, we're done
		if (node->GetDisplayType() == Block)
			return true;

		// see if this node is the first node in its parent
		CompositeDisplayNode* parent = dynamic_cast<CompositeDisplayNode*>(node->Parent());
		if (parent == NULL) {
			// not composite; must have only one child
			continue;
			}
		if (node != parent->FirstChild())
			return false;
		}

	// got to the top and we're still first
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsInLastTextOfBlock()
{
	for (DisplayNode* node = textNode; node; node = node->Parent()) {
		// if we've reached the enclosing block, we're done
		if (node->GetDisplayType() == Block)
			return true;

		// see if this node is the last node in its parent
		CompositeDisplayNode* parent = dynamic_cast<CompositeDisplayNode*>(node->Parent());
		if (parent == NULL) {
			// not composite; must have only one child
			continue;
			}
		if (node != parent->LastChild())
			return false;
		}

	// got to the top and we're still last
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* EnclosingLeafBlockElement()
{
	DisplayNode* block = textNode->EnclosingLeafBlock();
	for (; block; block = block->Parent()) {
		ElementDisplayNode* elementDisplayNode =
			dynamic_cast<ElementDisplayNode*>(block);
		if (elementDisplayNode)
			return elementDisplayNode->GetElement();
		}
	throw InternalException("CharacterSelection::EnclosingLeafBlockElement: there wasn't one.");
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextDisplayNode* textNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int ascent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int caretWidth = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int caretHeight = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagXOffset = -7;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagYOffset = 8;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:31:22 PDT" wind-frame="94.000000,155.000000,734.000000,685.000000" list-views-height="0.000000">
<name>
CharacterSelection
</name>
<superclasses>
public PointSelection
</superclasses>
<hIncludes><![CDATA[
#include "PointSelection.h"

class TextDisplayNode;
class Word;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Word.h"
#include "Space.h"
#include "AddCharsAction.h"
#include "BackCharsAction.h"
#include "CompositeAction.h"
#include "NewElementAction.h"
#include "SplitTextAction.h"
#include "SplitElementAction.h"
#include "RestoreSelectionAction.h"
#include "RestorePointSelectionAction.h"
#include "DisplayDirector.h"
#include "Text.h"
#include "GlyphsSelection.h"
#include "BetweenWordsSelection.h"
#include "BetweenGlyphsSelection.h"
#include "View.h"
#include "Font.h"
#include "Keys.h"
#include "UTF8Utils.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CharacterSelection(TextDisplayNode* textNodeIn, Word* wordIn, int charIndexIn)
	: PointSelection(textNodeIn), word(wordIn), charIndex(charIndexIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	Text* text = textNode->GetText();
	int offset = textNode->OffsetOfGlyph(word);
	if (offset < 0)
		throw InternalException("CharacterSelection::AcceptKey(): couldn't get glyph offset.");
	offset += charIndex;

	if (tagEditor || (key == "\t" && !textNode->IsPreSpace()))
		PointSelection::AcceptKey(key, director);

	else if (key == "\b") {
		// step back one character, accounting for UTF8
		offset -= 1;
		DOMString textData = text->Data();
		const char* str = textData.begin();
		while (offset > 0 && !UTF8Utils::IsFirstByte(str[offset]))
			--offset;
		director->DoAction(new BackCharsAction(text, offset));
		}

	else if (key == Keys::DelKey)
		director->DoAction(new BackCharsAction(text, offset));

	else if (key == "\n") {
		HandleReturn(textNode->OffsetOfGlyph(word) + charIndex, director);
/***
		CompositeAction* action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		Text* text = textNode->GetText();
		unsigned long offset =
			textNode->OffsetOfGlyph(word) + charIndex;
		action->AddAction(new SplitTextAction(text, offset));
		action->AddAction(new SplitElementAction(EnclosingLeafBlockElement(), text));
		director->DoAction(action);
***/
		}

	else if (key == Keys::RightArrowKey) {
		if ((director->WindowView()->CurModifiers() & OptionModifier) != 0) {
			// go past the word
			SelectPastWord(word, director);
			}
		else {
			// forward one char, accounting for UTF8
			offset += 1;
			DOMString textData = text->Data();
			const char* str = textData.begin();
			int len = textData.length();
			while (offset < len && !UTF8Utils::IsFirstByte(str[offset]))
				++offset;
			director->SetSelection(textNode->GetSelectionAtOffset(offset));
			}
		director->ScrollToSelection();
		}

	else if (key == Keys::LeftArrowKey) {
		if ((director->WindowView()->CurModifiers() & OptionModifier) != 0) {
			// go back past the word
			SelectBeforeWord(word, director);
			}
		else {
			// back one char, accounting for UTF8
			offset -= 1;
			const char* str = text->Data().begin();
			while (offset > 0 && !UTF8Utils::IsFirstByte(str[offset]))
				--offset;
			director->SetSelection(textNode->GetSelectionAtOffset(offset));
			}
		director->ScrollToSelection();
		}

	else
		director->DoAction(new AddCharsAction(key, text, offset));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* ExtendTo(CoordPoint point)
{
	/***/
	return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	GlyphRef glyphRef(textNode, word);
	director->SetSelection(GlyphsSelection::SelectionFromTo(glyphRef, glyphRef));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	unsigned long offset = textNode->OffsetOfGlyph(word) + charIndex;
	return new RestorePointSelectionAction(textNode->GetText(), offset);
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 21:23:23 PST"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 22:02:56 PST"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	Text* text = textNode->GetText();
	int offset = textNode->OffsetOfGlyph(word);
	if (offset < 0)
		throw InternalException("CharacterSelection::Paste(): couldn't get glyph offset.");
	offset += charIndex;

	director->DoAction(new AddCharsAction(pasteText, text, offset));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PointSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint Point()
{
	CoordPoint point = BlockOrigin(textNode);
	Font* font = textNode->CurFont();
	point.x += word->GetX() +
		font->WidthOf(word->GetDisplayWord().substr(0, word->DocToDisplayOffset(charIndex)));
	point.y += word->GetY() + font->Ascent();
	return point;
}
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:31:22 PDT"><![CDATA[
void InsertTag(DOMString tagName, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	Text* text = textNode->GetText();
	SplitTextAction* splitAction =
		new SplitTextAction(text, textNode->OffsetOfGlyph(word) + charIndex);
	action->AddAction(splitAction);
	Text* splitText = splitAction->GetNewText();
	action->AddAction(new NewElementAction(tagName, text->ParentNode(), splitText));
	director->DoAction(action);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Word* word;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int charIndex;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:31:42 PDT" wind-frame="155.000000,151.000000,795.000000,681.000000" list-views-height="0.000000">
<name>
BetweenGlyphsSelection
</name>
<superclasses>
public PointSelection
</superclasses>
<hIncludes><![CDATA[
#include "PointSelection.h"

class TextDisplayNode;
class Glyph;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "BlockableDisplayNode.h"
#include "Text.h"
#include "Element.h"
#include "Glyph.h"
#include "Space.h"
#include "DisplayDirector.h"
#include "CompositeAction.h"
#include "AddCharsAction.h"
#include "SplitTextAction.h"
#include "NewElementAction.h"
#include "MergeElementsAction.h"
#include "SelectPointAction.h"
#include "RestoreSelectionAction.h"
#include "RestorePointSelectionAction.h"
#include "BetweenWordsSelection.h"
#include "BetweenBlocksSelection.h"
#include "GlyphsSelection.h"
#include "Font.h"
#include "View.h"
#include "Keys.h"
#include "UTF8Utils.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BetweenGlyphsSelection(TextDisplayNode* textNodeIn,
                       Glyph* firstGlyphIn, Glyph* secondGlyphIn,
                       bool promoteBeforeIn)
	: PointSelection(textNodeIn),
	  firstGlyph(firstGlyphIn), secondGlyph(secondGlyphIn),
	  promoteBefore(promoteBeforeIn)
{
	// double-check validity of "promoteBefore"
	if (promoteBefore) {
		if (firstGlyph == NULL)
			promoteBefore = false;
		}
	else {
		if (secondGlyph == NULL)
			promoteBefore = true;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	if (tagEditor || (key == "\t" && !textNode->IsPreSpace()))
		PointSelection::AcceptKey(key, director);
	else if (key == "\b") {
		if (firstGlyph)
			director->DoAction(firstGlyph->DeleteBackAction(textNode));
		else if (IsInFirstTextOfBlock()) {
			// merge with the previous node
			MergeElementsAction* mergeAction =
				new MergeElementsAction(EnclosingLeafBlockElement());
			if (mergeAction->IsValid()) {
				CompositeAction* action = new CompositeAction();
				action->AddAction(new RestoreSelectionAction());
				action->AddAction(mergeAction);
				action->AddAction(new SelectPointAction(textNode->GetText(), 0));
				director->DoAction(action);
				}
			else
				delete mergeAction;
			}
		}
	else if (key == Keys::DelKey) {
		if (secondGlyph)
			director->DoAction(secondGlyph->DeleteFrontAction(textNode));
		}
	else if (key == Keys::RightArrowKey)
		SelectForward(director);
	else if (key == Keys::LeftArrowKey)
		SelectBackward(director);
	else if (key == "\n") {
		unsigned long offset =
			(secondGlyph ? textNode->OffsetOfGlyph(secondGlyph) :
			               textNode->GetText()->Length());
		HandleReturn(offset, director);
/***
		if (secondGlyph == NULL && IsInLastTextOfBlock()) {
			// new paragraph
			Action* newLeafBlockAction =
				new NewLeafBlockAction(EnclosingLeafBlockElement());
			director->DoAction(new RestoreSelectionAction(newLeafBlockAction));
			}
		else {
			// split the paragraph
			CompositeAction* action = new CompositeAction();
			action->AddAction(new RestoreSelectionAction());
			Text* text = textNode->GetText();
			if (secondGlyph) {
				unsigned long offset = textNode->OffsetOfGlyph(secondGlyph);
				action->AddAction(new SplitTextAction(text, offset));
				}
			action->AddAction(new SplitElementAction(EnclosingLeafBlockElement(), text));
			director->DoAction(action);
			}
***/
		}
	else {
		int offset;
		if (secondGlyph)
			offset = textNode->OffsetOfGlyph(secondGlyph);
		else {
			// we're at the end of the text, so the offset is its length
			offset = textNode->GetText()->Length();
			}
		if (offset < 0)
			throw InternalException("BetweenGlyphsSelection::AcceptKey(): couldn't get glyph offset.");
		director->DoAction(new AddCharsAction(key, textNode->GetText(), offset));
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* ExtendTo(CoordPoint point)
{
	/***/
	return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	unsigned long offset = 0;
	if (secondGlyph)
		offset = textNode->OffsetOfGlyph(secondGlyph);
	else if (firstGlyph)
		offset = textNode->OffsetOfGlyph(firstGlyph) + firstGlyph->NumCharsInText();
	return new RestorePointSelectionAction(textNode->GetText(), offset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	Glyph* selectedGlyph;
	if (promoteBefore && firstGlyph)
		selectedGlyph = firstGlyph;
	else if (secondGlyph)
		selectedGlyph = secondGlyph;
	else
		return;

	GlyphRef glyphRef(textNode, selectedGlyph);
	director->SetSelection(GlyphsSelection::SelectionFromTo(glyphRef, glyphRef));
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 22:03:19 PST"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 22:02:56 PST"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	int offset;
	if (secondGlyph)
		offset = textNode->OffsetOfGlyph(secondGlyph);
	else {
		// we're at the end of the text, so the offset is its length
		offset = textNode->GetText()->Length();
		}
	if (offset < 0)
		throw InternalException("BetweenGlyphsSelection::Paste(): couldn't get glyph offset.");

	director->DoAction(new AddCharsAction(pasteText, textNode->GetText(), offset));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PointSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint Point()
{
	CoordPoint point = BlockOrigin(textNode);
	Font* font = textNode->CurFont();
	if (firstGlyph && !(firstGlyph->IsLineBreak() && secondGlyph)) {
		// prefer the end of the firstGlyph, in case it's a space at the
		// end of a line
		point.x += firstGlyph->GetX() + firstGlyph->Width(font);
		point.y += firstGlyph->GetY() + font->Ascent();
		}
	else if (secondGlyph) {
		point.x += secondGlyph->GetX();
		point.y += secondGlyph->GetY() + font->Ascent();
		}
	else {
		point.y += font->Ascent();
		// find out where the previous glyph ended (if there is one)
		DisplayNode* curNode = textNode;
		while (true) {
			// find the next (previous) node to check
			bool wentUp = false;
			DisplayNode* prevDisplayNode = curNode->PreviousSibling();
			if (prevDisplayNode == NULL) {
				prevDisplayNode = curNode->Parent();
				wentUp = true;
				}
			InlineableDisplayNode* prevNode =
				dynamic_cast<InlineableDisplayNode*>(prevDisplayNode);
			if (prevNode == NULL || prevNode->GetDisplayType() == Block)
				break;	// we went too far up
			if (wentUp) {
				// we don't actually want to check this node, go to its prev sibling
				curNode = prevDisplayNode;
				continue;
				}

			// see if it has any glyphs
			GlyphRef prevGlyph = prevNode->LastGlyph();
			if (prevGlyph.IsValid()) {
				point.x += prevGlyph.glyph->GetX() +
				           prevGlyph.glyph->Width(prevGlyph.textNode->CurFont());
				point.y += prevGlyph.glyph->GetY();
				break;
				}

			// go around again
			curNode = prevDisplayNode;
			}
		}
	return point;
}
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:31:42 PDT"><![CDATA[
void InsertTag(DOMString tagName, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	Text* text = textNode->GetText();
	Text* beforeText;
	if (firstGlyph) {
		int offset = textNode->OffsetOfGlyph(firstGlyph) + firstGlyph->NumCharsInText();
		SplitTextAction* splitAction = new SplitTextAction(text, offset);
		action->AddAction(splitAction);
		beforeText = splitAction->GetNewText();
		}
	else
		beforeText = text;
	action->AddAction(new NewElementAction(tagName, text->ParentNode(), beforeText));
	director->DoAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CaretOutLeft()
{
	return (firstGlyph != NULL || secondGlyph == NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CaretOutRight()
{
	return (secondGlyph != NULL || firstGlyph == NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectForward(DisplayDirector* director)
{
	// if the option key is down, select after the secondGlyph
	if ((director->WindowView()->CurModifiers() & OptionModifier) != 0) {
		if (secondGlyph == NULL)
			SelectPastText(director);
		else
			SelectPastWord(secondGlyph, director);
		}

	// select one character forward
	else if (secondGlyph) {
		director->SetSelection(secondGlyph->SelectionIntoFront(textNode));
		}
	else {
		// at end of the textNode; find the next point selection in the document
		SelectPastText(director);
		}

	director->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectBackward(DisplayDirector* director)
{
	// if the option key is down, select before the firstGlyph
	if ((director->WindowView()->CurModifiers() & OptionModifier) != 0) {
		if (firstGlyph == NULL)
			SelectBeforeText(director);
		else
			SelectBeforeWord(firstGlyph, director);
		}

	// select one character backward
	else if (firstGlyph) {
		director->SetSelection(firstGlyph->SelectionIntoBack(textNode));
		}
	else {
		// at beginning of the textNode; find the previous point selection in the document
		SelectBeforeText(director);
		}

	director->ScrollToSelection();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* firstGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* secondGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool promoteBefore;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:31:53 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BetweenWordsSelection
</name>
<superclasses>
public PointSelection
</superclasses>
<hIncludes><![CDATA[
#include "PointSelection.h"

class TextDisplayNode;
class Space;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Space.h"
#include "DisplayDirector.h"
#include "Text.h"
#include "CompositeAction.h"
#include "AddCharsAction.h"
#include "NewLeafBlockAction.h"
#include "NewElementAction.h"
#include "SplitTextAction.h"
#include "SplitElementAction.h"
#include "RestoreSelectionAction.h"
#include "RestoreBetweenWordsSelectionAction.h"
#include "BetweenGlyphsSelection.h"
#include "Font.h"
#include "View.h"
#include "Keys.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BetweenWordsSelection(TextDisplayNode* textNodeIn, Space* spaceIn)
	: PointSelection(textNodeIn), space(spaceIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	if (tagEditor || (key == "\t" && !textNode->IsPreSpace()))
		PointSelection::AcceptKey(key, director);

	else if (key == "\b" || key == Keys::DelKey)
		director->DoAction(space->DeleteBackAction(textNode));

	else if (key == Keys::RightArrowKey)
		SelectForward(director);

	else if (key == Keys::LeftArrowKey)
		SelectBackward(director);

	else if (key == "\n") {
		unsigned long offset =
			textNode->OffsetOfGlyph(space) + space->NumCharsInText();
		HandleReturn(offset, director);
/***
		if (textNode->GlyphAfter(space) == NULL && IsInLastTextOfBlock()) {
			// new paragraph
			Action* newLeafBlockAction =
				new NewLeafBlockAction(EnclosingLeafBlockElement());
			director->DoAction(new RestoreSelectionAction(newLeafBlockAction));
			}
		else {
			// split the paragraph
			CompositeAction* action = new CompositeAction();
			action->AddAction(new RestoreSelectionAction());
			Text* text = textNode->GetText();
			if (textNode->GlyphAfter(space) != NULL) {
				unsigned long offset =
					textNode->OffsetOfGlyph(space) + space->NumCharsInText();
				action->AddAction(new SplitTextAction(text, offset));
				}
			action->AddAction(new SplitElementAction(EnclosingLeafBlockElement(), text));
			director->DoAction(action);
			}
***/
		}

	else {
		// inserting a word--do it at the beginning of the whitespace, so
		// additional characters will go at the end of the word
		int offset = textNode->OffsetOfGlyph(space);
		if (offset < 0)
			throw InternalException("BetweenGlyphsSelection::AcceptKey(): couldn't get glyph offset.");
		qstring insertion = " ";
		insertion += key;

		director->DoAction(new AddCharsAction(insertion, textNode->GetText(), offset));
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Selection* ExtendTo(CoordPoint point)
{
	/***/
	return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	return new RestoreBetweenWordsSelectionAction(textNode->GetText(),
	                                              textNode->OffsetOfGlyph(space));
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 22:03:20 PST"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 22:02:55 PST"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	// inserting a word--do it at the beginning of the whitespace, so
	// additional characters will go at the end of the word
	//*** someday check for existing whitespace in the pasteText
	int offset = textNode->OffsetOfGlyph(space);
	if (offset < 0)
		throw InternalException("BetweenWordsSelection::Paste(): couldn't get glyph offset.");
	qstring insertion = " ";
	insertion += pasteText;

	director->DoAction(new AddCharsAction(insertion, textNode->GetText(), offset));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PointSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint Point()
{
	CoordPoint point = BlockOrigin(textNode);
	Font* font = textNode->CurFont();
	point.x += space->GetX() + space->Width(font) / 2;
	point.y += space->GetY() + font->Ascent();
	return point;
}
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:31:53 PDT"><![CDATA[
void InsertTag(DOMString tagName, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	Text* text = textNode->GetText();
	SplitTextAction* splitAction =
		new SplitTextAction(text, textNode->OffsetOfGlyph(space) + space->NumCharsInText());
	action->AddAction(splitAction);
	Text* splitText = splitAction->GetNewText();
	action->AddAction(new AddCharsAction(" ", splitText, 0));
	action->AddAction(new NewElementAction(tagName, text->ParentNode(), splitText));
	director->DoAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectForward(DisplayDirector* director)
{
	if ((director->WindowView()->CurModifiers() & OptionModifier) != 0) {
		// skip past the next word
		Glyph* nextWord = textNode->GlyphAfter(space);
		if (nextWord == NULL)
			SelectPastText(director);
		else {
			SelectPastWord(nextWord, director);
/***
			Glyph* nextGlyph = textNode->GlyphAfter(nextWord);
			Space* nextSpace = dynamic_cast<Space*>(nextGlyph);
			if (nextSpace)
				director->SetSelection(new BetweenWordsSelection(textNode, nextSpace));
			else {
				director->SetSelection(new BetweenGlyphsSelection(textNode,
				                                                  nextWord, nextGlyph,
				                                                  true));
				}
***/
			}
		}

	else {
		director->SetSelection(new BetweenGlyphsSelection(textNode, space,
		                                                  textNode->GlyphAfter(space),
		                                                  false));
		}
	director->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectBackward(DisplayDirector* director)
{
	if ((director->WindowView()->CurModifiers() & OptionModifier) != 0) {
		// skip to before the previous word
		Glyph* prevWord = textNode->GlyphBefore(space);
		if (prevWord == NULL)
			SelectBeforeText(director);
		else {
			SelectBeforeWord(prevWord, director);
/***
			Glyph* prevGlyph = textNode->GlyphBefore(prevWord);
			Space* prevSpace = dynamic_cast<Space*>(prevGlyph);
			if (prevSpace)
				director->SetSelection(new BetweenWordsSelection(textNode, prevSpace));
			else {
				director->SetSelection(new BetweenGlyphsSelection(textNode,
				                                                  prevGlyph, prevWord,
				                                                  false));
				}
***/
			}
		}

	else {
		director->SetSelection(new BetweenGlyphsSelection(textNode,
		                                                  textNode->GlyphBefore(space),
		                                                  space, true));
		}

	director->ScrollToSelection();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Space* space;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:32:09 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
EmptyPlaceholderSelection
</name>
<superclasses>
public BetweenGlyphsSelection
</superclasses>
<hIncludes><![CDATA[
#include "BetweenGlyphsSelection.h"

class PlaceholderTextDisplayNode;
class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Text.h"
#include "PlaceholderTextDisplayNode.h"
#include "ElementDisplayNode.h"
#include "DisplayDirector.h"
#include "CompositeAction.h"
#include "NewTextAction.h"
#include "MoveNodesAction.h"
#include "AddCharsAction.h"
#include "ChangeElementTagNameAction.h"
#include "RestoreSelectionAction.h"
#include "RestoreEmptyPlaceholderSelectionAction.h"
#include "Keys.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EmptyPlaceholderSelection(PlaceholderTextDisplayNode* textNodeIn)
	: BetweenGlyphsSelection(textNodeIn, NULL, NULL, false)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	// create the tagEditor if there isn't one yet
	// we'd do this in the ctor, except stupid C++ can't call derived virtual
	//		functions from the ctor
	if (tagEditor == NULL)
		ShowTag(textNode->GetDisplayDirector());

	BetweenGlyphsSelection::Draw(view, origin);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	if (TagIsSelected() || key == "\t")
		PointSelection::AcceptKey(key, director);
	else if (key == "\b" || key == Keys::DelKey) {
		/***/
		}
	else if (key == "\n") {
		/***/
		}
	else if (key == Keys::RightArrowKey)
		SelectForward(director);
	else if (key == Keys::LeftArrowKey)
		SelectBackward(director);
	else {
		// add contents to the element
		Element* element = GetElement();
		CompositeAction* action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		NewTextAction* newTextAction = new NewTextAction(element->OwnerDocument());
		action->AddAction(newTextAction);
		Text* newText = newTextAction->GetText();
		action->AddAction(new MoveNodesAction(newText, newText, element, NULL));
		action->AddAction(new AddCharsAction(key, newText, 0));
		director->DoAction(action);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	return new RestoreEmptyPlaceholderSelectionAction(GetElement());
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 22:06:14 PST"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	// add pasteText to the element
	Element* element = GetElement();
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	NewTextAction* newTextAction = new NewTextAction(element->OwnerDocument());
	action->AddAction(newTextAction);
	Text* newText = newTextAction->GetText();
	action->AddAction(new MoveNodesAction(newText, newText, element, NULL));
	action->AddAction(new AddCharsAction(pasteText, newText, 0));
	director->DoAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"PointSelection virtuals"
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:32:09 PDT"><![CDATA[
void InsertTag(DOMString tagName, DisplayDirector* director)
{
	HideTag(director);	// for safety
	ChangeElementTagNameAction* changeTagAction =
		new ChangeElementTagNameAction(GetElement(), tagName);
	director->DoAction(new RestoreSelectionAction(changeTagAction));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"TagSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return GetElement()->TagName();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* GetElement()
{
	for (DisplayNode* node = textNode->Parent(); node; node = node->Parent()) {
		ElementDisplayNode* elementNode = dynamic_cast<ElementDisplayNode*>(node);
		if (elementNode)
			return elementNode->GetElement();
		}
	if (useAssertions)
		throw InternalException("EmptyPlaceholderSelection: parent isn't an ElementDisplayNode.");
	return NULL;
}
]]></method>

</class>


<class mod-time="Sat, 03 Jun 2000 23:52:17 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GlyphsSelection
</name>
<superclasses>
public TagSelection
</superclasses>
<hIncludes><![CDATA[
#include "TagSelection.h"
#include "GlyphRef.h"
#include "InternalException.h"

class GlyphsHilite;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphsHilite.h"
#include "TagEditor.h"
#include "TextDisplayNode.h"
#include "ElementDisplayNode.h"
#include "BlockableDisplayNode.h"
#include "GlyphLoc.h"
#include "Glyph.h"
#include "Text.h"
#include "Element.h"
#include "CompositeAction.h"
#include "AddCharsAction.h"
#include "DeleteCharsAction.h"
#include "NewTextAction.h"
#include "RemoveNodesAction.h"
#include "SplitTextAction.h"
#include "EncloseTextAction.h"
#include "SelectPointAction.h"
#include "RestoreSelectionAction.h"
#include "RestoreGlyphsSelectionAction.h"
#include "DisplayDirector.h"
#include "XMLStringWriter.h"
#include "View.h"
#include "Keys.h"
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsSelection(GlyphRef firstGlyphIn, GlyphRef lastGlyphIn)
	: firstGlyph(firstGlyphIn), lastGlyph(lastGlyphIn)
{
	hilite = new GlyphsHilite(firstGlyph, lastGlyph);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~GlyphsSelection()
{
	delete hilite;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access & Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool HasEmbeddedElement()
{
	return (firstGlyph.GetTextNode() != lastGlyph.GetTextNode());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef FirstGlyph()
{
	return firstGlyph;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef LastGlyph()
{
	return lastGlyph;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Selection* SelectionFromTo(GlyphRef firstGlyph, GlyphRef lastGlyph)
{
	// see if it's selecting an entire element
	InlineableDisplayNode* ancestor =
		dynamic_cast<InlineableDisplayNode*>(firstGlyph.CommonAncestorWith(lastGlyph));
	if (ancestor && firstGlyph == ancestor->FirstSelectableGlyph() && lastGlyph == ancestor->LastSelectableGlyph()) {
		ElementDisplayNode* elementNode;
		// if the ancestor is a text node, and the only child of an element, check
		// that element
		TextDisplayNode* textNode = dynamic_cast<TextDisplayNode*>(ancestor);
		if (textNode) {
			elementNode = dynamic_cast<ElementDisplayNode*>(textNode->Parent());
			if (elementNode && elementNode->FirstChild() == textNode && elementNode->LastChild() == textNode)
				ancestor = elementNode;
			}
		// if the ancestor is an element, select it
		elementNode = dynamic_cast<ElementDisplayNode*>(ancestor);
		if (elementNode)
			return elementNode->GetSelection();
		}

	// otherwise, just use a GlyphsSelection
	return new GlyphsSelection(firstGlyph, lastGlyph);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	if (tagEditor) {
		tagEditor->Draw(view->Bounds());
		hilite->Draw(view, origin, tagEditor->Bounds());
		}
	else
		hilite->Draw(view, origin);
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:49:24 PDT"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	int offset;

	if (tagEditor || key == "\t")
		TagSelection::AcceptKey(key, director);
	else if (key == "\n") {
		// not supported yet
		/***/
		}
	else if (key == Keys::LeftArrowKey) {
		offset = firstGlyph.textNode->OffsetOfGlyph(firstGlyph.glyph);
		director->SetSelection(firstGlyph.textNode->GetSelectionAtOffset(offset));
		director->ScrollToSelection();
		}
	else if (key == Keys::RightArrowKey) {
		offset = lastGlyph.textNode->OffsetOfGlyph(lastGlyph.glyph) +
			lastGlyph.glyph->NumCharsInText();
		director->SetSelection(lastGlyph.textNode->GetSelectionAtOffset(offset));
		director->ScrollToSelection();
		}
	else {
		String newText = key;
		if (key == "\b" || key == Keys::DelKey)
			newText = "";
		ReplaceText(newText, director);
#ifdef NOT_ANYMORE
		// set up
		DisplayNode* ancestor = firstGlyph.CommonAncestorWith(lastGlyph);
		if (ancestor == NULL)
			throw InternalException("GlyphsSelection::AcceptKey: No common ancestor.");
		bool hasFirstText = (firstGlyph.textNode->Parent() == ancestor);
		bool hasLastText = (lastGlyph.textNode->Parent() == ancestor);
		bool oneText = (firstGlyph.textNode == lastGlyph.textNode);
		bool hasNodes =
			(!oneText &&
				(!hasFirstText || !hasLastText ||
				 firstGlyph.textNode->NextSibling() != firstGlyph.textNode));
		CompositeAction* action = new CompositeAction();
		action->AddAction(new RestoreGlyphsSelectionAction());
		// clear out anything that's there
		if (oneText) {
			unsigned long startOffset = firstGlyph.StartOffset();
			action->AddAction(new DeleteCharsAction(firstGlyph.textNode->GetText(),
			                                        startOffset,
			                                        lastGlyph.EndOffset() - startOffset));
			}
		else {
			if (hasFirstText) {
				Text* firstText = firstGlyph.textNode->GetText();
				unsigned long offset = firstGlyph.StartOffset();
				action->AddAction(new DeleteCharsAction(firstText, offset,
				                                        firstText->Length() - offset));
				}
			if (hasLastText) {
				action->AddAction(new DeleteCharsAction(lastGlyph.textNode->GetText(),
				                                        0, lastGlyph.EndOffset()));
				}
			if (hasNodes) {
				ElementDisplayNode* ancestorDisplayNode = dynamic_cast<ElementDisplayNode*>(ancestor);
				if (ancestorDisplayNode == NULL)
					throw InternalException("GlyphsSelection::AcceptKey: ancestor isn't an element.");
				Element* ancestorElement = ancestorDisplayNode->GetElement();
				Node* firstDeleteNode = firstGlyph.textNode->GetText();
				while (firstDeleteNode->ParentNode() != ancestorElement)
					firstDeleteNode = firstDeleteNode->ParentNode();
				if (hasFirstText)
					firstDeleteNode = firstDeleteNode->NextSibling();
				Node* lastDeleteNode = lastGlyph.textNode->GetText();
				while (lastDeleteNode->ParentNode() != ancestorElement)
					lastDeleteNode = lastDeleteNode->ParentNode();
				if (hasLastText)
					lastDeleteNode = lastDeleteNode->PreviousSibling();
				action->AddAction(new RemoveNodesAction(firstDeleteNode, lastDeleteNode));
				}
			}
		// add in the key
		if (key == "\b" || key == Keys::DelKey) {
			// just select
			Text* selectText = NULL;
			unsigned long selectOffset = 0;
			if (oneText || hasFirstText) {
				selectText = firstGlyph.textNode->GetText();
				selectOffset = firstGlyph.StartOffset();
				}
			else if (hasLastText) {
				selectText = lastGlyph.textNode->GetText();
				selectOffset = 0;
				}
			else {
				// we don't handle this yet (point selection between two Elements)
				/***/
				}
			if (selectText)
				action->AddAction(new SelectPointAction(selectText, selectOffset));
			}
		else {
			Text* destText;
			unsigned long destOffset;
			if (oneText || hasFirstText) {
				destText = firstGlyph.textNode->GetText();
				destOffset = firstGlyph.StartOffset();
				}
			else if (hasLastText) {
				destText = lastGlyph.textNode->GetText();
				destOffset = 0;
				}
			else {
				NewTextAction* newTextAction =
					new NewTextAction(firstGlyph.textNode->GetText()->OwnerDocument());
				action->AddAction(newTextAction);
				destText = newTextAction->GetText();
				destOffset = 0;
				}
			action->AddAction(new AddCharsAction(key, destText, destOffset));
				// this will do the selection also
			}
		// go!
		director->DoAction(action);
#endif
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	DisplayNode* node = firstGlyph.CommonAncestorWith(lastGlyph);

	// get out of the selection
	while (node) {
		InlineableDisplayNode* inlineNode = dynamic_cast<InlineableDisplayNode*>(node);
		if (inlineNode == NULL || inlineNode->GetDisplayType() != Inline)
			break;
		if (firstGlyph != inlineNode->FirstSelectableGlyph() ||
				lastGlyph != inlineNode->LastSelectableGlyph())
			break;
		node = node->Parent();
		}

	// get the nearest enclosing selection
	Selection* newSelection = NULL;
	for (; node; node = node->Parent()) {
		newSelection = node->GetSelection();
		if (newSelection)
			break;
		}

	// select
	if (newSelection)
		director->SetSelection(newSelection);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* ExtendTo(CoordPoint point)
{
	if (hilite->ContainsPoint(point))
		return this;

	// convert point to leaf-block coords
	BlockableDisplayNode* leafBlock = firstGlyph.GetTextNode()->EnclosingLeafBlock();
	point.y -= leafBlock->Top();
	point.x -= leafBlock->LeftSpace();

	DisplayNode* rawNode;

	// before current selection
	if (GlyphLoc(firstGlyph) > point) {
		// work backwards until we find it
		GlyphRef newFirstGlyph = firstGlyph;
		for (rawNode = firstGlyph.GetTextNode(); rawNode; rawNode = rawNode->PreviousSibling()) {
			InlineableDisplayNode* node = dynamic_cast<InlineableDisplayNode*>(rawNode);
			if (node == NULL)
				throw InternalException("GlyphsSelection::ExtendTo: Sibling is not inline.");

			// figure out whether to look in this node
			if (!node->CanSelectAcross())
				break;
			GlyphRef nodesFirstGlyph = node->FirstSelectableGlyph();
			if (!nodesFirstGlyph.IsValid())
				continue;
			if (GlyphLoc(node->LastSelectableGlyph()) < point)
				break;
			if (GlyphLoc(nodesFirstGlyph) >= point) {
				newFirstGlyph = nodesFirstGlyph;
				continue;
				}

			// we've now found the node to look into; check if it's a TextDisplayNode
			TextDisplayNode* textNode = dynamic_cast<TextDisplayNode*>(node);
			if (textNode == NULL) {
				// probly an element; select from its beginning
				newFirstGlyph = nodesFirstGlyph;
				break;
				}

			// it *is* a TextDisplayNode; find out which glyph to use
			Glyph* foundGlyph = textNode->GlyphAtPoint(point);
			if (foundGlyph)
				newFirstGlyph.Set(textNode, foundGlyph);
			break;
			}

		// return the new selection
		return SelectionFromTo(newFirstGlyph, lastGlyph);
		}

	// after current selection
	else {
		// work forwards until we find it
		GlyphRef newLastGlyph = lastGlyph;
		for (rawNode = lastGlyph.GetTextNode(); rawNode; rawNode = rawNode->NextSibling()) {
			InlineableDisplayNode* node = dynamic_cast<InlineableDisplayNode*>(rawNode);
			if (node == NULL)
				throw InternalException("GlyphsSelection::ExtendTo: Sibling is not inline.");

			// figure out whether to look in this node
			if (!node->CanSelectAcross())
				break;
			GlyphRef nodesLastGlyph = node->LastSelectableGlyph();
			if (!nodesLastGlyph.IsValid())
				continue;
			if (GlyphLoc(node->FirstSelectableGlyph()) > point)
				break;
			if (GlyphLoc(nodesLastGlyph) <= point) {
				newLastGlyph = nodesLastGlyph;
				continue;
				}

			// we've now found the node to look into; check if it's a TextDisplayNode
			TextDisplayNode* textNode = dynamic_cast<TextDisplayNode*>(node);
			if (textNode == NULL) {
				// probly an element; select to its end
				newLastGlyph = nodesLastGlyph;
				break;
				}

			// it *is* a TextDisplayNode; find out which glyph to use
			Glyph* foundGlyph = textNode->GlyphAtPoint(point);
			if (foundGlyph)
				newLastGlyph.Set(textNode, foundGlyph);
			break;
			}

		// return the new selection
		return SelectionFromTo(firstGlyph, newLastGlyph);
		}

	return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	return new RestoreGlyphsSelectionAction();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	return hilite->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	return hilite->IsVisible(pageRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsClip()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ContainsPoint(CoordPoint point)
{
	return hilite->ContainsPoint(point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DragStartPoint(CoordPoint destPoint)
{
	return hilite->DragStartPoint(destPoint);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanCopy()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetXMLCopy()
{
	// handle single-text case
	bool singleText = (firstGlyph.textNode == lastGlyph.textNode);
	if (singleText) {
		int startOffset = firstGlyph.StartOffset();
		int endOffset = lastGlyph.EndOffset();
		return firstGlyph.textNode->GetText()->SubstringData(startOffset, endOffset - startOffset);
		}

	// get info about the structure
	DisplayNode* ancestor = firstGlyph.CommonAncestorWith(lastGlyph);
	bool startsWithText = (firstGlyph.textNode->Parent() == ancestor);
	bool endsWithText = (lastGlyph.textNode->Parent() == ancestor);

	// find out where the first and last embedded elements are
	// first
	ElementDisplayNode* firstElementDisplayNode = NULL;
	if (!startsWithText) {
		// it's the element the first glyph is in
		DisplayNode* firstElementNode = firstGlyph.textNode;
		while (firstElementNode) {
			if (firstElementNode->Parent() == ancestor)
				break;
			firstElementNode = firstElementNode->Parent();
			}
		firstElementDisplayNode = dynamic_cast<ElementDisplayNode*>(firstElementNode);
		}
	else {
		firstElementDisplayNode =
			dynamic_cast<ElementDisplayNode*>(firstGlyph.textNode->NextSibling());
		}
	if (firstElementDisplayNode == NULL)
		throw InternalException("GlyphsSelection::GetXMLCopy: Couldn't find firstElementNode.");
	Node* firstElement = firstElementDisplayNode->GetElement();
	// last
	ElementDisplayNode* lastElementDisplayNode = NULL;
	if (!endsWithText) {
		// it's the element the last glyph is in
		DisplayNode* lastElementNode = lastGlyph.textNode;
		while (lastElementNode) {
			if (lastElementNode->Parent() == ancestor)
				break;
			lastElementNode = lastElementNode->Parent();
			}
		lastElementDisplayNode = dynamic_cast<ElementDisplayNode*>(lastElementNode);
		}
	else {
		lastElementDisplayNode =
			dynamic_cast<ElementDisplayNode*>(lastGlyph.textNode->PreviousSibling());
		}
	if (lastElementDisplayNode == NULL)
		throw InternalException("GlyphsSelection::GetXMLCopy: Couldn't find lastElementNode.");
	Node* lastElement = lastElementDisplayNode->GetElement();

	// write the selection
	XMLStringWriter writer(NULL);
	if (startsWithText) {
		Text* startText = firstGlyph.textNode->GetText();
		int startOffset = firstGlyph.StartOffset();
		DOMString startData =
			startText->SubstringData(startOffset, startText->Length() - startOffset);
		writer.AppendString(startData);
		}
	for (Node* node = firstElement; ; node = node->NextSibling()) {
		writer.AppendNode(node);
		if (node == lastElement)
			break;
		}
	if (endsWithText) {
		Text* endText = lastGlyph.textNode->GetText();
		int endOffset = lastGlyph.EndOffset();
		DOMString endData = endText->SubstringData(0, endOffset);
		writer.AppendString(endData);
		}
	return writer.GetString();
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:51:28 PDT"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:51:26 PDT"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	ReplaceText(pasteText, director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"TagSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return "";
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle TagSpecRect()
{
	return hilite->TagSpecRect();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagNameChanged(DOMString newTagName, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());

	if (HasEmbeddedElement()) {
		Error::ShowError("Making a new element from a GlyphsSelection with an embedded element is Coming Soon!");
		delete action;
		return;
		}

	else {
		// split the text up
		// we have to do this in a specific order so the SplitTextAction ctor is
		//	always passed a Text that is currently attached to a Document
		Text* initialText = firstGlyph.textNode->GetText();
		action->AddAction(new SplitTextAction(initialText, lastGlyph.EndOffset()));
		SplitTextAction* frontSplitAction =
			new SplitTextAction(initialText, firstGlyph.StartOffset());
		Text* selectedText = frontSplitAction->GetNewText();
		action->AddAction(frontSplitAction);
/***
		int firstSplitOffset = firstGlyph.StartOffset();
		SplitTextAction* firstSplitAction =
			new SplitTextAction(initialText, firstSplitOffset);
		Text* selectedText = firstSplitAction->GetNewText();
		action->AddAction(firstSplitAction);
		int secondSplitOffset = lastGlyph.EndOffset() - firstSplitOffset;
		action->AddAction(new SplitTextAction(selectedText, secondSplitOffset));
***/

		// enclose the selected text in a new tag
		action->AddAction(new EncloseTextAction(selectedText, newTagName));
		}

	director->DoAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagEditDone(DisplayDirector* director)
{
	HideTag(director);
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:46:12 PDT"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:52:17 PDT"><![CDATA[
void ReplaceText(String newText, DisplayDirector* director)
{
	// set up
	DisplayNode* ancestor = firstGlyph.CommonAncestorWith(lastGlyph);
	if (ancestor == NULL)
		throw InternalException("GlyphsSelection::AcceptKey: No common ancestor.");
	bool hasFirstText = (firstGlyph.textNode->Parent() == ancestor);
	bool hasLastText = (lastGlyph.textNode->Parent() == ancestor);
	bool oneText = (firstGlyph.textNode == lastGlyph.textNode);
	bool hasNodes =
		(!oneText &&
			(!hasFirstText || !hasLastText ||
			 firstGlyph.textNode->NextSibling() != firstGlyph.textNode));
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreGlyphsSelectionAction());

	// clear out anything that's there
	if (oneText) {
		unsigned long startOffset = firstGlyph.StartOffset();
		action->AddAction(new DeleteCharsAction(firstGlyph.textNode->GetText(),
		                                        startOffset,
		                                        lastGlyph.EndOffset() - startOffset));
		}
	else {
		if (hasFirstText) {
			Text* firstText = firstGlyph.textNode->GetText();
			unsigned long offset = firstGlyph.StartOffset();
			action->AddAction(new DeleteCharsAction(firstText, offset,
			                                        firstText->Length() - offset));
			}
		if (hasLastText) {
			action->AddAction(new DeleteCharsAction(lastGlyph.textNode->GetText(),
			                                        0, lastGlyph.EndOffset()));
			}
		if (hasNodes) {
			ElementDisplayNode* ancestorDisplayNode = dynamic_cast<ElementDisplayNode*>(ancestor);
			if (ancestorDisplayNode == NULL)
				throw InternalException("GlyphsSelection::AcceptKey: ancestor isn't an element.");
			Element* ancestorElement = ancestorDisplayNode->GetElement();
			Node* firstDeleteNode = firstGlyph.textNode->GetText();
			while (firstDeleteNode->ParentNode() != ancestorElement)
				firstDeleteNode = firstDeleteNode->ParentNode();
			if (hasFirstText)
				firstDeleteNode = firstDeleteNode->NextSibling();
			Node* lastDeleteNode = lastGlyph.textNode->GetText();
			while (lastDeleteNode->ParentNode() != ancestorElement)
				lastDeleteNode = lastDeleteNode->ParentNode();
			if (hasLastText)
				lastDeleteNode = lastDeleteNode->PreviousSibling();
			action->AddAction(new RemoveNodesAction(firstDeleteNode, lastDeleteNode));
			}
		}

	// if we're replacing it with nothing, just select the point
	if (newText.empty()) {
		// just select
		Text* selectText = NULL;
		unsigned long selectOffset = 0;
		if (oneText || hasFirstText) {
			selectText = firstGlyph.textNode->GetText();
			selectOffset = firstGlyph.StartOffset();
			}
		else if (hasLastText) {
			selectText = lastGlyph.textNode->GetText();
			selectOffset = 0;
			}
		else {
			// we don't handle this yet (point selection between two Elements)
			/***/
			}
		if (selectText)
			action->AddAction(new SelectPointAction(selectText, selectOffset));
		}

	// add in the new text
	else {
		Text* destText;
		unsigned long destOffset;
		if (oneText || hasFirstText) {
			destText = firstGlyph.textNode->GetText();
			destOffset = firstGlyph.StartOffset();
			}
		else if (hasLastText) {
			destText = lastGlyph.textNode->GetText();
			destOffset = 0;
			}
		else {
			NewTextAction* newTextAction =
				new NewTextAction(firstGlyph.textNode->GetText()->OwnerDocument());
			action->AddAction(newTextAction);
			destText = newTextAction->GetText();
			destOffset = 0;
			}
		action->AddAction(new AddCharsAction(newText, destText, destOffset));
			// this will do the selection also
		}

	// do it
	director->DoAction(action);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef firstGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef lastGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsHilite* hilite;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GlyphRef
</name>
<hIncludes><![CDATA[

class TextDisplayNode;
class Glyph;
class DisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Glyph.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef()
	: textNode(NULL), glyph(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef(TextDisplayNode* textNodeIn, Glyph* glyphIn)
	: textNode(textNodeIn), glyph(glyphIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Set(TextDisplayNode* textNodeIn, Glyph* glyphIn)
{
	textNode = textNodeIn;
	glyph = glyphIn;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access & Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextDisplayNode* GetTextNode() const
{
	return textNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* GetGlyph() const
{
	return glyph;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsValid() const
{
	return (textNode != NULL && glyph != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayNode* CommonAncestorWith(const GlyphRef& otherGlyph) const
{
	// special-case the common case, where both are part of the same textNode
	DisplayNode* firstNode = GetTextNode();
	DisplayNode* lastNode = otherGlyph.GetTextNode();
	if (firstNode == lastNode)
		return firstNode;

	// figure out the levels
	DisplayNode* node;
	int firstLevel = 0;
	for (node = firstNode; node; node = node->Parent())
		++firstLevel;
	int lastLevel = 0;
	for (node = lastNode; node; node = node->Parent())
		++lastLevel;

	// equalize the levels before we start the search
	int i;
	if (firstLevel > lastLevel) {
		for (i = firstLevel - lastLevel; i > 0; --i)
			firstNode = firstNode->Parent();
		}
	else if (lastLevel > firstLevel) {
		for (i = lastLevel - firstLevel; i > 0; --i)
			lastNode = lastNode->Parent();
		}

	// now step up the tree until we find the common ancestor
	while (firstNode != NULL) {
		if (firstNode == lastNode)
			return firstNode;
		firstNode = firstNode->Parent();
		lastNode = lastNode->Parent();
		}

	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long StartOffset()
{
	return textNode->OffsetOfGlyph(glyph);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long EndOffset()
{
	return textNode->OffsetOfGlyph(glyph) + glyph->NumCharsInText();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool operator==(const GlyphRef& other)
{
	return (textNode == other.textNode && glyph == other.glyph);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool operator!=(const GlyphRef& other)
{
	return (textNode != other.textNode || glyph != other.glyph);
}
]]></method>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextDisplayNode* textNode;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* glyph;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:24:05 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GlyphsHilite
</name>
<hIncludes><![CDATA[
#include "GlyphRef.h"
#include "CoordPoint.h"
#include "Rectangle.h"
#include "Color.h"
#include "Selection.h"

class View;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Glyph.h"
#include "Selection.h"
#include "BlockableDisplayNode.h"
#include "View.h"
#include "Font.h"
#include "Shape.h"
#include "Color.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsHilite(GlyphRef firstGlyphIn, GlyphRef lastGlyphIn,
             Color colorIn = Selection::selectionColor)
	: firstGlyph(firstGlyphIn), lastGlyph(lastGlyphIn), color(colorIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:24:05 PST"><![CDATA[
void Draw(View* view, CoordPoint origin, Rectangle tagBounds = Rectangle())
{
	int top, bottom, startX, endX, farLeft, farRight, xRadius, yRadius;

	// set up drawing
	view->PushState();
	view->SetPenSize(lineWidth);
/***
	Color color = Selection::selectionColor;
	color.alpha = 128;
***/
	view->SetDrawingMode(AlphaDrawingMode);
	view->SetHighColor(color);
	bool needsShape = false;

	// clip out the tagBounds
	if (tagBounds.IsValid()) {
		Rectangle allRect(0, 0, 32767, 32767);
		Region clipRegion;
		clipRegion.Set(allRect);
		tagBounds.OffsetBy(origin);
		clipRegion.Exclude(tagBounds);
		view->ConstrainClippingRegion(&clipRegion);
		}

	// common calcs
	// x- and y- radius
	Font* firstFont = firstGlyph.GetTextNode()->CurFont();
	Font* lastFont = lastGlyph.GetTextNode()->CurFont();
	xRadius = (int) (firstGlyph.GetGlyph()->Width(firstFont) * xCornerLength);
	float lastXRadius = lastGlyph.GetGlyph()->Width(lastFont) * yCornerLength;
	if (lastXRadius < xRadius)
		xRadius = (int) lastXRadius;
	if (xRadius < minCornerRadius)
		xRadius = minCornerRadius;
	yRadius = (int) ((firstFont->Ascent() + yOutset) * yCornerLength);
	// startX/endX
	startX = firstGlyph.GetGlyph()->GetX() - xOutset;
	endX = lastGlyph.GetGlyph()->GetX() + lastGlyph.GetGlyph()->Width(lastFont) + xOutset;
	// other
	BlockableDisplayNode* leafBlock = firstGlyph.GetTextNode()->EnclosingLeafBlock();
	origin += CoordPoint(leafBlock->LeftSpace(), leafBlock->Top());
	Shape shape;

	// all on one line
	int firstLine = firstGlyph.GetGlyph()->GetLine();
	int lastLine = lastGlyph.GetGlyph()->GetLine();
	if (firstLine == lastLine) {
		// draw
		top = (int) (firstGlyph.GetGlyph()->GetY() - yOutset);
		bottom = (int) (lastGlyph.GetGlyph()->GetY() + lastFont->Ascent() + lastFont->Descent() + yOutset);
		shape.MoveTo(startX, top + yRadius);
		shape.VerticalCornerTo(startX + xRadius, top);
		shape.LineTo(endX - xRadius, top);
		shape.HorizontalCornerTo(endX, top + yRadius);
		shape.LineTo(endX, bottom - yRadius);
		shape.VerticalCornerTo(endX - xRadius, bottom);
		shape.LineTo(startX + xRadius, bottom);
		shape.HorizontalCornerTo(startX, bottom - yRadius);
		shape.LineTo(startX, top + yRadius);
		shape.Close();
		view->MovePenTo(origin);
		view->StrokeShape(&shape);
		}

	// two lines
	else if (lastLine == firstLine + 1) {
		if (startX >= endX) {
			// discontinuous
			// first line
			top = (int) (firstGlyph.GetGlyph()->GetY() - yOutset);
			bottom = (int) (top + firstFont->Ascent() + firstFont->Descent() + 2 * yOutset);
			float right = leafBlock->Width();
			shape.MoveTo(right, top);
			shape.LineTo(startX + xRadius, top);
			shape.HorizontalCornerTo(startX, top + yRadius);
			shape.LineTo(startX, bottom - yRadius);
			shape.VerticalCornerTo(startX + xRadius, bottom);
			shape.LineTo(right, bottom);
			// second line
			top = (int) (lastGlyph.GetGlyph()->GetY() - yOutset);
			bottom = (int) (top + lastFont->Ascent() + lastFont->Descent() + 2 * yOutset);
			shape.MoveTo(0, top);
			shape.LineTo(endX - xRadius, top);
			shape.HorizontalCornerTo(endX, top + yRadius);
			shape.LineTo(endX, bottom - yRadius);
			shape.VerticalCornerTo(endX - xRadius, bottom);
			shape.LineTo(0, bottom);
			shape.MoveTo(0, bottom);	// makes the shape open-ended (at least on BeOS 4.0)
			// draw
			shape.Close();
			view->MovePenTo(origin);
			view->StrokeShape(&shape);
			}
		else {
			// continuous
			needsShape = true;
			}
		}

	// three or more lines
	else
		needsShape = true;

	// more than two lines, or two lines with overlap
	if (needsShape) {
		// set up
		top = (int) (firstGlyph.GetGlyph()->GetY() + yOutset);
		int upperMid = (int) (top + yOutset + firstFont->Ascent() + firstFont->Descent());
		int lowerMid = (int) (lastGlyph.GetGlyph()->GetY() - yOutset);
		bottom = (int) (lastGlyph.GetGlyph()->GetY() +
			lastFont->Ascent() + lastFont->Descent() + yOutset);
		farLeft = -xOutset;
		farRight = leafBlock->Width() + xOutset;
		// top-left corner
		shape.MoveTo(startX, top + yRadius);
		shape.VerticalCornerTo(startX + xRadius, top);
		// line to top-right
		shape.LineTo(farRight - xRadius, top);
		// top-right corner
		shape.HorizontalCornerTo(farRight, top + yRadius);
		// line to mid-far-right corner
		shape.LineTo(farRight, lowerMid - yRadius);
		// get to mid-mid-right corner
		if (farRight - endX < xRadius * 2) {
			// farRight and endX are too close together for the normal
			// method; draw mid-far-right corner without a connecting line
			shape.VerticalCornerTo((endX + farRight) / 2, lowerMid);
			}
		else {
			// mid-far-right corner
			shape.VerticalCornerTo(farRight - xRadius, lowerMid);
			// line to mid-mid-right corner
			shape.LineTo(endX + xRadius, lowerMid);
			}
		// mid-mid-right corner
		shape.HorizontalCornerTo(endX, lowerMid + yRadius);
		// line to bottom-right corner
		shape.LineTo(endX, bottom - yRadius);
		// bottom-right corner
		shape.VerticalCornerTo(endX - xRadius, bottom);
		// line to bottom-left corner
		shape.LineTo(farLeft + xRadius, bottom);
		// bottom-left corner
		shape.HorizontalCornerTo(farLeft, bottom - yRadius);
		// get to the top-left corner
		if (startX == farLeft) {
			// no wiggling to get there--just draw a line to top-left corner
			shape.LineTo(farLeft, top + yRadius);
			}
		else {
			// line to mid-far-left corner
			shape.LineTo(farLeft, upperMid + yRadius);
			// get to mid-mid-left corner
			if (startX - farLeft < xRadius * 2) {
				// startX is too close to farLeft, so draw the corners without
				// a connecting line
				shape.VerticalCornerTo((startX + farLeft) / 2, upperMid);
				}
			else {
				// mid-far-left corner
				shape.VerticalCornerTo(farLeft + xRadius, upperMid);
				// line to mid-mid-left corner
				shape.LineTo(startX - xRadius, upperMid);
				}
			// mid-mid-left corner
			shape.HorizontalCornerTo(startX, upperMid - yRadius);
			// line back to start at top-left corner
			shape.LineTo(startX, top + yRadius);
			}
		// draw
		shape.Close();
		view->MovePenTo(origin);
		view->StrokeShape(&shape);
		}

	// clean up drawing
	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	BlockableDisplayNode* leafBlock = firstGlyph.GetTextNode()->EnclosingLeafBlock();
	Font* lastFont = lastGlyph.GetTextNode()->CurFont();

	// all on one line
	if (firstGlyph.GetGlyph()->GetLine() == lastGlyph.GetGlyph()->GetLine()) {
		float endX = lastGlyph.GetGlyph()->GetX() + lastGlyph.GetGlyph()->Width(lastFont);
		Rectangle boundsRect(firstGlyph.GetGlyph()->GetX() - lineSpill,
		                     firstGlyph.GetGlyph()->GetY() - lineSpill,
		                     endX + lineSpill,
		                     lastGlyph.GetGlyph()->GetY() + lastFont->Ascent() + lastFont->Descent() + lineSpill);
		boundsRect.InsetBy(-xOutset, -yOutset);
		boundsRect.OffsetBy(leafBlock->LeftSpace(), leafBlock->Top());
		return boundsRect;
		}

	// more than one line
	else {
		Rectangle boundsRect(0, firstGlyph.GetGlyph()->GetY(),
		                    leafBlock->Width(),
		                    lastGlyph.GetGlyph()->GetY() + lastFont->Ascent() + lastFont->Descent());
		boundsRect.InsetBy(-(xOutset + lineSpill), -(yOutset + lineSpill));
		boundsRect.OffsetBy(leafBlock->LeftSpace(), leafBlock->Top());
		return boundsRect;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	int yOrigin = firstGlyph.GetTextNode()->EnclosingLeafBlock()->Top();
	Font* firstFont = firstGlyph.GetTextNode()->CurFont();
	int firstY = firstGlyph.GetGlyph()->GetY() + firstFont->Ascent() + yOrigin;
	int lastY = lastGlyph.GetGlyph()->GetY() + yOrigin;
	return (lastY >= pageRect.top && firstY <= pageRect.bottom);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ContainsPoint(CoordPoint point)
{
	int startX, endX;

	BlockableDisplayNode* leafBlock = firstGlyph.GetTextNode()->EnclosingLeafBlock();
	Font* firstFont = firstGlyph.GetTextNode()->CurFont();
	Font* lastFont = lastGlyph.GetTextNode()->CurFont();
	point.x -= leafBlock->LeftSpace();	// convert to paragraph coords
	point.y -= leafBlock->Top();

	// check if it's at all within range
	if (point.y < firstGlyph.GetGlyph()->GetY())
		return false;
	if (point.y > lastGlyph.GetGlyph()->GetY() + lastFont->Ascent() + lastFont->Descent())
		return false;

	// all on one line
	int firstLine = firstGlyph.GetGlyph()->GetLine();
	int lastLine = lastGlyph.GetGlyph()->GetLine();
	if (firstLine == lastLine) {
		startX = firstGlyph.GetGlyph()->GetX() - xOutset;
		endX = lastGlyph.GetGlyph()->GetX() + lastGlyph.GetGlyph()->Width(lastFont) + xOutset;
		return (point.x >= startX && point.x < endX);
		}

	// check if it's in the first line
	else if (point.y < firstGlyph.GetGlyph()->GetY() + firstFont->LineHeight()) {
		startX = firstGlyph.GetGlyph()->GetX() - xOutset;
		return (point.x >= startX);
		}

	// check if it's in the last line
	else if (point.y > lastGlyph.GetGlyph()->GetY()) {
		endX = lastGlyph.GetGlyph()->GetX() + lastGlyph.GetGlyph()->Width(lastFont) + xOutset;
		return (point.x < endX);
		}

	// otherwise, it's somewhere within the selection
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DragStartPoint(CoordPoint destPoint)
{
	BlockableDisplayNode* leafBlock = firstGlyph.GetTextNode()->EnclosingLeafBlock();
	Font* lastFont = lastGlyph.GetTextNode()->CurFont();
	CoordPoint blockOrigin(leafBlock->LeftSpace(), leafBlock->Top());
	int top = firstGlyph.GetGlyph()->GetY();
	bool oneLine = (firstGlyph.GetGlyph()->GetLine() == lastGlyph.GetGlyph()->GetLine());
	if (destPoint.y < top + blockOrigin.y) {
		// above the selection
		int lastX =
			oneLine ?
			lastGlyph.GetGlyph()->GetX() + lastGlyph.GetGlyph()->Width(lastFont) :
			leafBlock->Width();
		return CoordPoint((firstGlyph.GetGlyph()->GetX() + lastX) / 2, top - yOutset) + blockOrigin;
		}
	else {
		// below the selection (or on the same line)
		int firstX = (oneLine ? firstGlyph.GetGlyph()->GetX() : 0);
		int lastX = lastGlyph.GetGlyph()->GetX() + lastGlyph.GetGlyph()->Width(lastFont);
		return CoordPoint((firstX + lastX) / 2,
		                  lastGlyph.GetGlyph()->GetY() + lastFont->Ascent() + lastFont->Descent())
		       	+ blockOrigin;
		}
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:22:54 PST"><![CDATA[
Rectangle TagSpecRect()
{
	Rectangle specRect;

	int firstLine = firstGlyph.glyph->GetLine();
	int lastLine = lastGlyph.glyph->GetLine();
	if (firstLine == lastLine) {
		Rectangle bounds = Bounds();
		specRect.Set(bounds.left + tagXInset, 0,
		             bounds.right - tagXInset, bounds.top + tagYInset);
		}
	else {
		BlockableDisplayNode* leafBlock = firstGlyph.textNode->EnclosingLeafBlock();
		int left = firstGlyph.glyph->GetX() - xOutset - lineSpill + leafBlock->LeftSpace();
		int top = (int) (firstGlyph.glyph->GetY() - yOutset - lineSpill + leafBlock->Top());
		int right = leafBlock->Width();
		specRect.Set(left + tagXInset, 0, right - tagXInset, top + tagYInset);
		}

	return specRect;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef firstGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef lastGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Color color;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineWidth = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xOutset  = 2;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float yOutset = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float xCornerLength = 0.4;		// as a fraction of the glyph width
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float yCornerLength = 0.5;		// as a fraction of the glyph height
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int minCornerRadius = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagXInset = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagYInset = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Calcs"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineSpill = lineWidth - 1;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GlyphLoc
</name>
<hIncludes><![CDATA[
#include "GlyphRef.h"
#include "CoordPoint.h"

// comparison object for Glyph locations
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Glyph.h"
#include "TextDisplayNode.h"
#include "Font.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphLoc(GlyphRef glyphRefIn)
	: glyphRef(glyphRefIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool operator<(CoordPoint point)
{
	if (glyphRef.GetGlyph()->GetY() > point.y)
		return false;
	Font* font = glyphRef.GetTextNode()->CurFont();
	if (glyphRef.GetGlyph()->GetY() + font->LineHeight() < point.y)
		return true;
	return (glyphRef.GetGlyph()->GetX() + glyphRef.GetGlyph()->Width(font) < point.x);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool operator>(CoordPoint point)
{
	if (glyphRef.GetGlyph()->GetY() > point.y)
		return true;
	Font* font = glyphRef.GetTextNode()->CurFont();
	if (glyphRef.GetGlyph()->GetY() + font->LineHeight() < point.y)
		return false;
	return (glyphRef.GetGlyph()->GetX() > point.x);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool operator <=(CoordPoint point)
{
	return !(*this > point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool operator >=(CoordPoint point)
{
	return !(*this < point);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphRef glyphRef;
]]></variable>

</class>


<class mod-time="Sat, 03 Jun 2000 23:25:15 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InlineElementSelection
</name>
<superclasses>
public TagSelection
</superclasses>
<hIncludes><![CDATA[
#include "TagSelection.h"
#include "GlyphRef.h"

class ElementDisplayNode;
class GlyphsHilite;
class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "TextDisplayNode.h"
#include "GlyphsHilite.h"
#include "TagEditor.h"
#include "Element.h"
#include "Text.h"
#include "RestoreInlineElementSelectionAction.h"
#include "CompositeAction.h"
#include "RemoveNodesAction.h"
#include "NewTextAction.h"
#include "AddCharsAction.h"
#include "MoveNodesAction.h"
#include "ChangeElementTagNameAction.h"
#include "RestoreSelectionAction.h"
#include "DisplayDirector.h"
#include "WindowDirector.h"
#include "GlyphLoc.h"
#include "GlyphsSelection.h"
#include "XMLStringWriter.h"
#include "View.h"
#include "Keys.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InlineElementSelection(ElementDisplayNode* displayNodeIn)
	: displayNode(displayNodeIn)
{
	hilite = new GlyphsHilite(displayNode->FirstSelectableGlyph(),
	                          displayNode->LastSelectableGlyph());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~InlineElementSelection()
{
	delete hilite;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* GetElement()
{
	return displayNode->GetElement();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode* GetDisplayNode()
{
	return displayNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	// create the tagEditor if there isn't one yet
	// we'd do this in the ctor, except stupid C++ can't call derived virtual
	//		functions from the ctor
	if (tagEditor == NULL)
		ShowTag(displayNode->GetDisplayDirector());

	if (tagEditor) {
		tagEditor->Draw(view->Bounds());
		hilite->Draw(view, origin, tagEditor->Bounds());
		}
	else
		hilite->Draw(view, origin);
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:23:16 PDT"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	CompositeAction* action;
	Element* element;

	// handle keys for the tagEditor
	if ((tagEditor && tagEditor->IsSelected()) || key == "\t")
		TagSelection::AcceptKey(key, director);

	else if (key == "\n") {
		/***/
		}
	else if (key == "\b" || key == Keys::DelKey) {
		// delete the whole element
		element = displayNode->GetElement();
		action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		action->AddAction(new RemoveNodesAction(element, element));
		//*** need to select, but don't really have a selection for it yet...
		//*** kinda want a deleter, like GlyphsMover, to handle surrounding
		//*** space
		director->DoAction(action);
		}
	else if (key == Keys::RightArrowKey) {
		director->SetSelection(displayNode->EndSelection());
		director->ScrollToSelection();
		}
	else if (key == Keys::LeftArrowKey) {
		director->SetSelection(displayNode->StartSelection());
		director->ScrollToSelection();
		}
	else {
		// replace the contents of the element
		ReplaceContents(key, director);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	// get the nearest enclosing selection
	Selection* newSelection = NULL;
	for (DisplayNode* node = displayNode->Parent(); node; node = node->Parent()) {
		newSelection = node->GetSelection();
		if (newSelection)
			break;
		}

	// select
	if (newSelection)
		director->SetSelection(newSelection);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* ExtendTo(CoordPoint point)
{
	if (hilite->ContainsPoint(point))
		return this;

	// convert point to leaf-block coords
	BlockableDisplayNode* leafBlock = displayNode->EnclosingLeafBlock();
	point.y -= leafBlock->Top();
	point.x -= leafBlock->LeftSpace();

	DisplayNode* rawNode;
	TextDisplayNode* textNode;
	Glyph* foundGlyph;
	GlyphRef firstGlyph = displayNode->FirstSelectableGlyph();
	GlyphRef lastGlyph = displayNode->LastSelectableGlyph();
	GlyphRef newFirstGlyph = firstGlyph;
	GlyphRef newLastGlyph = lastGlyph;

	// before current selection
	if (GlyphLoc(firstGlyph) > point) {
		// work backwards until we find it
		for (rawNode = displayNode; rawNode; rawNode = rawNode->PreviousSibling()) {
			InlineableDisplayNode* node = dynamic_cast<InlineableDisplayNode*>(rawNode);
			if (node == NULL)
				throw InternalException("GlyphsSelection::ExtendTo: Sibling is not inline.");

			// figure out whether to look in this node
			if (!node->CanSelectAcross())
				break;
			GlyphRef nodesFirstGlyph = node->FirstSelectableGlyph();
			if (!nodesFirstGlyph.IsValid())
				continue;	// it doesn't show up on the display
			if (GlyphLoc(node->LastSelectableGlyph()) < point)
				break;
			if (GlyphLoc(nodesFirstGlyph) >= point) {
				newFirstGlyph = nodesFirstGlyph;
				continue;
				}

			// we've now found the node to look into; check if it's a TextDisplayNode
			textNode = dynamic_cast<TextDisplayNode*>(node);
			if (textNode == NULL) {
				// probly an element; select from its beginning
				newFirstGlyph = nodesFirstGlyph;
				break;
				}

			// it *is* a TextDisplayNode; find out which glyph to use
			foundGlyph = textNode->GlyphAtPoint(point);
			if (foundGlyph)
				newFirstGlyph.Set(textNode, foundGlyph);
			break;
			}
		}

	// after current selection
	else {
		// work forwards until we find it
		for (rawNode = displayNode; rawNode; rawNode = rawNode->NextSibling()) {
			InlineableDisplayNode* node = dynamic_cast<InlineableDisplayNode*>(rawNode);
			if (node == NULL)
				throw InternalException("GlyphsSelection::ExtendTo: Sibling is not inline.");

			// figure out whether to look in this node
			if (!node->CanSelectAcross())
				break;
			GlyphRef nodesLastGlyph = node->LastSelectableGlyph();
			if (!nodesLastGlyph.IsValid())
				continue;
			if (GlyphLoc(node->FirstSelectableGlyph()) > point)
				break;
			if (GlyphLoc(nodesLastGlyph) <= point) {
				newLastGlyph = nodesLastGlyph;
				continue;
				}

			// we've now found the node to look into; check if it's a TextDisplayNode
			textNode = dynamic_cast<TextDisplayNode*>(node);
			if (textNode == NULL) {
				// probly an element; select to its end
				newLastGlyph = nodesLastGlyph;
				break;
				}

			// it *is* a TextDisplayNode; find out which glyph to use
			foundGlyph = textNode->GlyphAtPoint(point);
			if (foundGlyph)
				newLastGlyph.Set(textNode, foundGlyph);
			break;
			}
		}

	// return the new selection
	return GlyphsSelection::SelectionFromTo(newFirstGlyph, newLastGlyph);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	return new RestoreInlineElementSelectionAction();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	return hilite->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	return hilite->IsVisible(pageRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsClip()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DragStartPoint(CoordPoint destPoint)
{
	return hilite->DragStartPoint(destPoint);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanCopy()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetXMLCopy()
{
	XMLStringWriter writer(displayNode->GetElement());
	writer.Write();
	return writer.GetString();
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:24:34 PDT"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:24:31 PDT"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	ReplaceContents(pasteText, director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"TagSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return displayNode->GetElement()->TagName();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle TagSpecRect()
{
	return hilite->TagSpecRect();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagNameChanged(DOMString newTagName, DisplayDirector* director)
{
	HideTag(director);	// this is going away; prevent surprises in TagEditDone()
	Element* element = displayNode->GetElement();
	if (element->TagName() == newTagName || newTagName.empty())
		return;
	ChangeElementTagNameAction* changeTagAction =
		new ChangeElementTagNameAction(element, newTagName);
	director->DoAction(new RestoreSelectionAction(changeTagAction));
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:22:26 PDT"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:25:15 PDT"><![CDATA[
void ReplaceContents(String newContents, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());

	// get rid of current contents
	Element* element = displayNode->GetElement();
	if (element->HasChildNodes())
		action->AddAction(new RemoveNodesAction(element->FirstChild(), element->LastChild()));

	// add the new contents
	NewTextAction* newTextAction = new NewTextAction(element->OwnerDocument());
	action->AddAction(newTextAction);
	Text* newText = newTextAction->GetText();
	action->AddAction(new MoveNodesAction(newText, newText, element, NULL));
	action->AddAction(new AddCharsAction(newContents, newText, 0));

	director->DoAction(action);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode* displayNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsHilite* hilite;
]]></variable>

</class>


<class mod-time="Wed, 12 Apr 2000 20:32:14 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BlocksSelection
</name>
<superclasses>
public Selection
</superclasses>
<hIncludes><![CDATA[
#include "Selection.h"

class BlockableDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlockableDisplayNode.h"
#include "CompositeAction.h"
#include "RestoreSelectionAction.h"
#include "RemoveNodesAction.h"
#include "NewTextAction.h"
#include "AddCharsAction.h"
#include "MoveNodesAction.h"
#include "SelectBetweenBlocksAction.h"
#include "RestoreBlocksSelectionAction.h"
#include "ElementDisplayNode.h"
#include "Element.h"
#include "Text.h"
#include "DisplayDirector.h"
#include "XMLStringWriter.h"
#include "View.h"
#include "Shape.h"
#include "Keys.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlocksSelection(BlockableDisplayNode* firstNodeIn, BlockableDisplayNode* lastNodeIn)
	: firstNode(firstNodeIn), lastNode(lastNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	// set up drawing
	view->PushState();
	view->SetPenSize(lineWidth);
	view->SetHighColor(Selection::selectionColor);
	view->SetDrawingMode(AlphaDrawingMode);

	// draw
	Rectangle rect = Bounds();
	rect.InsetBy(lineSpill, lineSpill);
	Shape shape;
	shape.MoveTo(rect.left, rect.top + cornerRadius);
	shape.VerticalCornerTo(rect.left + cornerRadius, rect.top);
	shape.LineTo(rect.right - cornerRadius, rect.top);
	shape.HorizontalCornerTo(rect.right, rect.top + cornerRadius);
	shape.LineTo(rect.right, rect.bottom - cornerRadius);
	shape.VerticalCornerTo(rect.right - cornerRadius, rect.bottom);
	shape.LineTo(rect.left + cornerRadius, rect.bottom);
	shape.HorizontalCornerTo(rect.left, rect.bottom - cornerRadius);
	shape.Close();
	view->MovePenTo(origin);
	view->StrokeShape(&shape);

	// clean up drawing
	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 12 Apr 2000 20:32:14 PDT"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	CompositeAction* action;

	ElementDisplayNode* firstElementNode = dynamic_cast<ElementDisplayNode*>(firstNode);
	if (firstNode == NULL)
		throw InternalException("BlocksSelection::AcceptKey: first node isn't an Element.");
	ElementDisplayNode* lastElementNode = dynamic_cast<ElementDisplayNode*>(lastNode);
	if (lastNode == NULL)
		throw InternalException("BlocksSelection::AcceptKey: last node isn't an Element.");

	if (key == "\t") {
		//*** don't do anything yet: we're not a TagSelection.
		}
	else if (key == "\b" || key == Keys::DelKey) {
		// delete the blocks
		action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		action->AddAction(new RemoveNodesAction(firstElementNode->GetElement(),
		                                        lastElementNode->GetElement()));
		// select
		ElementDisplayNode* parentElementNode =
			dynamic_cast<ElementDisplayNode*>(firstNode->Parent());
		Element* parentElement = (parentElementNode ? parentElementNode->GetElement() : NULL);
		ElementDisplayNode* nextElementNode =
			dynamic_cast<ElementDisplayNode*>(lastNode->NextSibling());
		Element* nextElement = (nextElementNode ? nextElementNode->GetElement() : NULL);
		if (parentElement)
			action->AddAction(new SelectBetweenBlocksAction(parentElement, nextElement));
		director->DoAction(action);
		}
	else if (key == Keys::LeftArrowKey) {
		director->SetSelection(firstNode->StartSelection());
		director->ScrollToSelection();
		}
	else if (key == Keys::RightArrowKey) {
		director->SetSelection(lastNode->EndSelection());
		director->ScrollToSelection();
		}
	else {
		// replace the first block with typed text
		action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		if (firstNode != lastNode) {
			// need to remove all but the first Element
			ElementDisplayNode* secondElementNode =
				dynamic_cast<ElementDisplayNode*>(firstNode->NextSibling());
			if (secondElementNode == NULL)
				throw InternalException("BlocksSelection::AcceptKey: second node isn't an Element.");
			action->AddAction(new RemoveNodesAction(secondElementNode->GetElement(),
			                                        lastElementNode->GetElement()));
			}
		// get rid of contents of the first element
		Element* element = firstElementNode->GetElement();
		action->AddAction(new RemoveNodesAction(element->FirstChild(), element->LastChild()));
		// add a new Text
		NewTextAction* newTextAction = new NewTextAction(element->OwnerDocument());
		action->AddAction(newTextAction);
		Text* newText = newTextAction->GetText();
		action->AddAction(new MoveNodesAction(newText, newText, element, NULL));
		action->AddAction(new AddCharsAction(key, newText, 0));
		director->DoAction(action);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	// firstNode and lastNode must be siblings, so just select the nearest
	// selectable ancestor
	for (DisplayNode* node = firstNode->Parent(); node; node = node->Parent()) {
		Selection* newSelection = node->GetSelection();
		if (newSelection) {
			director->SetSelection(newSelection);
			return;
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* ExtendTo(CoordPoint point)
{
	DisplayNode* parent = firstNode->Parent();
	if (parent == NULL)
		return this;

	// before current selection
	DisplayNode* node;
	BlockableDisplayNode* block;
	if (point.y < firstNode->Top()) {
		for (node = parent->FirstChild(); ; node = node->NextSibling()) {
			block = dynamic_cast<BlockableDisplayNode*>(node);
			if (block == NULL)
				throw InternalException("BlocksSelection::ExtendTo: some sibling is not a block!");

			// if we've reached "firstNode", we've got the current selection
			if (block == firstNode)
				return this;
			// if the point is after the current DisplayNode, keep looking
			if (point.y > block->Top() + block->Height())
				continue;

			// the new selection starts with this DisplayNode
			return new BlocksSelection(block, lastNode);
			}
		}

	// after current selection
	else if (point.y > lastNode->Top() + lastNode->Height()) {
		for (node = parent->LastChild(); ; node = node->PreviousSibling()) {
			block = dynamic_cast<BlockableDisplayNode*>(node);
			if (block == NULL)
				throw InternalException("BlocksSelection::ExtendTo: some sibling is not a block!");

			// if we've reached "lastNode", we've got the current selection
			if (block == lastNode)
				return this;
			// if the point is before the current DisplayNode, keep looking
			if (point.y < block->Top())
				continue;

			// the new selection ends with this DisplayNode
			return new BlocksSelection(firstNode, block);
			}
		}

	// in current selection
	else
		return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	ElementDisplayNode* firstElementNode =
		dynamic_cast<ElementDisplayNode*>(firstNode);
	if (firstElementNode == NULL)
		throw InternalException("BlocksSelection::GetRestoreAction: firstNode wasn't an ElementDisplayNode.");
	ElementDisplayNode* lastElementNode =
		dynamic_cast<ElementDisplayNode*>(lastNode);
	if (lastElementNode == NULL)
		throw InternalException("BlocksSelection::GetRestoreAction: lastNode wasn't an ElementDisplayNode.");

	return new RestoreBlocksSelectionAction(firstElementNode->GetElement(),
	                                        lastElementNode->GetElement());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	Rectangle bounds;
	bounds.top = firstNode->Top();
	bounds.bottom = lastNode->Top() + lastNode->Height();

	bounds.left = firstNode->DisplayLeft();
	bounds.right = bounds.left + firstNode->DisplayWidth();
	if (firstNode != lastNode) {
		for (DisplayNode* node = firstNode->NextSibling(); node; node = node->NextSibling()) {
			BlockableDisplayNode* block = dynamic_cast<BlockableDisplayNode*>(node);
			if (block == NULL)
				throw InternalException("BlocksSelection::Bounds: some node wasn't a block!");

			int left = block->DisplayLeft();
			if (left < bounds.left)
				bounds.left = left;
			int right = left + block->DisplayWidth();
			if (right > bounds.right)
				bounds.right = right;

			if (block == lastNode)
				break;
			}
		}

	bounds.InsetBy(-(xOutset + lineSpill), -(yOutset + lineSpill));
	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	return pageRect.Intersects(Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsClip()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DragStartPoint(CoordPoint destPoint)
{
	Rectangle bounds = Bounds();
	return CoordPoint(bounds.left, (bounds.top + bounds.bottom) / 2);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanCopy()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetXMLCopy()
{
	ElementDisplayNode* firstElementNode =
		dynamic_cast<ElementDisplayNode*>(firstNode);
	if (firstElementNode == NULL)
		throw InternalException("BlocksSelection::GetXMLCopy: firstNode wasn't an ElementDisplayNode.");
	ElementDisplayNode* lastElementNode =
		dynamic_cast<ElementDisplayNode*>(lastNode);
	if (lastElementNode == NULL)
		throw InternalException("BlocksSelection::GetXMLCopy: lastNode wasn't an ElementDisplayNode.");

	XMLStringWriter writer(NULL);
	Node* node = firstElementNode->GetElement();
	Node* lastNode = lastElementNode->GetElement();
	for (; node; node = node->NextSibling()) {
		writer.AppendNode(node);
		if (node == lastNode)
			break;
		}
	return writer.GetString();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Properties"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* FirstNode()
{
	return firstNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* LastNode()
{
	return lastNode;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* firstNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* lastNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineWidth = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xOutset = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yOutset = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int cornerRadius = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Calcs"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineSpill = lineWidth - 1;
]]></variable>

</class>


<class mod-time="Sat, 03 Jun 2000 23:19:03 PDT" wind-frame="138.000000,106.000000,778.000000,636.000000" list-views-height="0.000000">
<name>
BlockElementSelection
</name>
<superclasses>
public TagSelection
</superclasses>
<hIncludes><![CDATA[
#include "TagSelection.h"

class ElementDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "Element.h"
#include "Text.h"
#include "CompositeAction.h"
#include "RemoveNodesAction.h"
#include "MoveNodesAction.h"
#include "NewTextAction.h"
#include "AddCharsAction.h"
#include "ChangeElementTagNameAction.h"
#include "SelectBetweenBlocksAction.h"
#include "RestoreSelectionAction.h"
#include "RestoreBlockElementSelectionAction.h"
#include "BlocksSelection.h"
#include "TagEditor.h"
#include "XMLStringWriter.h"
#include "Shape.h"
#include "View.h"
#include "Keys.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockElementSelection(ElementDisplayNode* displayNodeIn)
	: displayNode(displayNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Properties"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode* GetDisplayNode()
{
	return displayNode;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	// create the tagEditor if there isn't one yet
	// we'd do this in the ctor, except stupid C++ can't call derived virtual
	//		functions from the ctor
	if (tagEditor == NULL)
		ShowTag(displayNode->GetDisplayDirector());

	// set up drawing
	view->PushState();
	view->SetPenSize(lineWidth);
	view->SetHighColor(Selection::selectionColor);
	view->SetDrawingMode(AlphaDrawingMode);

	// clip out the tagEditor
	if (tagEditor) {
		Rectangle allRect(0, 0, 32767, 32767);
		Region clipRegion;
		clipRegion.Set(allRect);
		Rectangle tagBounds = tagEditor->Bounds();
		tagBounds.OffsetBy(origin);
		clipRegion.Exclude(tagBounds);
		view->ConstrainClippingRegion(&clipRegion);
		}

	// draw
	Rectangle rect = HiliteBounds();
	rect.InsetBy(lineSpill, lineSpill);
	Shape shape;
	shape.MoveTo(rect.left, rect.top + cornerRadius);
	shape.VerticalCornerTo(rect.left + cornerRadius, rect.top);
	shape.LineTo(rect.right - cornerRadius, rect.top);
	shape.HorizontalCornerTo(rect.right, rect.top + cornerRadius);
	shape.LineTo(rect.right, rect.bottom - cornerRadius);
	shape.VerticalCornerTo(rect.right - cornerRadius, rect.bottom);
	shape.LineTo(rect.left + cornerRadius, rect.bottom);
	shape.HorizontalCornerTo(rect.left, rect.bottom - cornerRadius);
	shape.Close();
	view->MovePenTo(origin);
	view->StrokeShape(&shape);

	// clean up drawing
	view->PopState();

	// draw the tagEditor
	if (tagEditor)
		tagEditor->Draw(view->Bounds());
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:18:37 PDT"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	CompositeAction* action;
	Element* element;

	// handle keys for the tagEditor
	if ((tagEditor && tagEditor->IsSelected()) || key == "\t")
		TagSelection::AcceptKey(key, director);

	// deletion
	else if (key == "\b" || key == Keys::DelKey) {
		// delete the blocks
		action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		element = displayNode->GetElement();
		action->AddAction(new RemoveNodesAction(element, element));
		// select
		ElementDisplayNode* parentElementNode =
			dynamic_cast<ElementDisplayNode*>(displayNode->Parent());
		Element* parentElement = (parentElementNode ? parentElementNode->GetElement() : NULL);
		ElementDisplayNode* nextElementNode =
			dynamic_cast<ElementDisplayNode*>(displayNode->NextSibling());
		Element* nextElement = (nextElementNode ? nextElementNode->GetElement() : NULL);
		if (parentElement)
			action->AddAction(new SelectBetweenBlocksAction(parentElement, nextElement));
		director->DoAction(action);
		}

	else if (key == Keys::LeftArrowKey) {
		director->SetSelection(displayNode->StartSelection());
		director->ScrollToSelection();
		}
	else if (key == Keys::RightArrowKey) {
		director->SetSelection(displayNode->EndSelection());
		director->ScrollToSelection();
		}

	else {
		// replace the contents with typed text
		ReplaceContents(key, director);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	// select the nearest selectable ancestor
	for (DisplayNode* node = displayNode->Parent(); node; node = node->Parent()) {
		Selection* newSelection = node->GetSelection();
		if (newSelection) {
			director->SetSelection(newSelection);
			return;
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* ExtendTo(CoordPoint point)
{
	DisplayNode* parent = displayNode->Parent();
	if (parent == NULL)
		return this;

	// before current selection
	DisplayNode* node;
	BlockableDisplayNode* block;
	if (point.y < displayNode->Top()) {
		for (node = parent->FirstChild(); ; node = node->NextSibling()) {
			block = dynamic_cast<BlockableDisplayNode*>(node);
			if (block == NULL)
				throw InternalException("BlockElementSelection::ExtendTo: some sibling is not a block!");

			// if we've reached "displayNode", we've got the current selection
			if (block == displayNode)
				return this;
			// if the point is after the current DisplayNode, keep looking
			if (point.y > block->Top() + block->Height())
				continue;

			// the new selection starts with this DisplayNode
			return new BlocksSelection(block, displayNode);
			}
		}

	// after current selection
	else if (point.y > displayNode->Top() + displayNode->Height()) {
		for (node = parent->LastChild(); ; node = node->PreviousSibling()) {
			block = dynamic_cast<BlockableDisplayNode*>(node);
			if (block == NULL)
				throw InternalException("BlockElementSelection::ExtendTo: some sibling is not a block!");

			// if we've reached "displayNode", we've got the current selection
			if (block == displayNode)
				return this;
			// if the point is before the current DisplayNode, keep looking
			if (point.y < block->Top())
				continue;

			// the new selection ends with this DisplayNode
			return new BlocksSelection(displayNode, block);
			}
		}

	// in current selection
	else
		return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	return new RestoreBlockElementSelectionAction(displayNode->GetElement());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	Rectangle bounds = HiliteBounds();
	if (tagEditor)
		bounds = bounds | tagEditor->Bounds();

	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	return pageRect.Intersects(Bounds());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsClip()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DragStartPoint(CoordPoint destPoint)
{
	Rectangle bounds = Bounds();
	return CoordPoint(bounds.left, (bounds.top + bounds.bottom) / 2);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanCopy()
{
	return true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString GetXMLCopy()
{
	XMLStringWriter writer(displayNode->GetElement());
	writer.Write();
	return writer.GetString();
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:18:46 PDT"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:19:03 PDT"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	ReplaceContents(pasteText, director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"TagSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return displayNode->GetElement()->TagName();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle TagSpecRect()
{
	Rectangle bounds = HiliteBounds();
	return Rectangle(bounds.left + tagXInset, 0, bounds.right - tagXInset,
	                 bounds.top + tagYInset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagNameChanged(DOMString newTagName, DisplayDirector* director)
{
	HideTag(director);	// so it won't cause trouble when the selection changes
	Element* element = displayNode->GetElement();
	if (element->TagName() == newTagName || newTagName.empty())
		return;
	ChangeElementTagNameAction* changeTagAction =
		new ChangeElementTagNameAction(element, newTagName);
	director->DoAction(new RestoreSelectionAction(changeTagAction));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle HiliteBounds()
{
	Rectangle bounds;
	bounds.top = displayNode->Top();
	bounds.bottom = bounds.top + displayNode->Height();
	bounds.left = displayNode->DisplayLeft();
	bounds.right = bounds.left + displayNode->DisplayWidth();
	bounds.InsetBy(-(xOutset + lineSpill), -(yOutset + lineSpill));
	return bounds;
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:16:42 PDT"><![CDATA[
void ReplaceContents(String newContents, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());

	// get rid of the contents of the element
	Element* element = displayNode->GetElement();
	if (element->HasChildNodes())
		action->AddAction(new RemoveNodesAction(element->FirstChild(), element->LastChild()));

	// add a new Text
	NewTextAction* newTextAction = new NewTextAction(element->OwnerDocument());
	action->AddAction(newTextAction);
	Text* newText = newTextAction->GetText();
	action->AddAction(new MoveNodesAction(newText, newText, element, NULL));
	action->AddAction(new AddCharsAction(newContents, newText, 0));

	director->DoAction(action);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode* displayNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineWidth = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xOutset = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yOutset = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int cornerRadius = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagXInset = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagYInset = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Calcs"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineSpill = lineWidth - 1;
]]></variable>

</class>


<class mod-time="Sat, 03 Jun 2000 23:35:35 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BetweenBlocksSelection
</name>
<superclasses>
public TagSelection
</superclasses>
<hIncludes><![CDATA[
#include "TagSelection.h"

class BlockableDisplayNode;
class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlockableDisplayNode.h"
#include "ElementDisplayNode.h"
#include "GeneratedLeafBlock.h"
#include "Element.h"
#include "Text.h"
#include "CompositeAction.h"
#include "NewElementAction.h"
#include "NewTextAction.h"
#include "MoveNodesAction.h"
#include "AddCharsAction.h"
#include "RestoreSelectionAction.h"
#include "RestoreBetweenBlocksSelectionAction.h"
#include "TagEditor.h"
#include "DisplayDirector.h"
#include "View.h"
#include "Keys.h"
#include <typeinfo>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BetweenBlocksSelection(BlockableDisplayNode* parentNodeIn,
                       BlockableDisplayNode* beforeNodeIn)
	: parentNode(parentNodeIn), beforeNode(beforeNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Selection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	view->PushState();
	view->SetPenSize(caretLineWidth);
	view->SetHighColor(selectionColor);

	CoordPoint point = Point() + origin;
	view->StrokeLine(point, CoordPoint(point.x - caretWidth, point.y - caretHeight));
	view->StrokeLine(point, CoordPoint(point.x - caretWidth, point.y + caretHeight));

	if (tagEditor) {
		Rectangle tagBounds = tagEditor->Bounds();
		view->SetPenSize(1);
		view->StrokeLine(point, CoordPoint(tagBounds.left + origin.x, point.y));
		tagEditor->Draw(view->Bounds());
		}

	view->PopState();
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:32:39 PDT"><![CDATA[
void AcceptKey(string_slice key, DisplayDirector* director)
{
	if (TagIsSelected() || key == "\t")
		TagSelection::AcceptKey(key, director);
	else if (key == "\b" || key == Keys::DelKey || key == "\n") {
		// do nothing
		}
	else if (key == Keys::LeftArrowKey) {
		SelectBackward(director);
		}
	else if (key == Keys::RightArrowKey) {
		SelectForward(director);
		}
	else {
		// create a new Element
		InsertText(key, director);
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	CoordPoint point = Point();
	const int lineSpill = caretLineWidth - 1;
	Rectangle bounds(point.x - caretWidth - lineSpill, point.y - caretHeight - lineSpill,
	                 point.x + lineSpill, point.y + caretHeight + lineSpill);
	if (tagEditor)
		bounds = bounds | tagEditor->Bounds();
	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsVisible(Rectangle pageRect)
{
	return pageRect.Contains(Point());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool NeedsClip()
{
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Promote(DisplayDirector* director)
{
	director->SetSelection(parentNode->GetSelection());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* ExtendTo(CoordPoint point)
{
	/***/
	return this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetRestoreAction()
{
	return new RestoreBetweenBlocksSelectionAction(DocParentNode(), DocBeforeNode());
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:34:03 PDT"><![CDATA[
bool CanPaste()
{
	return true;
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:34:09 PDT"><![CDATA[
void Paste(String pasteText, DisplayDirector* director)
{
	InsertText(pasteText, director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"TagSelection virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return "";
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:26:39 PST"><![CDATA[
Rectangle TagSpecRect()
{
	CoordPoint point = Point();
	int tagX = (int) (point.x + tagXOffset);
	return Rectangle(tagX, 0, tagX, point.y + tagYOffset);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagNameChanged(DOMString newTagName, DisplayDirector* director)
{
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	action->AddAction(new NewElementAction(newTagName, DocParentNode(), DocBeforeNode()));
	director->DoAction(action);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void TagEditDone(DisplayDirector* director)
{
	HideTag(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint Point()
{
	BlockableDisplayNode* afterNode = dynamic_cast<BlockableDisplayNode*>(
			beforeNode ? beforeNode->PreviousSibling() : parentNode->LastChild()
		);
	int x, y;
	if (afterNode && beforeNode) {
		// x is min of the two blocks' left edges
		x = afterNode->DisplayLeft();
		int beforeX = beforeNode->DisplayLeft();
		if (beforeX < x)
			x = beforeX;
		// y is between them
		y = (afterNode->Bottom() + beforeNode->Top()) / 2;
		}
	else if (afterNode) {
		x = afterNode->DisplayLeft();
		y = afterNode->Bottom();
		}
	else if (beforeNode) {
		x = beforeNode->DisplayLeft();
		y = beforeNode->Top();
		}
	else {
		// probably never happens; may need to be changed if it does
		x = parentNode->DisplayLeft();
		y = parentNode->Top();
		}
	return CoordPoint(x, y);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* DocParentNode()
{
	Node* parent = parentNode->FirstNode();
	if (typeid(*parentNode) == typeid(GeneratedLeafBlock))
		parent = parent->ParentNode();
	return parent;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* DocBeforeNode()
{
	return (beforeNode ? beforeNode->FirstNode() : NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectForward(DisplayDirector* director)
{
	Selection* selection = NULL;

	// find the selection
	DisplayNode* node = (beforeNode ? beforeNode : parentNode->NextNodeInDoc());
	while (node) {
		selection = node->StartSelection();
		if (selection)
			break;
		node = node->NextNodeInDoc();
		}

	if (selection)
		director->SetSelection(selection);
	director->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SelectBackward(DisplayDirector* director)
{
	Selection* selection = NULL;

	// find the selection
	DisplayNode* node = (beforeNode ? beforeNode->PrevNodeInDoc() : parentNode->LastChild());
	while (node) {
		selection = node->EndSelection();
		if (selection)
			break;
		node = node->PrevNodeInDoc();
		}

	if (selection)
		director->SetSelection(selection);
	director->ScrollToSelection();
}
]]></method>

<method access="public" mod-time="Sat, 03 Jun 2000 23:35:35 PDT"><![CDATA[
void InsertText(String newContents, DisplayDirector* director)
{
	// figure out what kind of element to insert
	DisplayNode* protoNode = NULL;
	if (beforeNode) {
		DisplayNode* afterNode = beforeNode->PreviousSibling();
		if (afterNode)
			protoNode = afterNode;
		}
	else
		protoNode = parentNode->LastChild();
	ElementDisplayNode* protoElementNode = dynamic_cast<ElementDisplayNode*>(protoNode);

	// other info
	ElementDisplayNode* parentElementNode =
		dynamic_cast<ElementDisplayNode*>(parentNode);
	ElementDisplayNode* beforeElementNode =
		dynamic_cast<ElementDisplayNode*>(beforeNode);

	// do it
	if (protoElementNode && parentElementNode && (beforeElementNode || beforeNode == NULL)) {
		Element* parentElement = parentElementNode->GetElement();
		CompositeAction* action = new CompositeAction();
		action->AddAction(new RestoreSelectionAction());
		NewElementAction* newElementAction =
			new NewElementAction(protoElementNode->GetElement()->TagName(),
			                     parentElement,
			                     beforeElementNode->GetElement());
		action->AddAction(newElementAction);
		NewTextAction* newTextAction = new NewTextAction(parentElement->OwnerDocument());
		action->AddAction(newTextAction);
		Text* newText = newTextAction->GetText();
		action->AddAction(new MoveNodesAction(newText, newText,
		                                      newElementAction->GetNewElement(),
		                                      NULL));
		action->AddAction(new AddCharsAction(newContents, newText, 0));
		director->DoAction(action);
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* parentNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* beforeNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int caretWidth = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int caretHeight = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int caretLineWidth = 2;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagXOffset = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int tagYOffset = 8;
]]></variable>

</class>


<class mod-time="Thu, 20 Apr 2000 00:42:39 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TagEditor
</name>
<superclasses>
public DisplayDirector
</superclasses>
<hIncludes><![CDATA[
#include "DisplayDirector.h"
#include "DOMString.h"
#include "Color.h"

class WindowDirector;
class TagSelection;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "TagSelection.h"
#include "TagDocumentSource.h"
#include "Document.h"
#include "Element.h"
#include "Text.h"
#include "Selection.h"
#include "BlockDrawContext.h"
#include "DocumentDisplayNode.h"
#include "TextDisplayNode.h"
#include "CompositeStylesheet.h"
#include "DefaultValidator.h"
#include "BetweenGlyphsSelection.h"
#include "GlyphsSelection.h"
#include "View.h"
#include "Shape.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:27:42 PST"><![CDATA[
TagEditor(DOMString tagName, TagSelection* ownerIn, WindowDirector* windowDirectorIn)
	: DisplayDirector(NULL),		// docSource will be set up below
	  windowDirector(windowDirectorIn), owner(ownerIn)
{
	// create docSource
	docSource = new TagDocumentSource(tagName);

	// create the stylesheet
	Element* docElement = docSource->GetDocument()->DocumentElement();
	stylesheet = new CompositeStylesheet(docElement->TagName());
	validator = new DefaultValidator(this);

	SetupDisplayNodes();

/***
	// set the selection
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(DisplayNodeFor(docElement->FirstChild()));
	if (displayNode == NULL)
		throw InternalException("TagEditor ctor: Can't get TextDisplayNode to select.");
	if (tagName.empty())
		SetSelection(new BetweenGlyphsSelection(displayNode, NULL, NULL, false));
	else {
		SetSelection(new GlyphsSelection(displayNode->FirstSelectableGlyph(), displayNode->LastSelectableGlyph()));
		}
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TagEditor()
{
	delete validator;
	delete stylesheet;
	delete docSource;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Select()
{
	Element* docElement = docSource->GetDocument()->DocumentElement();
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(DisplayNodeFor(docElement->FirstChild()));
	if (displayNode == NULL)
		throw InternalException("TagEditor ctor: Can't get TextDisplayNode to select.");
	if (TagName().empty())
		SetSelection(new BetweenGlyphsSelection(displayNode, NULL, NULL, false));
	else {
		SetSelection(new GlyphsSelection(displayNode->FirstSelectableGlyph(),
		                                 displayNode->LastSelectableGlyph()));
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Deselect()
{
	SetSelection(NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsSelected()
{
	return (selection != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetTagName(DOMString newTagName)
{
	TagDocumentSource* tagSource = dynamic_cast<TagDocumentSource*>(docSource);
	if (useAssertions && tagSource == NULL)
		throw InternalException("TagEditor::RestoreTagName: docSource isn't a TagDocumentSource!");
	tagSource->SetTagName(newTagName);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DisplayDirector virtuals"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:28:22 PST"><![CDATA[
void Draw(Rectangle updateRect)
{
	View* drawView = DrawingView();
	drawView->PushState();

	// make the outline shape
	Rectangle bounds = Bounds();
	Rectangle outlineRect = bounds;
	int lineSpill = (lineWidth + 1) / 2;
	lineSpill -= 1;		//*** fudge factor?
	outlineRect.InsetBy(lineSpill, lineSpill);
	Shape shape;
	shape.MoveTo(outlineRect.left, outlineRect.top + cornerRadius);
	shape.VerticalCornerTo(outlineRect.left + cornerRadius, outlineRect.top);
	shape.LineTo(outlineRect.right - cornerRadius, outlineRect.top);
	shape.HorizontalCornerTo(outlineRect.right, outlineRect.top + cornerRadius);
	shape.LineTo(outlineRect.right, outlineRect.bottom - cornerRadius);
	shape.VerticalCornerTo(outlineRect.right - cornerRadius, outlineRect.bottom);
	shape.LineTo(outlineRect.left + cornerRadius, outlineRect.bottom);
	shape.HorizontalCornerTo(outlineRect.left, outlineRect.bottom - cornerRadius);
	shape.LineTo(outlineRect.left, outlineRect.top + cornerRadius);
	shape.Close();

	// clear and draw the outline
	CoordPoint origin = windowDirector->DocToView(CoordPoint(0, 0));
	Color bgndAlphaColor = bgndColor;
	bgndAlphaColor.alpha = bgndAlpha;
	drawView->MovePenTo(origin);
	drawView->SetDrawingMode(AlphaDrawingMode);
	drawView->SetHighColor(bgndAlphaColor);
	drawView->FillShape(&shape);
	drawView->SetPenSize(lineWidth);
	drawView->SetHighColor(selection ? selectedColor : Selection::selectionColor);
	drawView->StrokeShape(&shape);

	// draw the document
	static const Color blackColor = { 0, 0, 0, 255 };
	drawView->SetHighColor(blackColor);
	drawView->SetDrawingMode(CopyDrawingMode);
	int hOrigin = (int) (origin.x + bounds.left + lineWidth + xOutset);
	int vOrigin = (int) (origin.y + bounds.top + lineWidth + yOutset);
	BlockDrawContext
		drawContext(this, drawView, hOrigin, vOrigin,
		            0, docDisplayNode->Height());
	docDisplayNode->BlockDraw(&drawContext);

	// draw selection
	if (selection /*** && selection->IsVisible(pageRect) ***/) {
/***
		bool needsClip = selection->NeedsClip();
		if (needsClip) {
			bitmapView->PushState();
			Rectangle clipRect = DocToView(pageRect);
			clipRect.left = view->Bounds().left;
			clipRect.right = view->Bounds().right;
			Region clipRgn;
			clipRgn.Include(clipRect);
			bitmapView->ConstrainClippingRegion(&clipRgn);
			}
***/

		selection->Draw(drawView, DocToView(CoordPoint(0, 0)));

/***
		if (needsClip)
			bitmapView->PopState();
***/
		}

	drawView->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KeyDown(string_slice key)
{
	if (selection) {
		StartRefreshCycle();
		selection->AcceptKey(key, this);
		FinishRefreshCycle();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved()
{
	// nothing to do
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ScreenChanged()
{
	// nothing to do
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* GetStylesheet()
{
	return stylesheet;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Validator* GetValidator()
{
	return validator;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int DisplayWidth()
{
	return windowDirector->DisplayWidth() - 2 * xOutset - 2 * lineWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* DrawingView()
{
	return windowDirector->DrawingView();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* WindowView()
{
	return windowDirector->WindowView();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint ViewToDoc(CoordPoint viewPoint)
{
	Rectangle bounds = Bounds();
	CoordPoint origin(bounds.left + lineWidth + xOutset,
	                  bounds.top + lineWidth + yOutset);
	return viewPoint - windowDirector->DocToView(origin);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint DocToView(CoordPoint docPoint)
{
	Rectangle bounds = Bounds();
	CoordPoint origin(bounds.left + lineWidth + xOutset,
	                  bounds.top + lineWidth + yOutset);
	return docPoint + windowDirector->DocToView(origin);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ViewToDoc(Rectangle rect)
{
	Rectangle bounds = Bounds();
	CoordPoint origin(bounds.left + lineWidth + xOutset,
	                  bounds.top + lineWidth + yOutset);
	origin = windowDirector->DocToView(origin);
	rect.OffsetBy(-origin.x, -origin.y);
	return rect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle DocToView(Rectangle rect)
{
	Rectangle bounds = Bounds();
	CoordPoint origin(bounds.left + lineWidth + xOutset,
	                  bounds.top + lineWidth + yOutset);
	origin = windowDirector->DocToView(origin);
	rect.OffsetBy(origin);
	return rect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle DocRect()
{
	Rectangle docRect = Bounds();
	docRect.InsetBy(lineWidth + xOutset, lineWidth + yOutset);
	return windowDirector->DocToView(docRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StartRefreshCycle()
{
	windowDirector->StartRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishRefreshCycle()
{
	windowDirector->FinishRefreshCycle();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshViewRect(Rectangle rect)
{
	windowDirector->RefreshViewRect(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void RefreshDocAfter(int y)
{
	Rectangle rect = Bounds();
	rect.InsetBy(lineWidth + xOutset, lineWidth + yOutset);
	rect.top += y;
	windowDirector->RefreshViewRect(rect);
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:42:39 PDT"><![CDATA[
void RefreshAll()
{
	windowDirector->RefreshAll();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DocTypeChanged()
{
	// never happens
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	// first try to get the optimal requested bounds
	Rectangle specRect = owner->TagSpecRect();
	Rectangle bounds;
	bounds.left = specRect.left;
	int width = docDisplayNode->MaxLineWidth();
/***
	if (width < minWidth)
		width = minWidth;
***/
	if (width == 0)
		width = emptyWidth;
	bounds.right = bounds.left + width + 2 * lineWidth + 2 * xOutset;
	bounds.bottom = specRect.bottom;
	bounds.top = bounds.bottom - docDisplayNode->Height() -
	             2 * lineWidth - 2 * yOutset;

	// if it spills over the right edge, slip it back
	int maxRight = windowDirector->DisplayWidth();
	if (bounds.right > maxRight)
		bounds.OffsetBy(maxRight - bounds.right, 0);

	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	Text* tagText =
		dynamic_cast<Text*>(docSource->GetDocument()->DocumentElement()->FirstChild());
	if (useAssertions && tagText == NULL)
		throw InternalException("TagEditor::TagName: Couldn't get tag name.");
	return tagText->Data();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* windowDirector;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TagSelection* owner;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* stylesheet;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Validator* validator;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineWidth = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xOutset = 2;	// was 8
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yOutset = -1;	// was 2
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int cornerRadius = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int emptyWidth = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color bgndColor = { 255, 255, 255, 0 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static int bgndAlpha = 192;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color selectedColor = Selection::selectionColor;
	// purple: 220, 0, 255
	// darker blue: 0, 108, 192
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:03:52 PDT" wind-frame="95.000000,109.000000,735.000000,639.000000" list-views-height="0.000000">
<name>
TagDocumentSource
</name>
<superclasses>
public DocumentSource
</superclasses>
<hIncludes><![CDATA[
#include "DocumentSource.h"
#include "DOMString.h"

class Text;

]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Element.h"
#include "Text.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TagDocumentSource(DOMString tagName)
{
	InitStatics();

	// build the document
	document = new Document();
	Element* tagElement = document->CreateElement("tag-name");
	document->AppendChild(tagElement);
	tagText = document->CreateTextNode(tagName);
	tagElement->AppendChild(tagText);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~TagDocumentSource()
{
	delete document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"DocumentSource virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* GetDocument()
{
	return document;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetWindowTitle()
{
	return "#tag-name";
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Save()
{
	// nothing to do
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Properties"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString TagName()
{
	return tagText->Data();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetTagName(DOMString tagName)
{
	tagText->SetData(tagName);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void InitStatics()
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Document* document;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* tagText;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Destinations"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 17:03:55 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Destination
</name>
<hIncludes><![CDATA[
#include "Rectangle.h"
#include "CoordPoint.h"
#include "Color.h"

class Selection;
class View;
class Action;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Destination(Selection* selectionIn)
	: selection(selectionIn)
{
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:03:55 PST"><![CDATA[
virtual ~Destination()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle ArrowBounds() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void DrawArrow(View* view, CoordPoint origin) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Action* GetMoveAction() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Action* GetCopyAction() = 0;
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* selection;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const Color arrowColor = { 0, 0xBB, 255, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float arrowheadWidth = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float arrowheadHeight = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float arrowLineWidth = 3;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SpaceDestination
</name>
<superclasses>
public Destination
</superclasses>
<hIncludes><![CDATA[
#include "Destination.h"

class TextDisplayNode;
class Space;
class InlineArrow;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Space.h"
#include "Text.h"
#include "InlineArrow.h"
#include "BlockableDisplayNode.h"
#include "Selection.h"
#include "GlyphsSelection.h"
#include "InlineElementSelection.h"
#include "GlyphsMover.h"
#include "MoveCharsAction.h"
#include "Font.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SpaceDestination(Selection* selectionIn, TextDisplayNode* textNodeIn, Space* spaceIn)
	: Destination(selectionIn), textNode(textNodeIn), space(spaceIn)
{
	BlockableDisplayNode* leafBlock = textNode->EnclosingLeafBlock();
	if (leafBlock == NULL)
		throw InternalException("SpaceDestination ctor: textNode has no enclosing leaf block.");
	Font* font = textNode->CurFont();

	CoordPoint destPoint(leafBlock->LeftSpace(), leafBlock->Top());
	destPoint.x += space->GetX() + space->Width(font) / 2;
	destPoint.y += space->GetY() + font->Ascent();
	Rectangle sourceBounds = selection->Bounds();
	bool above = (destPoint.y < (sourceBounds.top + sourceBounds.bottom) / 2);
	arrow = new InlineArrow(selection->DragStartPoint(destPoint), destPoint,
	                        above, font->Ascent());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~SpaceDestination()
{
	delete arrow;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Destination virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ArrowBounds()
{
	return arrow->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawArrow(View* view, CoordPoint origin)
{
	arrow->Draw(view, origin);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetMoveAction()
{
	return MakeMoveAction(false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetCopyAction()
{
	return MakeMoveAction(true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* MakeMoveAction(bool copying)
{
	InlineElementSelection* elementSource;
	GlyphsSelection* glyphsSource = dynamic_cast<GlyphsSelection*>(selection);
	if (glyphsSource) {
		GlyphsMover mover(glyphsSource->FirstGlyph(), glyphsSource->LastGlyph(),
		                  GlyphRef(textNode, textNode->GlyphBefore(space)),
		                  GlyphRef(textNode, space),
		                  GlyphRef(textNode, textNode->GlyphAfter(space)),
		                  copying);
		return mover.MakeAction();
		}
	else if ((elementSource = dynamic_cast<InlineElementSelection*>(selection)) != NULL) {
		GlyphsMover mover(elementSource->GetDisplayNode(),
		                  GlyphRef(textNode, textNode->GlyphBefore(space)),
		                  GlyphRef(textNode, space),
		                  GlyphRef(textNode, textNode->GlyphAfter(space)),
		                  copying);
		return mover.MakeAction();
		}
	else
		throw InternalException("SpaceDestination::MakeMoveAction: Invalid selection type.");

	return NULL;	// will never happen, but keep the compiler happy
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextDisplayNode* textNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Space* space;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InlineArrow* arrow;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BetweenGlyphsDestination
</name>
<superclasses>
public Destination
</superclasses>
<hIncludes><![CDATA[
#include "Destination.h"

class TextDisplayNode;
class Glyph;
class InlineArrow;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Glyph.h"
#include "Text.h"
#include "Element.h"
#include "InlineArrow.h"
#include "BlockableDisplayNode.h"
#include "ElementDisplayNode.h"
#include "Selection.h"
#include "GlyphsSelection.h"
#include "InlineElementSelection.h"
#include "GlyphsMover.h"
#include "Font.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BetweenGlyphsDestination(Selection* selectionIn, TextDisplayNode* textNodeIn,
                         Glyph* firstGlyphIn, Glyph* secondGlyphIn)
	: Destination(selectionIn), textNode(textNodeIn),
	  firstGlyph(firstGlyphIn), secondGlyph(secondGlyphIn)
{
	BlockableDisplayNode* leafBlock = textNode->EnclosingLeafBlock();
	if (leafBlock == NULL)
		throw InternalException("SpaceDestination ctor: textNode has no enclosing leaf block.");
	Font* font = textNode->CurFont();

	CoordPoint destPoint(leafBlock->LeftSpace(), leafBlock->Top());
	if (firstGlyph) {
		destPoint.x += firstGlyph->GetX() + firstGlyph->Width(font);
		destPoint.y += firstGlyph->GetY() + font->Ascent();
		}
	else {
		destPoint.x += secondGlyph->GetX();
		destPoint.y += secondGlyph->GetY() + font->Ascent();
		}
	Rectangle sourceBounds = selection->Bounds();
	bool above = (destPoint.y < (sourceBounds.top + sourceBounds.bottom) / 2);
	arrow = new InlineArrow(selection->DragStartPoint(destPoint), destPoint,
	                        above, font->Ascent());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~BetweenGlyphsDestination()
{
	delete arrow;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Destination virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ArrowBounds()
{
	return arrow->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawArrow(View* view, CoordPoint origin)
{
	arrow->Draw(view, origin);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetMoveAction()
{
	return MakeMoveAction(false);
/***
	GlyphsSelection* source = dynamic_cast<GlyphsSelection*>(selection);
	if (source == NULL)
		throw InternalException("BetweenGlyphsDestination::GetMoveAction: Source is not a GlyphsSelection.");
	GlyphsMover mover(source->FirstGlyph(), source->LastGlyph(),
	                  GlyphRef(textNode, firstGlyph), GlyphRef(),
	                  GlyphRef(textNode, secondGlyph),
	                  false);
	return mover.MakeAction();
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetCopyAction()
{
	return MakeMoveAction(true);
/***
	GlyphsSelection* source = dynamic_cast<GlyphsSelection*>(selection);
	if (source == NULL)
		throw InternalException("BetweenGlyphsDestination::GetCopyAction: Source is not a GlyphsSelection.");
	GlyphsMover mover(source->FirstGlyph(), source->LastGlyph(),
	                  GlyphRef(textNode, firstGlyph), GlyphRef(),
	                  GlyphRef(textNode, secondGlyph),
	                  true);
	return mover.MakeAction();
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* MakeMoveAction(bool copying)
{
	InlineElementSelection* elementSource;
	GlyphsSelection* glyphsSource = dynamic_cast<GlyphsSelection*>(selection);
	if (glyphsSource) {
		GlyphsMover mover(glyphsSource->FirstGlyph(), glyphsSource->LastGlyph(),
		                  GlyphRef(textNode, firstGlyph), GlyphRef(),
	                      GlyphRef(textNode, secondGlyph),
		                  copying);
		return mover.MakeAction();
		}
	else if ((elementSource = dynamic_cast<InlineElementSelection*>(selection)) != NULL) {
		GlyphsMover mover(elementSource->GetDisplayNode(),
		                  GlyphRef(textNode, firstGlyph), GlyphRef(),
	                      GlyphRef(textNode, secondGlyph),
		                  copying);
		return mover.MakeAction();
		}
	else
		throw InternalException("BetweenGlyphsDestination::MakeMoveAction: Invalid selection type.");

	return NULL;	// will never happen, but keep the compiler happy
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextDisplayNode* textNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* firstGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Glyph* secondGlyph;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InlineArrow* arrow;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:40:56 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InlineArrow
</name>
<hIncludes><![CDATA[
#include "CoordPoint.h"
#include "Rectangle.h"
#include "Color.h"

class View;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InlineArrow(CoordPoint fromPointIn, CoordPoint toPointIn, bool above, int ascent)
	: fromPoint(fromPointIn), toPoint(toPointIn)
{
	if (above) {
		// above selection
		if (toPoint.y >= fromPoint.y - loopZone) {
			// need to loop
			loops = true;
			arrowPointsDown = true;
			toPoint.y -= ceil(ascent / 2);
			}
		else {
			loops = false;
			arrowPointsDown = false;
			}
		}
	else {
		// below selection
		if (toPoint.y <= fromPoint.y + loopZone) {
			loops = true;
			arrowPointsDown = false;
			}
		else {
			loops = false;
			arrowPointsDown = true;
			toPoint.y -= ceil(ascent / 2);
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:40:56 PST"><![CDATA[
Rectangle Bounds()
{
	int left = (int) (fromPoint.x - lineSlop);
	int arrowLeft = (int) (toPoint.x - arrowheadWidth / 2 - lineSlop);
	if (arrowLeft < left)
		left = arrowLeft;

	int right = (int) (fromPoint.x + lineSlop);
	int arrowRight = (int) (toPoint.x + arrowheadWidth / 2 + lineSlop);
	if (arrowRight > right)
		right = arrowRight;

	int top = (int) (fromPoint.y - lineSlop);
	if (loops && arrowPointsDown)
		top = (int) (toPoint.y - loopHeight - lineSlop);
	else {
		int arrowTop = (int) (toPoint.y - lineSlop);
		if (arrowPointsDown)
			arrowTop -= arrowheadHeight;
		if (arrowTop < top)
			top = arrowTop;
		}

	int bottom = (int) (fromPoint.y + lineSlop);
	if (loops && !arrowPointsDown)
		bottom = (int) (toPoint.y + loopHeight + lineSlop);
	else {
		float arrowBottom = toPoint.y + lineSlop;
		if (!arrowPointsDown)
			arrowBottom += arrowheadHeight;
		if (arrowBottom > bottom)
			bottom = (int) arrowBottom;
		}

	return Rectangle(left, top, right, bottom);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	view->PushState();
	view->SetPenSize(arrowLineWidth);
	view->SetHighColor(arrowColor);

	// line
	BPoint points[4];
	if (loops) {
		CoordPoint center((fromPoint.x + toPoint.x) / 2,
		                  toPoint.y + (arrowPointsDown ? -loopHeight : loopHeight));
		points[0] = fromPoint + origin;
		points[1] = CoordPoint(fromPoint.x, center.y) + origin;
		points[2] = points[1];
		points[3] = center + origin;
		view->StrokeBezier(points);
		points[0] = center + origin;
		points[1] = CoordPoint(toPoint.x, center.y) + origin;
		points[2] = points[1];
		points[3] = toPoint + origin;
		view->StrokeBezier(points);
		}
	else {
		points[0] = fromPoint + origin;
		points[1] = CoordPoint(fromPoint.x, (fromPoint.y + toPoint.y) / 2) + origin;
		points[2] = CoordPoint(toPoint.x, fromPoint.y) + origin;
		points[3] = toPoint + origin;
		view->StrokeBezier(points);
		}

	// arrowhead
	float xOffset = arrowheadWidth / 2;
	if (arrowPointsDown) {
		// arrow points down
		float arrowTop = toPoint.y - arrowheadHeight;
		view->StrokeLine(toPoint + origin,
		                 CoordPoint(toPoint.x - xOffset, arrowTop) + origin);
		view->StrokeLine(toPoint + origin,
		                 CoordPoint(toPoint.x + xOffset, arrowTop) + origin);
		}
	else {
		// arrow points up
		float arrowBottom = toPoint.y + arrowheadHeight;
		view->StrokeLine(toPoint + origin,
		                 CoordPoint(toPoint.x - xOffset, arrowBottom) + origin);
		view->StrokeLine(toPoint + origin,
		                 CoordPoint(toPoint.x + xOffset, arrowBottom) + origin);
		}

	view->PopState();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint fromPoint;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint toPoint;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool loops;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool arrowPointsDown;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const Color arrowColor = { 0, 0xBB, 255, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowheadWidth = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowheadHeight = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowLineWidth = 2;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int loopZone = 24;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int loopHeight = 16;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Calcs"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineSlop = arrowLineWidth / 2;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:39:38 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BetweenBlocksDestination
</name>
<superclasses>
public Destination
</superclasses>
<hIncludes><![CDATA[
#include "Destination.h"
#include "CoordPoint.h"

class BlockableDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "BlocksSelection.h"
#include "BlockElementSelection.h"
#include "Element.h"
#include "CompositeAction.h"
#include "RestoreSelectionAction.h"
#include "MoveNodesAction.h"
#include "CopyNodesAction.h"
#include "SelectBlockElementsAction.h"
#include "View.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BetweenBlocksDestination(Selection* selectionIn, BlockableDisplayNode* parentIn,
                         BlockableDisplayNode* afterNodeIn)
	: Destination(selectionIn), parent(parentIn), afterNode(afterNodeIn)
{
	// calculate the destination point
	toPoint.x = parent->LeftSpace();
	if (afterNode) {
		int prevBottom = afterNode->Bottom();
		BlockableDisplayNode* nextNode =
			dynamic_cast<BlockableDisplayNode*>(afterNode->NextSibling());
		if (nextNode)
			toPoint.y = (prevBottom + nextNode->Top()) / 2;
		else
			toPoint.y = prevBottom;
		}
	else
		toPoint.y = parent->Top();

	fromPoint = selection->DragStartPoint(toPoint);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Destination virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle ArrowBounds()
{
	Rectangle bounds;

	bounds.left = fromPoint.x - arrowLoopWidth - lineSlop;
	float toLeft = toPoint.x - arrowStem - arrowLoopWidth - lineSlop;
	if (toLeft < bounds.left)
		bounds.left = toLeft;

	bounds.right = fromPoint.x + lineSlop;
	float toRight = toPoint.x + lineSlop;
	if (toRight > bounds.right)
		bounds.right = toRight;

	bounds.top = fromPoint.y - lineSlop;
	float toTop = toPoint.y - arrowheadHeight / 2 - lineSlop;
	if (toTop < bounds.top)
		bounds.top = toTop;

	bounds.bottom = fromPoint.y + lineSlop;
	float toBottom = toPoint.y + arrowheadHeight / 2 + lineSlop;
	if (toBottom > bounds.bottom)
		bounds.bottom = toBottom;

	return bounds;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:39:26 PST"><![CDATA[
void DrawArrow(View* view, CoordPoint origin)
{
	view->PushState();
	view->SetPenSize(arrowLineWidth);
	view->SetHighColor(arrowColor);

	// line
	const int loopWidth = arrowLoopWidth - arrowStem;
	CoordPoint loopTo(toPoint.x - arrowStem, toPoint.y);
	CoordPoint midPoint((fromPoint.x + loopTo.x) / 2 - loopWidth,
	                    (fromPoint.y + loopTo.y) / 2);
	CoordPoint points[4];
	points[0] = fromPoint + origin;
	points[1] = CoordPoint(fromPoint.x - loopWidth, fromPoint.y) + origin;
	points[2] = points[3] = midPoint + origin;
	view->StrokeBezier(points);
	points[0] = points[1] = midPoint + origin;
	points[2] = CoordPoint(loopTo.x - loopWidth, loopTo.y) + origin;
	points[3] = loopTo + origin;
	view->StrokeBezier(points);
	view->StrokeLine(loopTo + origin, toPoint + origin);

	// arrowhead
	int arrowheadLeft = (int) (toPoint.x - arrowheadWidth);
	view->StrokeLine(toPoint + origin,
	                 CoordPoint(arrowheadLeft, toPoint.y - arrowheadHeight / 2) + origin);
	view->StrokeLine(toPoint + origin,
	                 CoordPoint(arrowheadLeft, toPoint.y + arrowheadHeight / 2) + origin);

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetMoveAction()
{
	return MakeMoveAction(false);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* GetCopyAction()
{
	return MakeMoveAction(true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:39:38 PST"><![CDATA[
Action* MakeMoveAction(bool copying)
{
	// get the source info
	Element* firstElement = NULL;
	Element* lastElement = NULL;
	BlocksSelection* blocksSource = dynamic_cast<BlocksSelection*>(selection);
	if (blocksSource) {
		ElementDisplayNode* firstElementNode =
			dynamic_cast<ElementDisplayNode*>(blocksSource->FirstNode());
		if (useAssertions && firstElementNode == NULL)
			throw InternalException("BetweenBlocksDestination: selection start is not an Element.");
		firstElement = firstElementNode->GetElement();
		ElementDisplayNode* lastElementNode =
			dynamic_cast<ElementDisplayNode*>(blocksSource->LastNode());
		if (useAssertions && lastElementNode == NULL)
			throw InternalException("BetweenBlocksDestination: selection end is not an Element.");
		lastElement = lastElementNode->GetElement();
		}
	else {
		BlockElementSelection* elementSource = dynamic_cast<BlockElementSelection*>(selection);
		ElementDisplayNode* displayNode =
			dynamic_cast<ElementDisplayNode*>(elementSource->GetDisplayNode());
		if (useAssertions && displayNode == NULL)
			throw InternalException("BetweenBlocksDestination: BlockElementSelection has no ElementDisplayNode.");
		firstElement = lastElement = displayNode->GetElement();
		}
	if (useAssertions && firstElement == NULL)
		throw InternalException("BetweenBlocksDestination: unhandled selection type.");

	// get the dest info
	ElementDisplayNode* parentElementNode = dynamic_cast<ElementDisplayNode*>(parent);
	if (parentElementNode == NULL)
		throw InternalException("BetweenBlocksDestination: parent is not an Element");
	Element* parentElement = parentElementNode->GetElement();
	ElementDisplayNode* afterElementNode = dynamic_cast<ElementDisplayNode*>(afterNode);
	if (afterElementNode == NULL && afterNode != NULL)
		throw InternalException("BetweenBlocksDestination: afterNode is not an Element.");
	Node* beforeNode;
	if (afterElementNode)
		beforeNode = afterElementNode->GetElement()->NextSibling();
	else
		beforeNode = parentElement->FirstChild();

	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	Action* moveAction;
	Element* firstSelectionElement;
	Element* lastSelectionElement;
	if (copying) {
		CopyNodesAction* copyAction = new CopyNodesAction(firstElement, lastElement,
		                                                  parentElement, beforeNode);
		moveAction = copyAction;
		firstSelectionElement = dynamic_cast<Element*>(copyAction->FirstNode());
		lastSelectionElement = dynamic_cast<Element*>(copyAction->LastNode());
		}
	else {
		moveAction = new MoveNodesAction(firstElement, lastElement,
		                                 parentElement, beforeNode);
		firstSelectionElement = firstElement;
		lastSelectionElement = lastElement;
		}
	action->AddAction(moveAction);
	action->AddAction(new SelectBlockElementsAction(firstSelectionElement, lastSelectionElement));
	return action;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* parent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockableDisplayNode* afterNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint fromPoint;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint toPoint;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowheadWidth = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowheadHeight = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowLoopWidth = 18;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int arrowStem = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Calcs"
]]></variable>

<variable access="protected" mod-time="Thu, 30 Mar 2000 17:38:46 PST"><![CDATA[
static const int lineSlop = (int) (arrowLineWidth / 2);
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Hotspots"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 17:04:27 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Hotspot
</name>
<hIncludes><![CDATA[
#include "CoordPoint.h"
#include "Rectangle.h"
#include "Color.h"

class View;
class DisplayDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "StyleParser.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Thu, 30 Mar 2000 17:04:17 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:04:27 PST"><![CDATA[
virtual ~Hotspot()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle Bounds() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool ContainsPoint(CoordPoint point) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(View* view, CoordPoint origin) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Clicked(DisplayDirector* director) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FadeDocument(View* view, CoordPoint origin)
{
	// I've decided I don't like this
	return;

	static const Color fadeColor = { 255, 255, 255, 128 };
//***	static const Color fadeColor = { 255, 255, 255, 96 };
		// nicer, but only works at 32-bit

	view->PushState();

	// set up
	Rectangle bounds = Bounds();
	bounds.OffsetBy(origin);
	Rectangle viewBounds = view->Bounds();
	view->SetDrawingMode(AlphaDrawingMode);
	view->SetHighColor(fadeColor);

	// draw the four rectangles
	Rectangle rect = viewBounds;
	rect.bottom = bounds.top;
	view->FillRect(rect);
	rect.top = bounds.top;
	rect.bottom = bounds.bottom;
	rect.right = bounds.left;
	view->FillRect(rect);
	rect.left = bounds.right;
	rect.right = viewBounds.right;
	view->FillRect(rect);
	rect.top = bounds.bottom;
	rect.bottom = viewBounds.bottom;
	rect.left = viewBounds.left;
	view->FillRect(rect);

	view->PopState();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const Color hotspotColor = StyleParser::ParseColor("rgba(255, 130, 0, 128)");
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ElementHotspot
</name>
<superclasses>
public Hotspot
</superclasses>
<hIncludes><![CDATA[
#include "Hotspot.h"

class ElementDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "Element.h"
#include "DisplayDirector.h"
#include "EditStylesheet.h"
#include "System.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementHotspot(ElementDisplayNode* displayNodeIn)
	: displayNode(displayNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Hotspot virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Clicked(DisplayDirector* director)
{
	Element* element = displayNode->GetElement();
	EditStylesheet* stylesheet = director->GetStylesheet();
	DOMString action = stylesheet->PropertyForElement("action", element->TagName());
	action = displayNode->Eval(action);
	if (!action.empty()) {
		if (!action.empty())
			director->DoDocAction(action);
		return;
		}
	DOMString link = stylesheet->PropertyForElement("link", element->TagName());
	if (!link.empty()) {
		// chase down "attr()"
		if (link.startsWith("attr(")) {
			DOMString attrName = link.substr(5, link.length() - 6);
			link = element->GetAttribute(attrName);
			}
		if (!link.empty()) {
			// for now, we only support opening it in the browser
			System::OpenURL(link);
			}
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ElementDisplayNode* displayNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InlineElementHotspot
</name>
<superclasses>
public ElementHotspot
</superclasses>
<hIncludes><![CDATA[
#include "ElementHotspot.h"

class ElementDisplayNode;
class GlyphsHilite;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "GlyphsHilite.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InlineElementHotspot(ElementDisplayNode* displayNodeIn)
	: ElementHotspot(displayNodeIn)
{
	hilite = new GlyphsHilite(displayNode->FirstSelectableGlyph(),
	                          displayNode->LastSelectableGlyph(),
	                          Hotspot::hotspotColor);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~InlineElementHotspot()
{
	delete hilite;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Hotspot virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	return hilite->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ContainsPoint(CoordPoint point)
{
	return hilite->ContainsPoint(point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	// fade the rest of the document
	FadeDocument(view, origin);

	hilite->Draw(view, origin);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsHilite* hilite;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BlockElementHotspot
</name>
<superclasses>
public ElementHotspot
</superclasses>
<hIncludes><![CDATA[
#include "ElementHotspot.h"

class ElementDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "ElementDisplayNode.h"
#include "View.h"
#include "Shape.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockElementHotspot(ElementDisplayNode* displayNodeIn)
	: ElementHotspot(displayNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Hotspot virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	Rectangle bounds;
	bounds.top = displayNode->Top();
	bounds.bottom = bounds.top + displayNode->Height();
	bounds.left = displayNode->LeftSpace();
	bounds.right = bounds.left + displayNode->Width();
	bounds.InsetBy(-(xOutset + lineSpill), -(yOutset + lineSpill));
	return bounds;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ContainsPoint(CoordPoint point)
{
	return Bounds().Contains(point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(View* view, CoordPoint origin)
{
	// fade the rest of the document
	FadeDocument(view, origin);

	// set up drawing
	view->PushState();
	view->SetPenSize(lineWidth);
	view->SetHighColor(Hotspot::hotspotColor);
	view->SetDrawingMode(AlphaDrawingMode);

	// draw
	Rectangle rect = Bounds();
	rect.InsetBy(lineSpill, lineSpill);
	Shape shape;
	shape.MoveTo(rect.left, rect.top + cornerRadius);
	shape.VerticalCornerTo(rect.left + cornerRadius, rect.top);
	shape.LineTo(rect.right - cornerRadius, rect.top);
	shape.HorizontalCornerTo(rect.right, rect.top + cornerRadius);
	shape.LineTo(rect.right, rect.bottom - cornerRadius);
	shape.VerticalCornerTo(rect.right - cornerRadius, rect.bottom);
	shape.LineTo(rect.left + cornerRadius, rect.bottom);
	shape.HorizontalCornerTo(rect.left, rect.bottom - cornerRadius);
	shape.Close();
	view->MovePenTo(origin);
	view->StrokeShape(&shape);

	// clean up drawing
	view->PopState();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineWidth = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xOutset = 4;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yOutset = 0;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int cornerRadius = 8;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Calcs"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineSpill = lineWidth - 1;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Operation Helpers"
</name>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GlyphsMover
</name>
<hIncludes><![CDATA[
#include "TextSpan.h"

class Action;
class Node;
class DisplayNode;
class ElementDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "ElementDisplayNode.h"
#include "Text.h"
#include "Element.h"
#include "Glyph.h"
#include "CompositeAction.h"
#include "SplitTextAction.h"
#include "MoveCharsAction.h"
#include "CopyCharsAction.h"
#include "DeleteCharsAction.h"
#include "InsertSpaceAction.h"
#include "MoveNodesAction.h"
#include "CopyNodesAction.h"
#include "SelectGlyphsAction.h"
#include "RestoreSelectionAction.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsMover(GlyphRef srcFirstGlyph, GlyphRef srcLastGlyph,
            GlyphRef destPreGlyph, GlyphRef destSpaceGlyph, GlyphRef destPostGlyph,
            bool copy)
	: copying(copy), takePreSpace(false), takePostSpace(false),
	  addPreSpace(false), addPostSpace(false), addSrcSpace(false),
	  firstMoveNode(NULL), lastMoveNode(NULL)
{
	// get info about the source structure
	DisplayNode* ancestor = srcFirstGlyph.CommonAncestorWith(srcLastGlyph);
	bool srcStartsWithText = (srcFirstGlyph.textNode->Parent() == ancestor);
	bool srcEndsWithText = (srcLastGlyph.textNode->Parent() == ancestor);
	singleSrcText = (srcFirstGlyph.textNode == srcLastGlyph.textNode);
	hasNodes =
		(!srcStartsWithText || !srcEndsWithText ||
		 srcFirstGlyph.textNode->NextSibling() != srcLastGlyph.textNode);
	if (singleSrcText) {
		srcStartsWithText = true;
		srcEndsWithText = true;
		hasNodes = false;
		}

	// find the pre and post space in the src
	//*** someday make this peek outside the Texts when appropriate
	//*** but watch out: you'll need to use GlyphRefs instead of Glyphs
	Glyph* srcPreGlyph = srcFirstGlyph.textNode->GlyphBefore(srcFirstGlyph.glyph);
	Glyph* srcPreSpaceGlyph = srcPreGlyph;
	bool srcBindsBefore = true;
	if (srcPreSpaceGlyph) {
		if (srcPreSpaceGlyph->IsWhitespace())
			srcBindsBefore = false;
		else
			srcPreSpaceGlyph = NULL;
		}
	bool srcBindsAfter = true;
	Glyph* srcPostGlyph = srcLastGlyph.textNode->GlyphAfter(srcLastGlyph.glyph);
	Glyph* srcPostSpaceGlyph = srcPostGlyph;
	if (srcPostSpaceGlyph) {
		if (srcPostSpaceGlyph->IsWhitespace())
			srcBindsAfter = false;
		else
			srcPostSpaceGlyph = NULL;
		}

	// begin setting up the source
	// src
	if (srcPreSpaceGlyph)
		srcPreSpace.Set(GlyphRef(srcFirstGlyph.textNode, srcPreSpaceGlyph));
	unsigned long srcStartOffset;
	if (singleSrcText) {
		srcStartOffset =
			srcFirstGlyph.textNode->OffsetOfGlyph(srcFirstGlyph.glyph);
		srcFirstText.Set(srcFirstGlyph.textNode->GetText(),
		                 srcStartOffset,
		                 srcLastGlyph.textNode->OffsetOfGlyph(srcLastGlyph.glyph) +
		                 	srcLastGlyph.glyph->NumCharsInText() - srcStartOffset);
		}
	else {
		if (srcStartsWithText) {
			srcStartOffset =
				srcFirstGlyph.textNode->OffsetOfGlyph(srcFirstGlyph.glyph);
			srcFirstText.Set(srcFirstGlyph.textNode->GetText(),
			                 srcStartOffset,
			                 srcFirstGlyph.textNode->GetText()->Length() - srcStartOffset);
			}
		if (srcEndsWithText) {
			unsigned long srcLastOffset =
				srcLastGlyph.textNode->OffsetOfGlyph(srcLastGlyph.glyph) +
				srcLastGlyph.glyph->NumCharsInText();
			srcLastText.Set(srcLastGlyph.textNode->GetText(), 0, srcLastOffset);
			}
		}
	if (srcPostSpaceGlyph)
		srcPostSpace.Set(GlyphRef(srcLastGlyph.textNode, srcPostSpaceGlyph));

	// figure out source binding
	if (copying)
		keepSrcPreSpace = keepSrcPostSpace = true;
	else {
		bool needSrcSpace = true;
		if (srcPreGlyph && srcPreGlyph->ShouldBindAfter())
			needSrcSpace = false;
		if (srcPostGlyph && srcPostGlyph->ShouldBindBefore())
			needSrcSpace = false;
		if (needSrcSpace) {
			if (srcPreSpaceGlyph && srcPostSpaceGlyph) {
				// have both; take whichever is less work
				if (takePostSpace) {
					keepSrcPostSpace = false;
					keepSrcPreSpace = true;
					}
				else {
					keepSrcPreSpace = false;
					keepSrcPostSpace = true;
					}
				}
			else if (srcPreSpaceGlyph) {
				keepSrcPreSpace = true;
				keepSrcPostSpace = false;
				}
			else if (srcPostSpaceGlyph) {
				keepSrcPostSpace = true;
				keepSrcPreSpace = false;
				}
			else
				addSrcSpace = true;
			}
		else
			keepSrcPreSpace = keepSrcPostSpace = false;
		}

/***
	// see if we need source space
	bool needSrcSpace = (!copying && srcBindsBefore && srcBindsAfter &&
	                     srcPreGlyph && srcPostGlyph &&
	                     !srcPreGlyph->ShouldBindAfter() &&
	                     !srcPostGlyph->ShouldBindAfter());
***/

	// merge first & last source texts if we can
	if (srcFirstText.IsJustBefore(srcLastText)) {
		srcFirstText.Append(srcLastText);
		srcLastText.Clear();
		}

	// set up the destination
	ConfigureDest(GlyphRef(srcFirstGlyph.textNode, srcPreSpaceGlyph), srcFirstGlyph,
	              srcLastGlyph, GlyphRef(srcLastGlyph.textNode, srcPostSpaceGlyph),
	              destPreGlyph, destSpaceGlyph, destPostGlyph);

	// move nodes
	if (hasNodes) {
		ElementDisplayNode* ancestorDisplayNode = dynamic_cast<ElementDisplayNode*>(ancestor);
		if (ancestorDisplayNode == NULL)
			throw InternalException("BetweenGlyphsDestination::MoveActionWithElements: ancestor isn't an element.");
		Element* ancestorElement = ancestorDisplayNode->GetElement();
		firstMoveNode = srcFirstGlyph.textNode->GetText();
		while (firstMoveNode->ParentNode() != ancestorElement)
			firstMoveNode = firstMoveNode->ParentNode();
		if (srcStartsWithText)
			firstMoveNode = firstMoveNode->NextSibling();
		lastMoveNode = srcLastGlyph.textNode->GetText();
		while (lastMoveNode->ParentNode() != ancestorElement)
			lastMoveNode = lastMoveNode->ParentNode();
		if (srcEndsWithText)
			lastMoveNode = lastMoveNode->PreviousSibling();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsMover(ElementDisplayNode* displayNode,
            GlyphRef destPreGlyph, GlyphRef destSpaceGlyph, GlyphRef destPostGlyph,
            bool copy)
	: copying(copy), takePreSpace(false), takePostSpace(false),
	  keepSrcPreSpace(true), keepSrcPostSpace(false),
	  addPreSpace(false), addPostSpace(false), addSrcSpace(false),
	  firstMoveNode(NULL), lastMoveNode(NULL)
{
	// get info about the source structure
	singleSrcText = false;
	hasNodes = true;

	//*** someday look for pre- and post-space

	// set up the destination
	ConfigureDest(GlyphRef(), displayNode->FirstSelectableGlyph(),
	              displayNode->LastSelectableGlyph(), GlyphRef(),
	              destPreGlyph, destSpaceGlyph, destPostGlyph);

	// move nodes
	Element* element = displayNode->GetElement();
	firstMoveNode = element;
	lastMoveNode = element;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* MakeAction()
{
	// set up
	CompositeAction* action = new CompositeAction();
	action->AddAction(new RestoreSelectionAction());
	TextSpan selectionStart(destFirstText.text, destFirstText.EndOffset(), 0);
	TextSpan selectionEnd(destLastText.text, destLastText.offset, 0);
	Node* moveBeforeNode = destLastText.text->NextSibling();
	Node* moveDestParentNode = destLastText.text->ParentNode();
	Text* srcText;
	Text* destText;
	unsigned long srcOffset, destOffset, length;

	// first, delete dest space if required
	if (!destDeleteText.IsEmpty()) {
		destText = destDeleteText.text;
		destOffset = destDeleteText.offset;
		length = destDeleteText.length;
		action->AddAction(new DeleteCharsAction(destText, destOffset, length));
		// adjust
		destLastText.AdjustForDelete(destText, destOffset, length);
		selectionEnd.AdjustForDelete(destText, destOffset, length);
		srcPreSpace.AdjustForDelete(destText, destOffset, length);
		srcFirstText.AdjustForDelete(destText, destOffset, length);
		srcLastText.AdjustForDelete(destText, destOffset, length);
		srcPostSpace.AdjustForDelete(destText, destOffset, length);
		}

	// split the destination
	if (!singleSrcText && destFirstText.text == destLastText.text) {
		destText = destFirstText.text;
		unsigned long splitOffset = destFirstText.EndOffset();
		SplitTextAction* splitAction =
			new SplitTextAction(destText, splitOffset);
		action->AddAction(splitAction);
		Text* newText = splitAction->GetNewText();
		moveBeforeNode = newText;
		// adjust
		destLastText.Set(newText, 0, 0);
		selectionEnd.Set(newText, 0, 0);
		if (srcPreSpace.text == destText && srcPreSpace.offset >= splitOffset)
			srcPreSpace.Set(newText, srcPreSpace.offset - splitOffset, srcPreSpace.length);
		if (srcFirstText.text == destText && srcFirstText.offset >= splitOffset)
			srcFirstText.Set(newText, srcFirstText.offset - splitOffset, srcFirstText.length);
		if (srcLastText.text == destText && srcLastText.offset >= splitOffset)
			srcLastText.Set(newText, srcLastText.offset - splitOffset, srcLastText.length);
		if (srcPostSpace.text == destText && srcPostSpace.offset >= splitOffset)
			srcPostSpace.Set(newText, srcPostSpace.offset - splitOffset, srcPostSpace.length);
		}

	// pre-space
	if (takePreSpace) {
		srcText = srcPreSpace.text;
		srcOffset = srcPreSpace.offset;
		destText = destFirstText.text;
		destOffset = destFirstText.EndOffset();
		length = srcPreSpace.length;
		if (keepSrcPreSpace) {
			action->AddAction(new CopyCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));
			}
		else {
			action->AddAction(new MoveCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));

			// adjust for the deletion
			destFirstText.AdjustForDelete(srcText, srcOffset, length);
			destLastText.AdjustForDelete(srcText, srcOffset, length);
			selectionStart.AdjustForDelete(srcText, srcOffset, length);
			selectionEnd.AdjustForDelete(srcText, srcOffset, length);
			srcFirstText.AdjustForDelete(srcText, srcOffset, length);
			srcLastText.AdjustForDelete(srcText, srcOffset, length);
			srcPostSpace.AdjustForDelete(srcText, srcOffset, length);
			if (srcText == destText && srcOffset < destOffset)
				destOffset -= length;
			}

		// adjust for the insertion
		destFirstText.length += length;
		selectionStart.offset += length;
		destLastText.AdjustForInsert(destText, destOffset, length);
		selectionEnd.AdjustForInsert(destText, destOffset, length);
		srcFirstText.AdjustForInsert(destText, destOffset, length);
		srcLastText.AdjustForInsert(destText, destOffset, length);
		srcPostSpace.AdjustForInsert(destText, destOffset, length);
		}
	else if (addPreSpace) {
		destText = destFirstText.text;
		destOffset = destFirstText.EndOffset();
		InsertSpaceAction* preSpaceAction = new InsertSpaceAction(destText, destOffset);
		action->AddAction(preSpaceAction);
		length = preSpaceAction->SpaceLength();
		// adjust for insertion
		destFirstText.length += length;
		selectionStart.offset += length;
		destLastText.AdjustForInsert(destText, destOffset, length);
		selectionEnd.AdjustForInsert(destText, destOffset, length);
		srcFirstText.AdjustForInsert(destText, destOffset, length);
		srcLastText.AdjustForInsert(destText, destOffset, length);
		srcPostSpace.AdjustForInsert(destText, destOffset, length);
		}
	if (!keepSrcPreSpace && !takePreSpace && !srcPreSpace.IsEmpty()) {
		// delete the src pre-space
		srcText = srcPreSpace.text;
		srcOffset = srcPreSpace.offset;
		length = srcPreSpace.length;
		action->AddAction(new DeleteCharsAction(srcText, srcOffset, length));
		// adjust for deletion
		destFirstText.AdjustForDelete(srcText, srcOffset, length);
		destLastText.AdjustForDelete(srcText, srcOffset, length);
		selectionStart.AdjustForDelete(srcText, srcOffset, length);
		selectionEnd.AdjustForDelete(srcText, srcOffset, length);
		srcFirstText.AdjustForDelete(srcText, srcOffset, length);
		srcLastText.AdjustForDelete(srcText, srcOffset, length);
		srcPostSpace.AdjustForDelete(srcText, srcOffset, length);
		}

	// first text
	if (!srcFirstText.IsEmpty()) {
		srcText = srcFirstText.text;
		srcOffset = srcFirstText.offset;
		length = srcFirstText.length;
		destText = destFirstText.text;
		destOffset = destFirstText.EndOffset();
		if (copying) {
			action->AddAction(new CopyCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));
			}
		else {
			action->AddAction(new MoveCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));
			// adjust for the deletion
			srcFirstText.length = 0;
			selectionStart.AdjustForDelete(srcText, srcOffset, length);
			selectionEnd.AdjustForDelete(srcText, srcOffset, length);
			destLastText.AdjustForDelete(srcText, srcOffset, length);
			srcLastText.AdjustForDelete(srcText, srcOffset, length);
			srcPostSpace.AdjustForDelete(srcText, srcOffset, length);
			if (srcText == destText && srcOffset < destOffset)
				destOffset -= length;
			}

		// adjust for the insertion
		selectionEnd.AdjustForInsert(destText, destOffset, length);
		destLastText.AdjustForInsert(destText, destOffset, length);
		srcFirstText.AdjustForInsert(destText, destOffset, length);
		srcLastText.AdjustForInsert(destText, destOffset, length);
		srcPostSpace.AdjustForInsert(destText, destOffset, length);
		}

	// last text
	if (!srcLastText.IsEmpty()) {
		srcText = srcLastText.text;
		srcOffset = srcLastText.offset;
		length = srcLastText.length;
		destText = destLastText.text;
		destOffset = destLastText.offset;
		if (copying) {
			action->AddAction(new CopyCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));
			}
		else {
			action->AddAction(new MoveCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));

			// adjust for delete
			selectionStart.AdjustForDelete(srcText, srcOffset, length);
			selectionEnd.AdjustForDelete(srcText, srcOffset, length);
			srcPostSpace.AdjustForDelete(srcText, srcOffset, length);
			if (srcText == destText && srcOffset < destOffset)
				destOffset -= length;
			}

		// adjust for insertion
		selectionEnd.length += length;
		destLastText.offset += length;
		srcPostSpace.AdjustForInsert(destText, destOffset, length);
		}

	// post space
	if (takePostSpace) {
		srcText = srcPostSpace.text;
		srcOffset = srcPostSpace.offset;
		length = srcPostSpace.length;
		destText = destLastText.text;
		destOffset = destLastText.offset;
		if (keepSrcPostSpace) {
			action->AddAction(new CopyCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));
			}
		else {
			action->AddAction(new MoveCharsAction(srcText, srcOffset, length,
			                                      destText, destOffset));
			selectionStart.AdjustForDelete(srcText, srcOffset, length);
			selectionEnd.AdjustForDelete(srcText, srcOffset, length);
			}
		}
	else if (addPostSpace) {
		action->AddAction(new InsertSpaceAction(destLastText.text, destLastText.offset));
		}
	if (!keepSrcPostSpace && !takePostSpace && !srcPostSpace.IsEmpty()) {
		srcText = srcPostSpace.text;
		srcOffset = srcPostSpace.offset;
		length = srcPostSpace.length;
		action->AddAction(new DeleteCharsAction(srcText, srcOffset, length));
		selectionStart.AdjustForDelete(srcText, srcOffset, length);
		selectionEnd.AdjustForDelete(srcText, srcOffset, length);
		}

	// source space
	if (addSrcSpace) {
		if (srcLastText.IsValid()) {
			srcText = srcLastText.text;
			srcOffset = srcLastText.offset;
			}
		else if (srcFirstText.IsValid()) {
			srcText = srcFirstText.text;
			srcOffset = srcFirstText.EndOffset();
			}
		else
			throw InternalException("GlyphsMover::MakeAction: Sorry, no adding source space where there's no Text yet.");
		InsertSpaceAction* srcSpaceAction = new InsertSpaceAction(srcText, srcOffset);
		action->AddAction(srcSpaceAction);
		length = srcSpaceAction->SpaceLength();
		// adjust for insertion
		selectionStart.AdjustForInsert(srcText, srcOffset, length);
		selectionEnd.AdjustForInsert(srcText, srcOffset, length);
		}

	// move the nodes
	Node* moveFirstDestNode = NULL;
	Node* moveLastDestNode = NULL;
	if (hasNodes) {
		if (copying) {
			CopyNodesAction* copyNodesAction =
				new CopyNodesAction(firstMoveNode, lastMoveNode,
			                        moveDestParentNode,
			                        moveBeforeNode);
			action->AddAction(copyNodesAction);
			moveFirstDestNode = copyNodesAction->FirstNode();
			moveLastDestNode = copyNodesAction->LastNode();
			}
		else {
			action->AddAction(new MoveNodesAction(firstMoveNode, lastMoveNode,
			                                      moveDestParentNode,
			                                      moveBeforeNode));
			moveFirstDestNode = firstMoveNode;
			moveLastDestNode = lastMoveNode;
			}
		}

	// select
	if (!srcFirstText.IsValid()) {
		// no first text; need to select from the beginning of firstMoveNode
		Text* firstText = FirstTextIn(moveFirstDestNode);
		if (useAssertions && firstText == NULL)
			throw InternalException("GlyphsMover::MakeAction: no first text.");
		selectionStart.Set(firstText, 0, firstText->Length());
		}
	if (selectionEnd.EndOffset() == 0) {
		// this is the beginning of the split node; we need to select to the
		// end of lastMoveNode
		Text* lastText = LastTextIn(moveLastDestNode);
		if (useAssertions && lastText == NULL)
			throw InternalException("GlyphsMover::MakeAction: no end text.");
		selectionEnd.Set(lastText, 0, lastText->Length());
		}
	action->AddAction(new SelectGlyphsAction(selectionStart.text, selectionStart.offset,
	                                         selectionEnd.text,
	                                         selectionEnd.EndOffset() - 1));

	return action;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ConfigureDest(GlyphRef srcPreSpaceGlyph, GlyphRef srcFirstGlyph,
                   GlyphRef srcLastGlyph, GlyphRef srcPostSpaceGlyph,
                   GlyphRef destPreGlyph, GlyphRef destSpaceGlyph, GlyphRef destPostGlyph)
{
	// figure out how it should bind
	bool srcBindsBefore = !srcPreSpaceGlyph.IsValid();
	bool bindBefore = srcBindsBefore && srcFirstGlyph.glyph->ShouldBindBefore();
	if (destPreGlyph.IsValid() && destPreGlyph.glyph->ShouldBindAfter())
		bindBefore = true;
	bool srcBindsAfter = !srcPostSpaceGlyph.IsValid();
	bool bindAfter = srcBindsAfter && srcLastGlyph.GetGlyph()->ShouldBindAfter();
	if (destPostGlyph.IsValid() && destPostGlyph.glyph->ShouldBindBefore())
		bindAfter = true;

	// begin setting up the dest
	if (destPreGlyph.IsValid())
		destFirstText.Set(destPreGlyph);
	else
		destFirstText.Set(destPostGlyph.textNode->GetText(), destPostGlyph.StartOffset(), 0);
	if (destPostGlyph.IsValid())
		destLastText.Set(destPostGlyph);
	else
		destLastText.Set(destPreGlyph.textNode->GetText(), destPreGlyph.EndOffset(), 0);

	// now figure out exactly how to do the dest binding
	bool needPreSpace = !bindBefore;
	bool needPostSpace = !bindAfter;
	// may need to delete space that's there
	if (!needPreSpace && !needPostSpace && destSpaceGlyph.IsValid())
		destDeleteText.Set(destSpaceGlyph);
	// take what we need from the source, preferring the srcPostSpaceGlyph
	else if (needPreSpace && needPostSpace) {
		// pre-space
		if (destSpaceGlyph.IsValid())
			destFirstText.Set(destSpaceGlyph);
		else if (srcPreSpaceGlyph.IsValid())
			takePreSpace = true;
		else
			addPreSpace = true;
		// post-space
		if (srcPostSpaceGlyph.IsValid())
			takePostSpace = true;
		else
			addPostSpace = true;
		}
	else if (needPreSpace) {
		if (destSpaceGlyph.IsValid())
			destFirstText.Set(destSpaceGlyph);
		else if (srcPreSpaceGlyph.IsValid())
			takePreSpace = true;
		else
			addPreSpace = true;
		}
	else if (needPostSpace) {
		if (destSpaceGlyph.IsValid())
			destLastText.Set(destSpaceGlyph);
		else if (srcPostSpaceGlyph.IsValid())
			takePostSpace = true;
		else
			addPostSpace = true;
		}

}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* FirstTextIn(Node* node)
{
	for (Node* childNode = node->FirstChild(); childNode; childNode = childNode->NextSibling()) {
		if (childNode->NodeType() == TEXT_NODE)
			return dynamic_cast<Text*>(childNode);
		Text* firstText = FirstTextIn(childNode);
		if (firstText)
			return firstText;
		}
	return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* LastTextIn(Node* node)
{
	for (Node* childNode = node->LastChild(); childNode; childNode = childNode->PreviousSibling()) {
		if (childNode->NodeType() == TEXT_NODE)
			return dynamic_cast<Text*>(childNode);
		Text* lastText = LastTextIn(childNode);
		if (lastText)
			return lastText;
		}
	return NULL;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool copying;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool singleSrcText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool hasNodes;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan srcPreSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan srcFirstText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan srcLastText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan srcPostSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan destFirstText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan destDeleteText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan destLastText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool takePreSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool takePostSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool keepSrcPreSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool keepSrcPostSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool addPreSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool addPostSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool addSrcSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* firstMoveNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* lastMoveNode;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:53:32 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
TextSpan
</name>
<hIncludes><![CDATA[
#include "GlyphRef.h"

class Text;

#ifndef NULL
#define NULL	(0)
#endif
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Text.h"
#include "Glyph.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline TextSpan(Text* textIn, unsigned long offsetIn, unsigned long lengthIn)
	: text(textIn), offset(offsetIn), length(lengthIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan(GlyphRef firstGlyph, GlyphRef lastGlyph)
{
	text = firstGlyph.GetTextNode()->GetText();
	if (useAssertions && text != lastGlyph.GetTextNode()->GetText())
		throw InternalException("TextSpan ctor: glyphs are not in the same Text.");
	offset = firstGlyph.GetTextNode()->OffsetOfGlyph(firstGlyph.GetGlyph());
	unsigned long lastStartOffset =
		lastGlyph.GetTextNode()->OffsetOfGlyph(lastGlyph.GetGlyph());
	length = lastStartOffset + lastGlyph.GetGlyph()->NumCharsInText() - offset;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
TextSpan(GlyphRef glyph)
{
	text = glyph.GetTextNode()->GetText();
	offset = glyph.GetTextNode()->OffsetOfGlyph(glyph.GetGlyph());
	length = glyph.GetGlyph()->NumCharsInText();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline TextSpan()
	: text(NULL), offset(0), length(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long EndOffset()
{
	return offset + length;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsJustBefore(const TextSpan& otherSpan)
{
	return (text == otherSpan.text && otherSpan.offset == offset + length);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline bool IsEmpty()
{
	return (length == 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsValid()
{
	return (text != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline void Set(Text* newText, unsigned long newOffset, unsigned long newLength)
{
	text = newText;
	offset = newOffset;
	length = newLength;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Set(GlyphRef firstGlyph, GlyphRef lastGlyph)
{
	text = firstGlyph.GetTextNode()->GetText();
	if (useAssertions && text != lastGlyph.GetTextNode()->GetText())
		throw InternalException("TextSpan::Set: glyphs are not in the same Text.");
	offset = firstGlyph.GetTextNode()->OffsetOfGlyph(firstGlyph.GetGlyph());
	unsigned long lastStartOffset =
		lastGlyph.GetTextNode()->OffsetOfGlyph(lastGlyph.GetGlyph());
	length = lastStartOffset + lastGlyph.GetGlyph()->NumCharsInText() - offset;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Set(GlyphRef glyph)
{
	text = glyph.GetTextNode()->GetText();
	offset = glyph.GetTextNode()->OffsetOfGlyph(glyph.GetGlyph());
	length = glyph.GetGlyph()->NumCharsInText();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Clear()
{
	text = NULL;
	offset = length = 0;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Append(const TextSpan& other)
{
	// sanity clauses
	if (useAssertions && other.text != text)
		throw InternalException("TextSpan::Append: Not the same Text.");
	if (useAssertions && other.offset != offset + length)
		throw InternalException("TextSpan::Append: Other span is not just after this one.");

	// append
	length += other.length;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AdjustForInsert(Text* insertText, unsigned long insertOffset, unsigned long insertLength)
{
	if (text == insertText) {
		if (offset >= insertOffset)
			offset += insertLength;
		else if (insertOffset < offset + length)
			length += insertLength;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AdjustForDelete(Text* deleteText, unsigned long deleteOffset, unsigned long deleteLength)
{
	if (text == deleteText) {
		if (offset > deleteOffset)
			offset -= deleteLength;
		else if (deleteOffset < offset + length) {
			deleteOffset -= offset;	// convert to relative position for convenience
			if (deleteOffset + deleteLength > length)
				length = deleteOffset;
			else
				length -= deleteLength;
			}
		}
}
]]></method>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables--Public"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long offset;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long length;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Actions"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 17:54:13 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Action
</name>
<hIncludes><![CDATA[

class DisplayDirector;
]]></hIncludes>
<cppIncludes><![CDATA[

#ifndef NULL
#define NULL	(0)
#endif
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action()
	: next(NULL), prev(NULL), done(false)
{
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:54:59 PST"><![CDATA[
virtual ~Action()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Do(DisplayDirector* director)
{
	/* pure virtual, inherit to set "done" */
	done = true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Undo(DisplayDirector* director)
{
	/* pure virtual, inherit to set "done" */
	done = false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool CanIncorporateNext(Action* nextAction)
{
	// default: no
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void IncorporateNext(Action* nextAction)
{
	// default: do nothing, since CanIncorporateNext() defaults to "false"
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual bool IsNulled()
{
	// IsNulled() is only meaningful immediately after IncorporateNext();
	// it means the consolidated action has no effect and should be
	// deleted from action list.
	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Linked List"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void InsertAfter(Action* prevAction)
{
	Unlink();

	next = prevAction->next;
	prev = prevAction;
	if (prevAction->next)
		prevAction->next->prev = this;
	prevAction->next = this;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Unlink()
{
	if (prev)
		prev->next = next;
	if (next)
		next->prev = prev;
	next = prev = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* NextAction()
{
	return next;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* PrevAction()
{
	return prev;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeleteRest()
{
	// delete the actions
	Action* nextAction = next;
	for (Action* action = nextAction; action; action = nextAction) {
		nextAction = action->next;
		delete action;
		}

	// mark this as the end
	next = NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DeleteAll()
{
	DeleteRest();

	// delete the actions
	Action* prevAction = prev;
	for (Action* action = prevAction; action; action = prevAction) {
		prevAction = action->prev;
		delete action;
		}

	// delete this too
	delete this;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* next;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* prev;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool done;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NullAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NullAction()
{
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 17:55:55 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
CompositeAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
]]></hIncludes>
<cppIncludes><![CDATA[

#ifndef NULL
#define NULL	(0)
#endif
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CompositeAction()
	: firstAction(NULL), lastAction(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~CompositeAction()
{
	Action* nextAction = NULL;
	for (Action* action = firstAction; action; action = nextAction) {
		nextAction = action->NextAction();
		delete action;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddAction(Action* action)
{
	if (lastAction)
		action->InsertAfter(lastAction);
	lastAction = action;
	if (firstAction == NULL)
		firstAction = action;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	for (Action* action = firstAction; action; action = action->NextAction())
		action->Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	for (Action* action = lastAction; action; action = action->PrevAction())
		action->Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanIncorporateNext(Action* nextAction)
{
	return (lastAction && lastAction->CanIncorporateNext(nextAction));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void IncorporateNext(Action* nextAction)
{
	lastAction->IncorporateNext(nextAction);

	// delete a nulled action
	if (lastAction->IsNulled()) {
		Action* penultimateAction = lastAction->PrevAction();
		delete lastAction;
		lastAction = penultimateAction;
		if (lastAction == NULL)
			firstAction = NULL;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsNulled()
{
	return (firstAction == NULL);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* firstAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* lastAction;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:56:30 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
AddCharsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "string_slice.h"
#include "qstring.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "DisplayDirector.h"
#include "TextDisplayNode.h"
#include "BackCharsAction.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
AddCharsAction(string_slice charsIn, Text* textIn, int atCharIn)
	: chars(charsIn), text(textIn), atChar(atCharIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);

	text->InsertData(atChar, DOMString(chars));

	// move the selection
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode)
		director->SetSelection(displayNode->GetSelectionAtOffset(atChar + chars.length()));

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	text->DeleteData(atChar, chars.length());

	// reset the selection
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode)
		director->SetSelection(displayNode->GetSelectionAtOffset(atChar));

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanIncorporateNext(Action* nextActionIn)
{
	// merge with another AddCharsAction if it's at the end of this one
	AddCharsAction* nextAction = dynamic_cast<AddCharsAction*>(nextActionIn);
	if (nextAction) {
		return (nextAction->text == text &&
		        nextAction->atChar == atChar + chars.length());
		}

	// merge with a BackCharAction if it's at the end of what we've added
	BackCharsAction* backAction = dynamic_cast<BackCharsAction*>(nextActionIn);
	if (backAction) {
		if (backAction->GetText() != text)
			return false;
		int numAddedChars = chars.length();
		int numDeletedChars = backAction->NumChars();
		int whichChar = backAction->WhichChar();
		return (whichChar + numDeletedChars == atChar + numAddedChars &&
		        numDeletedChars <= numAddedChars);
		}

	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void IncorporateNext(Action* nextActionIn)
{
	// incorporating AddCharsAction
	AddCharsAction* nextAction = dynamic_cast<AddCharsAction*>(nextActionIn);
	if (nextAction) {
		chars += nextAction->chars;
		}

	// incorporating BackCharAction
	BackCharsAction* backAction = dynamic_cast<BackCharsAction*>(nextActionIn);
	if (backAction) {
		// delete the last characters
		qstring newChars =
			string_slice(chars).substr(0, chars.length() - backAction->NumChars());
		chars = newChars;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsNulled()
{
	return (chars.length() == 0);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* GetText()
{
	return text;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int AtChar()
{
	return atChar;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int Length()
{
	return chars.length();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring chars;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Thu, 30 Mar 2000 17:56:30 PST"><![CDATA[
int atChar;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BackCharsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "qstring.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "DisplayDirector.h"
#include "TextDisplayNode.h"
#include "UTF8Utils.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BackCharsAction(Text* textIn, int whichCharIn, int numBytes = 1)
	: text(textIn), whichChar(whichCharIn)
{
	// store it into "chars", accounting for multi-byte UTF8 characters
	DOMString textData = text->Data();
	if (numBytes == 1) {
		// asking for deletion of one character; make sure to get all the bytes
		// of that character
		string_slice theChar = textData.substr(whichChar, 1);
		numBytes = UTF8Utils::BytesForChar(*theChar.begin());
		}
	chars = textData.substr(whichChar, numBytes);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~BackCharsAction()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// delete character(s)
	text->DeleteData(whichChar, chars.length());

	// move selection
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode)
		director->SetSelection(displayNode->GetSelectionAtOffset(whichChar));

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// re-insert the character
	text->InsertData(whichChar, DOMString(chars));

	// move selection
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode)
		director->SetSelection(displayNode->GetSelectionAtOffset(whichChar + chars.length()));

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanIncorporateNext(Action* nextAction)
{
	// merge with a BackCharAction if it's right before or after what we delete
	BackCharsAction* backAction = dynamic_cast<BackCharsAction*>(nextAction);
	if (backAction) {
		if (backAction->text != text)
			return false;
		if (backAction->whichChar + backAction->chars.length() == whichChar)
			return true;
		if (whichChar == backAction->whichChar) {
			// this test comes *after* we've done our deletion
			return true;
			}
		}

	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void IncorporateNext(Action* nextAction)
{
	// incorporating BackCharAction
	BackCharsAction* backAction = dynamic_cast<BackCharsAction*>(nextAction);
	if (backAction) {
		// add to ours
		if (backAction->whichChar + backAction->chars.length() == whichChar) {
			// backAction is a backwards delete from us
			whichChar -= backAction->chars.length();
			qstring newChars = backAction->chars;
			newChars += chars;
			chars = newChars;
			}
		else {
			// backAction is a forwards delete from us
			chars += backAction->chars;
			}
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* GetText()
{
	return text;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int WhichChar()
{
	return whichChar;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int NumChars()
{
	return chars.length();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int whichChar;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
qstring chars;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MoveCharsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "DOMString.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "DisplayDirector.h"
#include "TextDisplayNode.h"
#include "GlyphsSelection.h"
#include "Glyph.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MoveCharsAction(Text* srcTextIn, unsigned long srcOffsetIn, unsigned long srcLenIn,
                Text* destTextIn, unsigned long destOffsetIn, unsigned long destLen = 0,
                bool addPreSpaceIn = false, bool addPostSpaceIn = false,
                bool selectIn = false)
	: srcText(srcTextIn), srcOffset(srcOffsetIn), srcLen(srcLenIn),
	  destText(destTextIn), destOffset(destOffsetIn),
	  addPreSpace(addPreSpaceIn), addPostSpace(addPostSpaceIn), select(selectIn)
{
	if (destLen > 0) {
		destDeleted = destText->SubstringData(destOffset, destLen);
		destDeleted.detach();
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	if (select)
		director->SetSelection(NULL);

	unsigned long newSrcOffset = srcOffset;
	unsigned long newDestOffset = destOffset;

	// first delete anything necessary from the dest
	if (!destDeleted.empty()) {
		destText->DeleteData(destOffset, destDeleted.length());
		if (srcText == destText && newSrcOffset > destOffset)
			newSrcOffset -= destOffset;
		}

	// next insert the data
	if (addPreSpace) {
		destText->InsertData(newDestOffset, " ");
		newDestOffset += 1;
		if (srcText == destText && newSrcOffset > newDestOffset)
			newSrcOffset += 1;
		}
	destText->InsertData(newDestOffset, srcText->SubstringData(newSrcOffset, srcLen));
	if (srcText == destText && newSrcOffset >= destOffset)
		newSrcOffset += srcLen;
	if (addPostSpace) {
		destText->InsertData(newDestOffset + srcLen, " ");
		if (srcText == destText && newSrcOffset > newDestOffset)
			newSrcOffset += 1;
		}

	// finally, remove it from the source
	srcText->DeleteData(newSrcOffset, srcLen);
	if (srcText == destText && newDestOffset > newSrcOffset)
		newDestOffset -= srcLen;

	// select
	if (select) {
		TextDisplayNode* displayNode =
			dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(destText));
		if (displayNode == NULL)
			throw InternalException("MoveCharsAction::Do: No display node for destText.");
		Glyph* firstGlyph =
			displayNode->GlyphAtOffset(newDestOffset - displayNode->TextOffset());
		while (firstGlyph->IsWhitespace()) {
			Glyph* nextGlyph = displayNode->GlyphAfter(firstGlyph);
			if (nextGlyph == NULL)
				break;
			firstGlyph = nextGlyph;
			}
		Glyph* lastGlyph =
			displayNode->GlyphAtOffset(newDestOffset + srcLen - 1 - displayNode->TextOffset());
		while (lastGlyph->IsWhitespace()) {
			Glyph* prevGlyph = displayNode->GlyphBefore(lastGlyph);
			if (prevGlyph == NULL)
				break;
			lastGlyph = prevGlyph;
			}
		director->SetSelection(
			new GlyphsSelection(GlyphRef(displayNode, firstGlyph),
			                    GlyphRef(displayNode, lastGlyph)));
		}

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	if (select)
		director->SetSelection(NULL);

	// figure out where things ended up
	unsigned long newSrcOffset = srcOffset;
	unsigned long newDestOffset = destOffset;
	bool sameText = (srcText == destText);
	if (sameText) {
		if (srcOffset > destOffset) {
			if (!destDeleted.empty())
				newSrcOffset -= destOffset;
			if (addPreSpace)
				newSrcOffset += 1;
			if (addPostSpace)
				newSrcOffset += 1;
			newSrcOffset += srcLen;
			}
		else {
			newDestOffset -= srcLen;
			}
		}
	if (addPreSpace)
		newDestOffset += 1;

	// copy back to the source
	srcText->InsertData(newSrcOffset, destText->SubstringData(newDestOffset, srcLen));
	if (sameText && newDestOffset > newSrcOffset)
		newDestOffset += srcLen;

	// remove from the dest
	unsigned long delLen = srcLen;
	if (addPreSpace) {
		newDestOffset -= 1;
		delLen += 1;
		}
	if (addPostSpace)
		delLen += 1;
	destText->DeleteData(newDestOffset, delLen);

	// restore destDeleted
	if (!destDeleted.empty())
		destText->InsertData(destOffset, destDeleted);

	// select
	if (select) {
		TextDisplayNode* displayNode =
			dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(srcText));
		if (displayNode == NULL)
			throw InternalException("MoveCharsAction::Undo: No display node for srcText.");
		Glyph* firstGlyph =
			displayNode->GlyphAtOffset(srcOffset - displayNode->TextOffset());
		while (firstGlyph->IsWhitespace()) {
			Glyph* nextGlyph = displayNode->GlyphAfter(firstGlyph);
			if (nextGlyph == NULL)
				break;
			firstGlyph = nextGlyph;
			}
		Glyph* lastGlyph =
			displayNode->GlyphAtOffset(srcOffset + srcLen - 1 - displayNode->TextOffset());
		while (lastGlyph->IsWhitespace()) {
			Glyph* prevGlyph = displayNode->GlyphBefore(lastGlyph);
			if (prevGlyph == NULL)
				break;
			lastGlyph = prevGlyph;
			}
		director->SetSelection(
			new GlyphsSelection(GlyphRef(displayNode, firstGlyph),
			                    GlyphRef(displayNode, lastGlyph)));
		}

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* srcText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long srcOffset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long srcLen;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* destText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long destOffset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString destDeleted;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool addPreSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool addPostSpace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool select;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
CopyCharsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CopyCharsAction(Text* srcTextIn, unsigned long srcOffsetIn, unsigned long lengthIn,
                Text* destTextIn, unsigned long destOffsetIn)
	: srcText(srcTextIn), srcOffset(srcOffsetIn), length(lengthIn),
	  destText(destTextIn), destOffset(destOffsetIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	destText->InsertData(destOffset, srcText->SubstringData(srcOffset, length));

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	destText->DeleteData(destOffset, length);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* srcText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long srcOffset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long length;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* destText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long destOffset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DeleteCharsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "DOMString.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DeleteCharsAction(Text* textIn, unsigned long offsetIn, unsigned long lengthIn)
	: text(textIn), offset(offsetIn), length(lengthIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// save the text for undo
	data = text->SubstringData(offset, length);
	data.detach();

	// delete it
	text->DeleteData(offset, length);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	text->InsertData(offset, data);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long offset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long length;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString data;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SelectGlyphsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "TextDisplayNode.h"
#include "Glyph.h"
#include "GlyphsSelection.h"
#include "DisplayDirector.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectGlyphsAction(Text* firstTextIn, unsigned long firstOffsetIn,
                   Text* lastTextIn, unsigned long lastOffsetIn)
	: firstText(firstTextIn), firstOffset(firstOffsetIn),
	  lastText(lastTextIn), lastOffset(lastOffsetIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	TextDisplayNode* firstNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(firstText));
	if (firstNode == NULL)
		throw InternalException("SelectGlyphsAction::Do: first TextDisplayNode doesn't exist.");
	Glyph* firstGlyph = firstNode->GlyphAtOffset(firstOffset);
	if (firstGlyph == NULL)
		throw InternalException("SelectGlyphsAction::Do: first glyph doesn't exist.");
	TextDisplayNode* lastNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(lastText));
	if (lastNode == NULL)
		throw InternalException("SelectGlyphsAction::Do: last TextDisplayNode doesn't exist.");
	Glyph* lastGlyph = lastNode->GlyphAtOffset(lastOffset);
	if (lastGlyph == NULL)
		throw InternalException("SelectGlyphsAction::Do: last glyph doesn't exist.");
	director->SetSelection(new GlyphsSelection(GlyphRef(firstNode, firstGlyph), GlyphRef(lastNode, lastGlyph)));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// clear the selection for safety
	director->SetSelection(NULL);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* firstText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long firstOffset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* lastText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long lastOffset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SelectPointAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DisplayDirector.h"
#include "TextDisplayNode.h"
#include "Text.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectPointAction(Text* textIn, unsigned long offsetIn)
	: text(textIn), offset(offsetIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode == NULL)
		throw InternalException("SelectPointAction::Do: couldn't get display node.");
	director->SetSelection(displayNode->GetSelectionAtOffset(offset));

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long offset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SelectBlockElementsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlocksSelection.h"
#include "BlockElementSelection.h"
#include "Element.h"
#include "DisplayDirector.h"
#include "ElementDisplayNode.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectBlockElementsAction(Element* firstElementIn, Element* lastElementIn)
	: firstElement(firstElementIn), lastElement(lastElementIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	ElementDisplayNode* firstBlock =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(firstElement));
	ElementDisplayNode* lastBlock =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(lastElement));
	if (firstBlock && lastBlock) {
		if (firstBlock == lastBlock)
			director->SetSelection(new BlockElementSelection(firstBlock));
		else
			director->SetSelection(new BlocksSelection(firstBlock, lastBlock));
		}

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* firstElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* lastElement;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SelectBetweenBlocksAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BetweenBlocksSelection.h"
#include "BlockableDisplayNode.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SelectBetweenBlocksAction(Node* parentNodeIn, Node* beforeNodeIn)
	: parentNode(parentNodeIn), beforeNode(beforeNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	BlockableDisplayNode* parentDisplayNode =
		dynamic_cast<BlockableDisplayNode*>(director->DisplayNodeFor(parentNode));
	if (useAssertions && parentDisplayNode == NULL)
		throw InternalException("SelectBetweenBlocksAction: Couldn't get parent display node.");
	BlockableDisplayNode* beforeDisplayNode = NULL;
	if (beforeNode) {
		beforeDisplayNode = dynamic_cast<BlockableDisplayNode*>(director->DisplayNodeFor(beforeNode));
		if (useAssertions && beforeDisplayNode == NULL)
			throw InternalException("SelectBetweenBlocksAction: Couldn't get 'before' display node.");
		}
	director->SetSelection(new BetweenBlocksSelection(parentDisplayNode, beforeDisplayNode));

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* parentNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* beforeNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreGlyphsSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "GlyphsSelection.h"
#include "DisplayDirector.h"
#include "TextDisplayNode.h"
#include "Text.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreGlyphsSelectionAction()
	: firstText(NULL), firstOffset(0), lastText(NULL), lastOffset(0)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	GlyphsSelection* selection = dynamic_cast<GlyphsSelection*>(director->GetSelection());
	if (selection == NULL)
		throw InternalException("RestoreGlyphsSelectionAction::Do: no GlyphsSelection.");

	// get the info
	GlyphRef firstGlyph = selection->FirstGlyph();
	firstText = firstGlyph.GetTextNode()->GetText();
	firstOffset = firstGlyph.GetTextNode()->OffsetOfGlyph(firstGlyph.GetGlyph());
	GlyphRef lastGlyph = selection->LastGlyph();
	lastText = lastGlyph.GetTextNode()->GetText();
	lastOffset = lastGlyph.GetTextNode()->OffsetOfGlyph(lastGlyph.GetGlyph());

	// for safety of further actions, clear the selection
	director->SetSelection(NULL);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// sanity clause
	if (firstText == NULL || lastText == NULL)
		return;

	// restore the selection
	TextDisplayNode* firstNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(firstText));
	if (firstNode == NULL)
		throw InternalException("RestoreGlyphsSelectionAction::Undo: first TextDisplayNode doesn't exist.");
	Glyph* firstGlyph = firstNode->GlyphAtOffset(firstOffset);
	if (firstGlyph == NULL)
		throw InternalException("RestoreGlyphsSelectionAction::Undo: first glyph doesn't exist.");
	TextDisplayNode* lastNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(lastText));
	if (lastNode == NULL)
		throw InternalException("RestoreGlyphsSelectionAction::Undo: last TextDisplayNode doesn't exist.");
	Glyph* lastGlyph = lastNode->GlyphAtOffset(lastOffset);
	if (lastGlyph == NULL)
		throw InternalException("RestoreGlyphsSelectionAction::Undo: last glyph doesn't exist.");
	director->SetSelection(new GlyphsSelection(GlyphRef(firstNode, firstGlyph), GlyphRef(lastNode, lastGlyph)));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* firstText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long firstOffset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* lastText;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long lastOffset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreInlineElementSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "ElementDisplayNode.h"
#include "InlineElementSelection.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreInlineElementSelectionAction()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	InlineElementSelection* selection =
		dynamic_cast<InlineElementSelection*>(director->GetSelection());
	if (selection == NULL)
		throw InternalException("RestoreInlineElementSelectionAction::Do: no InlineElementSelection.");

	element = selection->GetElement();
	director->SetSelection(NULL);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// sanity clause
	if (element == NULL)
		return;

	// restore the selection
	ElementDisplayNode* displayNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(element));
	if (displayNode == NULL)
		throw InternalException("RestoreInlineElementAction::Undo: no DislayNode.");
	director->SetSelection(new InlineElementSelection(displayNode));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* element;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestorePointSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "TextDisplayNode.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestorePointSelectionAction(Text* textIn, unsigned long offsetIn)
	: text(textIn), offset(offsetIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// reselect
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode == NULL) {
		if (useAssertions)
			throw InternalException("RestorePointSelectionAction::Undo: couldn't get display node.");
		return;
		}
	director->SetSelection(displayNode->GetSelectionAtOffset(offset));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long offset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreBetweenWordsSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "TextDisplayNode.h"
#include "Space.h"
#include "Text.h"
#include "BetweenWordsSelection.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreBetweenWordsSelectionAction(Text* textIn, unsigned long offsetIn)
	: text(textIn), offset(offsetIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (displayNode == NULL)
		throw InternalException("RestoreBetweenWordsSelectionAction::Do: couldn't get TextDisplayNode.");
	Space* space = dynamic_cast<Space*>(displayNode->GlyphAtOffset(offset));
	if (space == NULL)
		throw InternalException("RestoreBetweenWordsSelectionAction::Do: couldn't get Space.");
	director->SetSelection(new BetweenWordsSelection(displayNode, space));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long offset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreBlocksSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlocksSelection.h"
#include "ElementDisplayNode.h"
#include "Element.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreBlocksSelectionAction(Element* firstElementIn, Element* lastElementIn)
	: firstElement(firstElementIn), lastElement(lastElementIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	ElementDisplayNode* firstDisplayNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(firstElement));
	if (firstDisplayNode == NULL)
		throw InternalException("RestoreBlocksSelectAction::Do: couldn't get ElementDisplayNode.");
	ElementDisplayNode* lastDisplayNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(lastElement));
	if (lastDisplayNode == NULL)
		throw InternalException("RestoreBlocksSelectAction::Do: couldn't get ElementDisplayNode.");

	director->SetSelection(new BlocksSelection(firstDisplayNode, lastDisplayNode));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* firstElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* lastElement;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreBlockElementSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "BlockElementSelection.h"
#include "DisplayDirector.h"
#include "ElementDisplayNode.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreBlockElementSelectionAction(Element* elementIn)
	: element(elementIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	ElementDisplayNode* displayNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(element));
	if (displayNode == NULL)
		throw InternalException("RestoreBlockElementSelectAction::Do: couldn't get ElementDisplayNode.");

	director->SetSelection(new BlockElementSelection(displayNode));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* element;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreBetweenBlocksSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include "BlockableDisplayNode.h"
#include "BetweenBlocksSelection.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreBetweenBlocksSelectionAction(Node* parentNodeIn, Node* beforeNodeIn)
	: parentNode(parentNodeIn), beforeNode(beforeNodeIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	BlockableDisplayNode* parentDisplayNode =
		dynamic_cast<BlockableDisplayNode*>(director->DisplayNodeFor(parentNode));
	if (useAssertions && parentDisplayNode == NULL)
		throw InternalException("RestoreBetweenBlocksSelectionAction: parent isn't blockable.");
	BlockableDisplayNode* beforeDisplayNode = NULL;
	if (beforeNode) {
		beforeDisplayNode =
			dynamic_cast<BlockableDisplayNode*>(director->DisplayNodeFor(beforeNode));
		if (useAssertions && beforeDisplayNode == NULL)
			throw InternalException("RestoreBetweenBlocksSelectionAction: beforeNode isn't blockable.");
		}
	director->SetSelection(new BetweenBlocksSelection(parentDisplayNode, beforeDisplayNode));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* parentNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* beforeNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreEmptyPlaceholderSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Element;
class DisplayNode;
class PlaceholderTextDisplayNode;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "ElementDisplayNode.h"
#include "PlaceholderTextDisplayNode.h"
#include "EmptyPlaceholderSelection.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RestoreEmptyPlaceholderSelectionAction(Element* elementIn)
	: element(elementIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);
	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	ElementDisplayNode* elementNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(element));
	if (useAssertions && elementNode == NULL)
		throw InternalException("RestoreEmptyPlaceholderSelectionAction::Undo: Couldn't get ElementDisplayNode.");
	PlaceholderTextDisplayNode* placeholder = FindPlaceholderIn(elementNode);
/***
	PlaceholderTextDisplayNode* placeholder =
		dynamic_cast<PlaceholderTextDisplayNode*>(elementNode->FirstChild());
***/
	if (useAssertions && placeholder == NULL)
		throw InternalException("RestoreEmptyPlaceholderSelectionAction::Undo: Couldn't get the PlaceholderTextDisplayNode.");
	director->SetSelection(new EmptyPlaceholderSelection(placeholder));

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
PlaceholderTextDisplayNode* FindPlaceholderIn(DisplayNode* node)
{
	for (DisplayNode* child = node->FirstChild(); child; child = child->NextSibling()) {
		// see if the child is the placeholder
		PlaceholderTextDisplayNode* placeholder =
			dynamic_cast<PlaceholderTextDisplayNode*>(child);
		if (placeholder)
			return placeholder;

		// see if the placeholder is inside the child
		placeholder = FindPlaceholderIn(child);
		if (placeholder)
			return placeholder;
		}

	return NULL;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* element;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:58:47 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RestoreSelectionAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

#ifndef NULL
#define NULL	(0)
#endif
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Selection.h"
#include "DisplayDirector.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 17:58:47 PST"><![CDATA[
RestoreSelectionAction(Action* wrappedActionIn = NULL)
	: restoreAction(NULL), wrappedAction(wrappedActionIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~RestoreSelectionAction()
{
	delete restoreAction;
	delete wrappedAction;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// set up to restore the selection
	delete restoreAction;
	Selection* selection = director->GetSelection();
	restoreAction = (selection ? selection->GetRestoreAction() : NULL);
	if (restoreAction)
		restoreAction->Do(director);

	// do the wrappedAction
	if (wrappedAction)
		wrappedAction->Do(director);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// undo the wrappedAction
	if (wrappedAction)
		wrappedAction->Undo(director);

	// restore the selection
	if (restoreAction)
		restoreAction->Undo(director);
	else
		director->SetSelection(NULL);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* restoreAction;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Action* wrappedAction;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NewTextAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Document;
class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Document.h"
#include "Text.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewTextAction(Document* document)
{
	text = document->CreateTextNode("");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NewTextAction()
{
	if (!done)
		delete text;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// nothing to actually do; if the Text is to be inserted, another Action will do it

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	// nothing to actually undo

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* GetText()
{
	return text;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MoveNodesAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Node;

/*
	You can move a single node to or from a NULL parent, but you won't
	be able to do this to multiple nodes until DocumentFragments are implemented.
*/
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include "DisplayDirector.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MoveNodesAction(Node* firstNodeIn, Node* lastNodeIn,
                Node* destParentIn, Node* destNextNodeIn)
	: firstNode(firstNodeIn), lastNode(lastNodeIn),
	  destParent(destParentIn), destNextNode(destNextNodeIn)
{
	srcParent = firstNode->ParentNode();
	srcNextNode = lastNode->NextSibling();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);

	Node* nextNode = NULL;
	for (Node* node = firstNode; ; node = nextNode) {
		nextNode = node->NextSibling();

		// move the node
		if (srcParent)
			srcParent->RemoveChild(node);
		if (destParent)
			destParent->InsertBefore(node, destNextNode);

		if (node == lastNode)
			break;
		}

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	Node* nextNode = NULL;
	for (Node* node = firstNode; ; node = nextNode) {
		nextNode = node->NextSibling();

		// move the node
		if (destParent)
			destParent->RemoveChild(node);
		if (srcParent)
			srcParent->InsertBefore(node, srcNextNode);

		if (node == lastNode)
			break;
		}

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* firstNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* lastNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* srcParent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* srcNextNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* destParent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* destNextNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
CopyNodesAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Node;
class CopiedNodesList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include <vector>

class CopiedNodesList : public vector<Node*> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CopyNodesAction(Node* firstNode, Node* lastNode,
                Node* destParentIn, Node* destBeforeNodeIn)
	: destParent(destParentIn), destBeforeNode(destBeforeNodeIn)
{
	copiedNodes = new CopiedNodesList();
	for (Node* srcNode = firstNode; ; srcNode = srcNode->NextSibling()) {
		copiedNodes->push_back(srcNode->CloneNode(true));
		if (srcNode == lastNode)
			break;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~CopyNodesAction()
{
	if (!done) {
		for (CopiedNodesList::iterator n = copiedNodes->begin(); n != copiedNodes->end(); ++n)
			delete *n;
		}
	delete copiedNodes;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	for (CopiedNodesList::iterator n = copiedNodes->begin(); n != copiedNodes->end(); ++n) {
		destParent->InsertBefore(*n, destBeforeNode);
		}

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	for (CopiedNodesList::iterator n = copiedNodes->begin(); n != copiedNodes->end(); ++n) {
		destParent->RemoveChild(*n);
		}

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* FirstNode()
{
	return copiedNodes->front();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* LastNode()
{
	return copiedNodes->back();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CopiedNodesList* copiedNodes;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* destParent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* destBeforeNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
RemoveNodesAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Node;
class RemovedNodesList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include <vector>

class RemovedNodesList : public vector<Node*> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RemoveNodesAction(Node* firstNode, Node* lastNode)
{
	nodes = new RemovedNodesList();
	for (Node* node = firstNode; node; node = node->NextSibling()) {
		nodes->push_back(node);
		if (node == lastNode)
			break;
		}

	parent = firstNode->ParentNode();
	beforeNode = lastNode->NextSibling();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~RemoveNodesAction()
{
	if (done) {
		for (RemovedNodesList::iterator n = nodes->begin(); n != nodes->end(); ++n)
			delete *n;
		}
	delete nodes;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// remove the nodes
	for (RemovedNodesList::iterator n = nodes->begin(); n != nodes->end(); ++n)
		parent->RemoveChild(*n);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	for (RemovedNodesList::iterator n = nodes->begin(); n != nodes->end(); ++n)
		parent->InsertBefore(*n, beforeNode);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
RemovedNodesList* nodes;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* parent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* beforeNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SplitTextAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "Document.h"
#include "DisplayDirector.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SplitTextAction(Text* textIn, unsigned long splitOffsetIn)
	: text(textIn), splitOffset(splitOffsetIn)
{
	newText = text->OwnerDocument()->CreateTextNode("");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~SplitTextAction()
{
	if (!done)
		delete newText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// copy characters to the new text
	unsigned long splitLen = text->Length() - splitOffset;
	if (splitLen > 0) {
		newText->AppendData(text->SubstringData(splitOffset, splitLen));
		text->DeleteData(splitOffset, splitLen);
		}

	// insert the new text node
	text->ParentNode()->InsertBefore(newText, text->NextSibling());

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// remove the new node
	text->ParentNode()->RemoveChild(newText);

	// copy the text back
	text->AppendData(newText->Data());
	newText->SetData("");

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* GetNewText()
{
	return newText;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long splitOffset;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* newText;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InsertSpaceAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InsertSpaceAction(Text* textIn, unsigned long offsetIn)
	: text(textIn), offset(offsetIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// insert
	text->InsertData(offset, " ");

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	text->DeleteData(offset, 1);

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long SpaceLength()
{
	return 1;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long offset;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NewLeafBlockAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "DOMString.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Text.h"
#include "Document.h"
#include "DisplayDirector.h"
#include "BetweenGlyphsSelection.h"
#include "TextDisplayNode.h"
#include "RestoreSelectionAction.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewLeafBlockAction(Element* afterElementIn, DOMString tagName = DOMString())
	: afterElement(afterElementIn)
{
	Document* document = afterElement->OwnerDocument();
	if (tagName.empty())
		tagName = afterElement->TagName();
	newElement = document->CreateElement(tagName);
	Text* newText = document->CreateTextNode("");
	newElement->AppendChild(newText);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NewLeafBlockAction()
{
	if (!done) {
		delete newElement->RemoveChild(newElement->FirstChild());
		delete newElement;		
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// add the new leaf block
	afterElement->ParentNode()->InsertBefore(newElement, afterElement->NextSibling());

	// select
	Text* text = dynamic_cast<Text*>(newElement->FirstChild());
	if (useAssertions && text == NULL)
		throw InternalException("NewLeafBlockAction::Do: New element's text disappeared!");
	TextDisplayNode* textDisplayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(text));
	if (useAssertions && textDisplayNode == NULL)
		throw InternalException("NewLeafBlockAction::Do: Didn't get DisplayNode for the new text.");
	director->SetSelection(new BetweenGlyphsSelection(textDisplayNode, NULL, NULL, false));

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	afterElement->ParentNode()->RemoveChild(newElement);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* afterElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* newElement;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:22:54 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NewElementAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "DOMString.h"

class Node;
class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Document.h"
#include "Text.h"
#include "TextDisplayNode.h"
#include "ElementDisplayNode.h"
#include "DisplayDirector.h"
#include "BetweenGlyphsSelection.h"
#include "AddCharsAction.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:22:48 PDT"><![CDATA[
NewElementAction(DOMString tagName, Node* parentNodeIn, Node* beforeNodeIn)
	: parentNode(parentNodeIn), beforeNode(beforeNodeIn)
{
	Document* document = parentNode->OwnerDocument();
	newElement = document->CreateElement(tagName);
//***	newElement->AppendChild(document->CreateTextNode(""));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NewElementAction()
{
	if (!done)
		delete newElement;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Properties"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* GetNewElement()
{
	return newElement;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	// add the new element
	parentNode->InsertBefore(newElement, beforeNode);

	// select
/***
	Text* newText = dynamic_cast<Text*>(newElement->FirstChild());
	if (useAssertions && newText == NULL)
		throw InternalException("NewElementAction::Do: new Element lost its Text child.");
	TextDisplayNode* displayNode =
		dynamic_cast<TextDisplayNode*>(director->DisplayNodeFor(newText));
	if (useAssertions && displayNode == NULL)
		throw InternalException("NewElementAction::Do: no TextDisplayNode for the new text.");
	director->SetSelection(displayNode->EndSelection());
***/
	DisplayNode* displayNode = director->DisplayNodeFor(newElement);
	if (displayNode)
		director->SetSelection(displayNode->GetSelection());
/***
	ElementDisplayNode* elementNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(newElement));
	if (useAssertions && elementNode == NULL)
		throw InternalException("NewElementAction::Do: Can't get the new element's display node.");
	director->SetSelection(elementNode->EndSelection());
***/
/*** NOT TRIED (EndSelection() was quicker)
	PlaceholderTextDisplayNode* textNode =
		dynamic_cast<PlaceholderTextDisplayNode*>(elementNode->FirstChild());
	if (useAssertions && textNode == NULL)
		throw InternalException("NewElementAction::Do: Placeholder is missing!");
***/

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// remove the node
	parentNode->RemoveChild(newElement);

	Action::Undo(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool CanIncorporateNext(Action* nextActionIn)
{
/***
	// merge with another AddCharsAction if it's at the end of this one
	AddCharsAction* nextAction = dynamic_cast<AddCharsAction*>(nextActionIn);
	if (nextAction) {
		Text* newText = dynamic_cast<Text*>(newElement->FirstChild());
		if (useAssertions && newText == NULL)
			throw InternalException("NewElementAction::CanIncorporateNext: new Element lost its Text child.");
		return (nextAction->GetText() == newText &&
		        nextAction->AtChar() == newText->Length() - nextAction->Length());
		}
***/

	return false;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void IncorporateNext(Action* nextAction)
{
	// nothing to do--"nextAction" is an AddCharsAction and the characters
	// are already in the new Text
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* parentNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* beforeNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* newElement;
]]></variable>

</class>


<class mod-time="Thu, 13 Apr 2000 02:21:27 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ChangeElementTagNameAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "DOMString.h"

class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Document.h"
#include "DisplayDirector.h"
#include "DisplayNode.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 02:21:27 PDT"><![CDATA[
ChangeElementTagNameAction(Element* element, DOMString newTagName)
	: oldElement(element)
{
	newElement = oldElement->OwnerDocument()->CreateElement(newTagName);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~ChangeElementTagNameAction()
{
	if (!done)
		delete newElement;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// replace the element
	oldElement->ParentNode()->ReplaceChild(newElement, oldElement);

	// move the child nodes
	for (Node* child = oldElement->FirstChild(); child; child = oldElement->FirstChild())
		newElement->AppendChild(oldElement->RemoveChild(child));

	// select
	DisplayNode* displayNode = director->DisplayNodeFor(newElement);
	if (displayNode)
		director->SetSelection(displayNode->GetSelection());

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// restore the old element
	newElement->ParentNode()->ReplaceChild(oldElement, newElement);

	// move the child nodes
	for (Node* child = newElement->FirstChild(); child; child = newElement->FirstChild())
		oldElement->AppendChild(newElement->RemoveChild(child));

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* oldElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* newElement;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
EncloseTextAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"
#include "DOMString.h"

class Text;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Text.h"
#include "Element.h"
#include "Document.h"
#include "ElementDisplayNode.h"
#include "DisplayDirector.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EncloseTextAction(Text* textIn, DOMString tagNameIn)
	: text(textIn), tagName(tagNameIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// remove the text from its parent
	Node* nextNode = text->NextSibling();
	Node* parent = text->ParentNode();
	parent->RemoveChild(text);

	// make the new element and add it in
	Element* element = parent->OwnerDocument()->CreateElement(tagName);
	element->AppendChild(text);
	parent->InsertBefore(element, nextNode);

	// select the new element
	ElementDisplayNode* displayNode =
		dynamic_cast<ElementDisplayNode*>(director->DisplayNodeFor(element));
	if (displayNode)
		director->SetSelection(displayNode->GetSelection());

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	// set up
	Element* element = dynamic_cast<Element*>(text->ParentNode());
	if (useAssertions && element == NULL)
		throw InternalException("EncloseTextAction::Undo: the text lost its parent element!");
	Node* parent = element->ParentNode();
	Node* nextNode = element->NextSibling();

	// remove the element
	parent->RemoveChild(element);

	// move the text back into place
	element->RemoveChild(text);
	parent->InsertBefore(text, nextNode);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Text* text;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString tagName;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
SplitElementAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Element;
class Node;
class NewElementsStack;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "BlockableDisplayNode.h"
#include "BetweenBlocksSelection.h"
#include "DisplayDirector.h"
#include "InternalException.h"
#include <vector>

class NewElementsStack : public vector<Node*> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
SplitElementAction(Element* splittingElementIn, Node* afterNodeIn)
	: splittingElement(splittingElementIn), afterNode(afterNodeIn), doneOnce(false)
{
	newElements = new NewElementsStack();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~SplitElementAction()
{
	if (!done) {
		for (NewElementsStack::iterator e = newElements->begin(); e != newElements->end(); ++e)
			delete *e;
		}
	delete newElements;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	Node* curElement = afterNode->ParentNode();
	if (curElement == NULL)
		throw InternalException("SplitElementAction::Do: Attempt to split non-element");
	Node* curAfterNode = afterNode;
	NewElementsStack::iterator e = newElements->begin();
	while (true) {
		// split the current element
		// create (or retrieve) and install the new element
		Node* newElement;
		if (!doneOnce) {
			newElement = curElement->CloneNode(false);
			newElements->push_back(newElement);
			}
		else
			newElement = *e;
		curElement->ParentNode()->InsertBefore(newElement, curElement->NextSibling());
		// move the children
		for (Node* child = curAfterNode->NextSibling(); child; ) {
			Node* nextChild = child->NextSibling();
			curElement->RemoveChild(child);
			newElement->AppendChild(child);
			child = nextChild;
			}

		// see if we're done
		if (curElement == splittingElement)
			break;

		// move up
		curAfterNode = curElement;
		curElement = curElement->ParentNode();
		++e;
		}

	// try to select between the (block) elements
	BlockableDisplayNode* beforeNode =
		dynamic_cast<BlockableDisplayNode*>(director->DisplayNodeFor(newElements->back()));
	if (beforeNode) {
		BlockableDisplayNode* parentNode =
			dynamic_cast<BlockableDisplayNode*>(beforeNode->Parent());
		if (parentNode)
			director->SetSelection(new BetweenBlocksSelection(parentNode, beforeNode));
		}

	doneOnce = true;
	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	director->SetSelection(NULL);

	Node* curElement = splittingElement;
	while (curElement != afterNode) {
		Node* splitChild = curElement->LastChild();

		// move the children back
		Node* splitElement = curElement->NextSibling();
		for (Node* child = splitElement->FirstChild(); child; ) {
			Node* nextChild = child->NextSibling();
			splitElement->RemoveChild(child);
			curElement->AppendChild(child);
			child = nextChild;
			}

		// remove the splitElement
		curElement->ParentNode()->RemoveChild(splitElement);

		// go 'round again
		curElement = splitChild;
		}

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* splittingElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* afterNode;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NewElementsStack* newElements;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool doneOnce;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MergeElementsAction
</name>
<superclasses>
public Action
</superclasses>
<hIncludes><![CDATA[
#include "Action.h"

class Node;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Node.h"
#include "Text.h"
#include "DisplayDirector.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MergeElementsAction(Node* mergedElement)
	: bottomMergedElement(mergedElement)
{
	// figure out how much deep the merge goes
	for (topMergedElement = bottomMergedElement; topMergedElement;
	     	topMergedElement = topMergedElement->ParentNode()) {
		retainedElement = topMergedElement->PreviousSibling();
		// skip ignorable whitespace, comments, etc.
		while (retainedElement && retainedElement->NodeType() != ELEMENT_NODE)
			retainedElement = retainedElement->PreviousSibling();
		if (retainedElement)
			break;
		}
	if (topMergedElement == NULL)
		return;

	// we want to put the text in the last paragraph of retainedElement
	Node* lastChild = retainedElement->LastChild();
	while (lastChild) {
		int nodeType = lastChild->NodeType();
		if (nodeType == TEXT_NODE) {
			Text* text = dynamic_cast<Text*>(lastChild);
			if (!text->IsIgnorableWhitespace())
				break;
			}
		if (nodeType == ELEMENT_NODE) {
			retainedElement = lastChild;
			lastChild = retainedElement->LastChild();
			}
		else {
			// it's a comment or something; check before it
			lastChild = lastChild->LastChild();
			}
		}

	// we need to know how to put topMergedElement back
	srcParent = topMergedElement->ParentNode();
	srcNext = topMergedElement->NextSibling();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~MergeElementsAction()
{
	if (done)
		delete topMergedElement;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool IsValid()
{
	return (topMergedElement != NULL);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Action virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Do(DisplayDirector* director)
{
	if (topMergedElement == NULL)
		return;

	// move all the children of bottomMergedElement to retainedElement
	firstMergedNode = bottomMergedElement->FirstChild();
	for (Node* child = firstMergedNode; child;
	     	child = bottomMergedElement->FirstChild()) {
		retainedElement->AppendChild(bottomMergedElement->RemoveChild(child));
		}

	// remove topMergedElement
	srcParent->RemoveChild(topMergedElement);

	Action::Do(director);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Undo(DisplayDirector* director)
{
	if (topMergedElement == NULL)
		return;

	// move the merged nodes back to bottomMergedElement
	Node* nextChild;
	for (Node* child = firstMergedNode; child; child = nextChild) {
		nextChild = child->NextSibling();
		bottomMergedElement->AppendChild(retainedElement->RemoveChild(child));
		}

	// put topMergedElement back
	srcParent->InsertBefore(topMergedElement, srcNext);

	Action::Undo(director);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* retainedElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* topMergedElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* bottomMergedElement;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* srcParent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* srcNext;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Node* firstMergedNode;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Contexts"
</name>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayContext
</name>
<hIncludes><![CDATA[

class DisplayDirector;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayContext(DisplayDirector* directorIn)
	: director(directorIn)
{
}
]]></method>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* director;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:39:49 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InlineLayoutContext
</name>
<hIncludes><![CDATA[
#include "DOMString.h"

class Glyph;
class Font;
class GlyphsList;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Glyph.h"
#include "Tab.h"
#include "Font.h"
#include <vector.h>

struct GlyphInfo {
	Glyph*	glyph;
	int   	width;
	int   	ascent;

	GlyphInfo(Glyph* glyphIn, int widthIn, int ascentIn)
		: glyph(glyphIn), width(widthIn), ascent(ascentIn) {}
	GlyphInfo() : glyph(NULL), width(0), ascent(0) {}	// STL requires this
};

class GlyphsList : public vector<GlyphInfo> {};

enum {
	AlignLeft,
	AlignRight,
	AlignCenter,
	AlignJustify
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:39:49 PST"><![CDATA[
InlineLayoutContext(int lineLengthIn, int textIndent, DOMString alignmentIn)
	: curX(textIndent), curY(0), curLine(0),
	  lineLength(lineLengthIn), curLineHeight(0),
	  haveStarted(false), haveStartedLine(false), inWhitespace(true), curWidth(0),
	  maxLineHeight(0), maxAscent(0), multiLineHeights(false),
	  totalHeight(0), curLineWidth(0), maxLineWidth(0)
{
	curGlyphs = new GlyphsList();
	curLineGlyphs = new GlyphsList();

	// alignment
	if (alignmentIn == "right")
		alignment = AlignRight;
	else if (alignmentIn == "center")
		alignment = AlignCenter;
	else if (alignmentIn == "justify")
		alignment = AlignJustify;
	else
		alignment = AlignLeft;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~InlineLayoutContext()
{
	delete curGlyphs;
	delete curLineGlyphs;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void AddGlyph(Glyph* glyph)
{
	bool glyphIsWhitespace = glyph->IsWhitespace();
	int glyphWidth = glyph->Width(font);

	// handle line break specially
	if (glyph->IsLineBreak()) {
		FinishCurGlyphs();
		inWhitespace = true;
		glyph->SetPosition(curX, curY, curLine);
		NewLine();
		return;
		}

	// handle tab specially
	if (glyph->IsTab()) {
		FinishCurGlyphs();
		inWhitespace = true;
		Tab* tab = dynamic_cast<Tab*>(glyph);
		tab->SetPosition(curX, curY, curLine);
		int tabWidth = 4 * font->SpaceWidth();	/***/
		int width = tabWidth - (curX % tabWidth);
		tab->SetWidth(width);
		curX += width;
		haveStartedLine = true;
		return;
		}

	// starting a new run
	if (glyphIsWhitespace != inWhitespace) {
		FinishCurGlyphs();
		inWhitespace = glyphIsWhitespace;
		}

	// continuing a run
	if (glyphIsWhitespace) {
		// continue whitespace
		glyph->SetPosition(curX, curY, curLine);
		if (glyph->IsPreSpace())
			curWidth += glyphWidth;
		else if (glyphWidth > curWidth)
			curWidth = glyphWidth;
		curGlyphs->push_back(GlyphInfo(glyph, glyphWidth, curAscent));
		}
	else {
		// start a new run of words
		curGlyphs->push_back(GlyphInfo(glyph, glyphWidth, curAscent));
		curWidth += glyphWidth;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetFont(Font* newFont)
	// NOTE: doesn't take "newFont"
{
	font = newFont;
	SetLineHeight(font->LineHeight());
	curAscent = font->Ascent();
	if (curAscent > maxAscent)
		maxAscent = curAscent;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetLineHeight(int newLineHeight)
{
	if (newLineHeight == curLineHeight)
		return;

	if (maxLineHeight != 0)
		multiLineHeights = true;
	curLineHeight = newLineHeight;
	if (curLineHeight > maxLineHeight)
		maxLineHeight = curLineHeight;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Finish()
{
	FinishCurGlyphs();
	FinishCurLine(true);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int WidthLeftInLine()
{
	return lineLength - curX;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int TotalHeight()
{
	return totalHeight + maxLineHeight;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int MaxLineWidth()
{
	return maxLineWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishCurGlyphs()
{
	if (inWhitespace) {
		for (GlyphsList::iterator g = curGlyphs->begin(); g != curGlyphs->end(); ++g)
			curLineGlyphs->push_back(*g);
		if (haveStarted)
			curX += curWidth;
		}
	else {
		// do a newline if necessary
		if (curWidth > WidthLeftInLine() && haveStartedLine)
			NewLine();

		// position the glyphs
		for (GlyphsList::iterator g = curGlyphs->begin(); g != curGlyphs->end(); ++g) {
			g->glyph->SetPosition(curX, curY, curLine);
			curX += g->width;
			curLineGlyphs->push_back(*g);
			curLineWidth = curX;
			}

		haveStartedLine = true;
		}

	curGlyphs->clear();
	curWidth = 0;
	haveStarted = true;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FinishCurLine(bool isLastLine = false)
{
	GlyphsList::iterator g;

	// adjust for multiple heights
	if (multiLineHeights) {
		for (g = curLineGlyphs->begin(); g != curLineGlyphs->end(); ++g)
			g->glyph->AdjustY(maxAscent - g->ascent);
		}
	multiLineHeights = false;

	// alignment
	if (alignment == AlignRight || alignment == AlignCenter) {
		int adjustment = lineLength - curLineWidth;
		if (alignment == AlignCenter)
			adjustment /= 2;
		for (g = curLineGlyphs->begin(); g != curLineGlyphs->end(); ++g)
			g->glyph->AdjustX(adjustment);
		}
	else if (alignment == AlignJustify && !isLastLine) {
		// first, count the number of whitespace glyphs
		int numWhitespaceGlyphs = 0;
		bool haveStarted = false;
		bool lastWasWhitespace = false;
		for (g = curLineGlyphs->begin(); g != curLineGlyphs->end(); ++g) {
			if (g->glyph->IsWhitespace()) {
				if (haveStarted && !lastWasWhitespace)
					++numWhitespaceGlyphs;
				lastWasWhitespace = true;
				}
			else {
				haveStarted = true;
				lastWasWhitespace = false;
				}
			}
		if (lastWasWhitespace)
			--numWhitespaceGlyphs;
		// now do the adjustment
		float perSpaceAdjustment = float(lineLength - curLineWidth) / numWhitespaceGlyphs;
		float curAdjustment = 0;
		haveStarted = lastWasWhitespace = false;
		for (g = curLineGlyphs->begin(); g != curLineGlyphs->end(); ++g) {
			if (g->glyph->IsWhitespace()) {
				if (haveStarted && !lastWasWhitespace)
					curAdjustment += perSpaceAdjustment;
				lastWasWhitespace = true;
				}
			else {
				haveStarted = true;
				lastWasWhitespace = false;
				}
			g->glyph->AdjustX(curAdjustment);
			}
		}

	curLineGlyphs->clear();

	if (curLineWidth > maxLineWidth)
		maxLineWidth = curLineWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void NewLine()
{
	FinishCurLine();

	curX = 0;
	curY += maxLineHeight;
	curLine += 1;
	totalHeight += maxLineHeight;
	maxLineHeight = curLineHeight;
	maxAscent = curAscent;
	multiLineHeights = false;
	haveStartedLine = false;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curX;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curY;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curLine;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int lineLength;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int alignment;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curLineHeight;	// the current lineHeight (declared by SetLineHeight) for all following Glyphs
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curAscent;	// the current lineHeight (declared by SetFont) for all following Glyphs
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool haveStarted;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool haveStartedLine;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsList* curGlyphs;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool inWhitespace;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curWidth;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphsList* curLineGlyphs;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int maxLineHeight;	// the maximum lineHeight of a Glyph on the current line
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int maxAscent;	// the maximum ascent of a Glyph on the current line
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool multiLineHeights;	// true <=> the current line has Glyphs with different lineHeights
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int totalHeight;	// of all lines
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curLineWidth;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int maxLineWidth;	// of all lines
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
BlockDrawContext
</name>
<superclasses>
public DisplayContext
</superclasses>
<hIncludes><![CDATA[
#include "DisplayContext.h"

class View;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BlockDrawContext(DisplayDirector* directorIn, View* viewIn, int originXIn, int originYIn,
                 int startYIn, int endYIn)
	: DisplayContext(directorIn), view(viewIn), originX(originXIn), originY(originYIn),
	  startY(startYIn), endY(endYIn), curY(0)
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* view;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int originX;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int originY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int startY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int endY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curY;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InlineDrawContext
</name>
<hIncludes><![CDATA[

class View;
class BlockDrawContext;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "BlockDrawContext.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InlineDrawContext(BlockDrawContext* blockContext, int extraIndent)
	: view(blockContext->view), originX(blockContext->originX + extraIndent),
	  originY(blockContext->originY + blockContext->curY),
	  startY(blockContext->startY + blockContext->originY),
	  endY(blockContext->endY + blockContext->originY)
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* view;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int originX;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int originY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int startY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int endY;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
GlyphDrawContext
</name>
<hIncludes><![CDATA[

class View;
class Font;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
GlyphDrawContext(int originXIn, int originYIn, View* viewIn, Font* fontIn,
                 int startYIn, int endYIn)
	: originX(originXIn), originY(originYIn), view(viewIn), font(fontIn),
	  startY(startYIn), endY(endYIn)
{
}
]]></method>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int originX;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int originY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* view;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int startY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int endY;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FindSelectionContext
</name>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FindSelectionContext(int mouseXIn, int mouseYIn)
	: mouseX(mouseXIn), mouseY(mouseYIn), curY(0), xIndent(0)
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int mouseX;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int mouseY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int xIndent;	// used in inline only
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FindDestinationContext
</name>
<hIncludes><![CDATA[

class Selection;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FindDestinationContext(Selection* sourceIn, int mouseXIn, int mouseYIn)
	: source(sourceIn), mouseX(mouseXIn), mouseY(mouseYIn), curY(0)
{
}
]]></method>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Selection* source;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int mouseX;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int mouseY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int xIndent;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FindHotspotContext
</name>
<hIncludes><![CDATA[

class DisplayDirector;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FindHotspotContext(DisplayDirector* directorIn, int mouseXIn, int mouseYIn)
	: director(directorIn), mouseX(mouseXIn), mouseY(mouseYIn), curY(0), xIndent(0)
{
}
]]></method>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DisplayDirector* director;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int mouseX;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int mouseY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curY;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int xIndent;	// used in inline only
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"EditStylesheet"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 16:47:28 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
EditStylesheet
</name>
<hIncludes><![CDATA[
#include "DOMString.h"

class Element;
]]></hIncludes>
<method access="public" mod-time="Thu, 30 Mar 2000 16:47:22 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:47:12 PST"><![CDATA[
virtual ~EditStylesheet()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Pure Virtual"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DOMString PropertyForElement(string_slice propertyName, string_slice elementName) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Element* ContentsTemplateForElement(string_slice elementName) = 0;
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
CompositeStylesheet
</name>
<superclasses>
public EditStylesheet
</superclasses>
<hIncludes><![CDATA[
#include "EditStylesheet.h"
#include "string_slice.h"

class DocumentSource;
class DOMEditStylesheet;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "XMLFileSource.h"
#include "DOMEditStylesheet.h"
#include "System.h"
#include "InternalException.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CompositeStylesheet(string_slice documentType)
	: docStylesheetSource(NULL), docStylesheet(NULL)
{
	InitStatics();

	DOMString filePath = System::AppDirectory();
	filePath += "Stylesheets/";
	filePath += documentType;
	try {
		docStylesheetSource = new XMLFileSource(filePath);
		docStylesheet = new DOMEditStylesheet(docStylesheetSource->GetDocument());
		}
	catch (...) {
		// we don't care about errors
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~CompositeStylesheet()
{
	delete docStylesheet;
	delete docStylesheetSource;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"EditStylesheet virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString PropertyForElement(string_slice propertyName, string_slice elementName)
{
	DOMString result;
	if (docStylesheet)
		result = docStylesheet->PropertyForElement(propertyName, elementName);
	if (result.empty() && defaultStylesheet)
		result = defaultStylesheet->PropertyForElement(propertyName, elementName);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* ContentsTemplateForElement(string_slice elementName)
{
	Element* result = NULL;
	if (docStylesheet)
		result = docStylesheet->ContentsTemplateForElement(elementName);
	if (result == NULL && defaultStylesheet)
		result = defaultStylesheet->ContentsTemplateForElement(elementName);
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void InitStatics()
{
	if (defaultStylesheet == NULL) {
		DOMString filePath = System::AppDirectory();
		filePath += "Stylesheets/#default";
		try {
			defaultStylesheetSource = new XMLFileSource(filePath);
			defaultStylesheet = new DOMEditStylesheet(defaultStylesheetSource->GetDocument());
			}
		catch (...) {
			throw InternalException("Couldn't open the default stylesheet.  Make sure the program was installed correctly.");
			}
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DocumentSource* docStylesheetSource;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
EditStylesheet* docStylesheet;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DocumentSource* defaultStylesheetSource = NULL;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static EditStylesheet* defaultStylesheet = NULL;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 17:11:04 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DOMEditStylesheet
</name>
<superclasses>
public EditStylesheet
</superclasses>
<hIncludes><![CDATA[
#include "EditStylesheet.h"

class Document;
class DOMEditStyleDict;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Element.h"
#include "Attr.h"
#include "Text.h"
#include "Document.h"
#include "NodeList.h"
#include <map>

class DOMEditStyleDict : public map<DOMString, Element*> {};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMEditStylesheet(Document* document)
{
	dict = new DOMEditStyleDict();

	// read the elements into the dict
	Element* docElement = document->DocumentElement();
	NodeList* elements = docElement->GetElementsByTagName("element");
	for (int i = elements->Length() - 1; i >= 0; --i) {
		Element* element = dynamic_cast<Element*>(elements->Item(i));
		if (element == NULL)
			continue;

		// get the value of the "name" attribute
		//** NOTE: we assume that this is a single Text--if it's not, only the first
		//** Text will be recognized
		Attr* nameAttr = element->GetAttributeNode("name");
		if (nameAttr == NULL)
			continue;
		Text* nameText = dynamic_cast<Text*>(nameAttr->FirstChild());
		if (nameText == NULL)
			continue;

		// add to the dict
		(*dict)[nameText->Data()] = element;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~DOMEditStylesheet()
{
	delete dict;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"EditStylesheet virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString PropertyForElement(string_slice propertyName, string_slice elementName)
{
	DOMEditStyleDict::const_iterator e = dict->find(elementName);
	if (e == dict->end())
		return DOMString();
	Element* element = e->second;
	return element->GetAttribute(propertyName);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Element* ContentsTemplateForElement(string_slice elementName)
{
	DOMEditStyleDict::const_iterator e = dict->find(elementName);
	if (e == dict->end())
		return NULL;
	Element* element = e->second;
	return element->GetElementByTagName("display-contents");
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMEditStyleDict* dict;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
StyleParser
</name>
<hIncludes><![CDATA[
#include "DOMString.h"
#include "Color.h"

class StyleScriptable;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "StyleScriptable.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color ParseColor(DOMString stringIn)
{
	static const Color aqua = { 0, 255, 255, 255 };
	static const Color black = { 0, 0, 0, 255 };
	static const Color blue = { 0, 0, 255, 255 };
	static const Color fuchsia = { 255, 0, 255, 255 };
	static const Color gray = { 128, 128, 128, 255 };
	static const Color green = { 0, 128, 0, 255 };
	static const Color lime = { 0, 255, 0, 255 };
	static const Color maroon = { 128, 0, 0, 255 };
	static const Color navy = { 0, 0, 127, 255 };
	static const Color olive = { 127, 127, 0, 255 };
	static const Color purple = { 127, 0, 127, 255 };
	static const Color red = { 255, 0, 0, 255 };
	static const Color silver = { 192, 192, 192, 255 };
	static const Color teal = { 0, 127, 127, 255 };
	static const Color yellow = { 255, 255, 0, 255 };
	static const Color white = { 255, 255, 255, 255 };

	string_slice str = stringIn;
	str = str.trim();
	if (str.startsWith("#")) {
		Color color;
		str.eraseFirst(1);
		if (str.length() == 6) {
			color.red = ParseHex(str.substr(0, 2));
			color.green = ParseHex(str.substr(2, 2));
			color.blue = ParseHex(str.substr(4, 2));
			color.alpha = 255;
			return color;
			}
		else if (str.length() == 3) {
			color.red = DoubleHexDigit(ParseHex(str.substr(0, 1)));
			color.green = DoubleHexDigit(ParseHex(str.substr(1, 1)));
			color.blue = DoubleHexDigit(ParseHex(str.substr(2, 1)));
			color.alpha = 255;
			return color;
			}
		}
	else if (str.startsWith("rgb(")) {
		Color color;
		str = str.substr(4, str.length() - 5);	// get rid of "rgb(" and ")"
		string_slice component = str.separate(",", &str).trim();
		color.red = ParseColorComponent(component);
		component = str.separate(",", &str).trim();
		color.green = ParseColorComponent(component);
		component = str.separate(",", &str).trim();
		color.blue = ParseColorComponent(component);
		color.alpha = 255;
		return color;
		}
	else if (str.startsWith("rgba(")) {
		Color color;
		str = str.substr(5, str.length() - 6);	// get rid of "rgba(" and ")"
		string_slice component = str.separate(",", &str).trim();
		color.red = ParseColorComponent(component);
		component = str.separate(",", &str).trim();
		color.green = ParseColorComponent(component);
		component = str.separate(",", &str).trim();
		color.blue = ParseColorComponent(component);
		component = str.separate(",", &str).trim();
		color.alpha = ParseColorComponent(component);
		return color;
		}
	else if (str == "aqua")
		return aqua;
	else if (str == "black")
		return black;
	else if (str == "blue")
		return blue;
	else if (str == "fuchsia")
		return fuchsia;
	else if (str == "gray" || str == "grey")
		return gray;
	else if (str == "green")
		return green;
	else if (str == "lime")
		return lime;
	else if (str == "maroon")
		return maroon;
	else if (str == "navy")
		return navy;
	else if (str == "olive")
		return olive;
	else if (str == "purple")
		return purple;
	else if (str == "red")
		return red;
	else if (str == "silver")
		return silver;
	else if (str == "teal")
		return teal;
	else if (str == "yellow")
		return yellow;
	else if (str == "white")
		return white;

	// default: black
	return black;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static unsigned long ParseHex(string_slice str)
{
	unsigned long val = 0;
	const char* stopper = str.end();
	for (const char* p = str.begin(); p < stopper; ++p) {
		char c = *p;
		if (c >= '0' && c <= '9') {
			val *= 16;
			val += c - '0';
			}
		else if (c >= 'A' && c <= 'F') {
			val *= 16;
			val += 0x0A + c - 'A';
			}
		else if (c >= 'a' && c <= 'f') {
			val *= 16;
			val += 0x0A + c - 'a';
			}
		}
	return val;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static long ParseInt(string_slice str)
{
	long val = 0;
	const char* stopper = str.end();
	int sign = 1;
	for (const char* p = str.begin(); p < stopper; ++p) {
		char c = *p;
		if (c >= '0' && c <= '9') {
			val *= 10;
			val += c - '0';
			}
		else if (c == '-')
			sign = -sign;
		}
	return sign * val;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static StyleScriptable* ParseObj(DOMString str)
{
	if (str.startsWith("obj(")) {
		int addr = string_slice(str.substr(4, str.length() - 5)).asInt();
		return dynamic_cast<StyleScriptable*>((StyleScriptable*) addr);
		}
	else
		return NULL;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString Eval(DOMString expr, StyleScriptable* target)
{
	int pos;

	StyleScriptable* obj = target;
	const char* p = expr.begin();
	const char* stopper = expr.end();
	DOMString result;
	while (p < stopper) {
		char c = *p++;
		if (c == '.') {
			pos = p - expr.begin() - 1;
			DOMString propertyName = expr.substr(0, pos).trim();
			expr = expr.substr(pos + 1, expr.length() - pos - 1);
			DOMString propVal = obj->GetScriptProperty(propertyName);
			StyleScriptable* nextObj = ParseObj(propVal);
			if (nextObj)
				obj = nextObj;
			else {
				result += propVal;
				result += ".";
				}
			}
		else if (c == '(') {
			int parenPos = p - expr.begin() - 1;
			DOMString funcName = expr.substr(0, parenPos).trim();
			// find the arg
			int parenLevel = 1;
			while (p < stopper) {
				c = *p++;
				if (c == '(')
					++parenLevel;
				else if (c == ')') {
					--parenLevel;
					if (parenLevel <= 0)
						break;
					}
				}
			int pos = p - expr.begin() - 1;
			DOMString arg = expr.substr(parenPos + 1, pos - parenPos - 1);
			expr = expr.substr(pos + 1, expr.length() - pos - 1);
			// call
			DOMString funcResult = obj->FunctionCall(funcName, arg, target);
			StyleScriptable* nextObj = ParseObj(funcResult);
			if (nextObj)
				obj = nextObj;
			else
				result += funcResult;
			}
		}

	// at the last bit; treat it as a property
	DOMString propVal = obj->GetScriptProperty(expr.trim());
	result += propVal;
	return result.trim();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString NextArg(DOMString& args)
{
	const char* p = args.begin();
	const char* stopper = args.end();
	int parenLevel = 0;
	while (p < stopper) {
		char c = *p++;
		if (c == ',' && parenLevel <= 0) {
			int pos = p - args.begin() - 1;
			DOMString result = args.substr(0, pos);
			args = args.substr(pos + 1, args.length() - pos - 1);
			return result;
			}
		else if (c == '(')
			++parenLevel;
		else if (c == ')')
			--parenLevel;
		}

	// fell thru; it's the last arg
	DOMString result = args;
	args = "";
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private Static"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static unsigned long DoubleHexDigit(unsigned long digit)
{
	return (digit | digit << 4);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static int ParseColorComponent(string_slice component)
{
	if (component[component.length() - 1] == '%') {
		// percentage
		return (component.substr(0, component.length() - 1).asInt() * 255) / 100;
		}
	else
		return component.asInt();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* SkipQuote(const char* p, const char* stopper)
{
	while (p < stopper) {
		char c = *p++;
		if (c == '\\')
			p++;
		else if (c == '"')
			break;
		}
	return p;
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 17:11:38 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
StyleScriptable
</name>
<hIncludes><![CDATA[
#include "DOMString.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "StyleParser.h"
#include <stdio.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:09:48 PST"><![CDATA[
virtual ~StyleScriptable()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DOMString GetScriptProperty(DOMString property)
{
	// default: no property of this type; return the property string
	return property;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual DOMString FunctionCall(DOMString function, DOMString arg, StyleScriptable* target)
{
	if (function == "if") {
		DOMString cond = NextArg(arg);
		DOMString ifClause = NextArg(arg);
		if (!target->Eval(cond).empty())
			return target->Eval(ifClause);
		else
			return target->Eval(NextArg(arg));
		}

	else if (function == "quote")
		return arg;

	else {
		DOMString result = function;
		result += "(";
		result += arg;
		result += ")";
		return result;
		}
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString Eval(DOMString expr)
{
	return StyleParser::Eval(expr, this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString NextArg(DOMString& args)
{
	return StyleParser::NextArg(args);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
DOMString AsString()
{
	char result[64];
	sprintf(result, "obj(%d)", (int) this);
	DOMString resultStr = result;
	resultStr.detach();
	return resultStr;
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Controls"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 18:03:26 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Control
</name>
<hIncludes><![CDATA[
#include "Rectangle.h"
#include "Color.h"

class DisplayDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DisplayDirector.h"
#include "View.h"
#include "CoordPoint.h"
]]></cppIncludes>
<method access="public" mod-time="Thu, 30 Mar 2000 16:47:57 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 16:48:09 PST"><![CDATA[
virtual ~Control()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual Rectangle GetRect() = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(DisplayDirector* director) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MouseDown(int x, int y, DisplayDirector* director) = 0;
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Helpers for subclasses"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:03:26 PST"><![CDATA[
int CurAlpha(DisplayDirector* director)
{
	// find out where the mouse is and make sure it's in the window
	View* windowView = director->WindowView();
	CoordPoint mousePoint = windowView->GetMousePoint();
	if (!windowView->Bounds().BRect::Contains(mousePoint))
		return 0;

	// calculate the alpha
	Rectangle rect = GetRect();
	int xDistance = 0;
	if (mousePoint.x < rect.left)
		xDistance = (int) (rect.left - mousePoint.x);
	else if (mousePoint.x > rect.right)
		xDistance = (int) (mousePoint.x - rect.right);
	int yDistance = 0;
	if (mousePoint.y < rect.top)
		yDistance = (int) (rect.top - mousePoint.y);
	else if (mousePoint.y > rect.bottom)
		yDistance = (int) (mousePoint.y - rect.bottom);
	float distance = sqrt(xDistance * xDistance + yDistance * yDistance);
	if (distance > visibleZone)
		distance = visibleZone;
	float visibility = (visibleZone - distance) / visibleZone;
	return (int) (visibility * 255);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const Color controlColor = { 0, 0xBA, 255, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float visibleZone = 64;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:04:38 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
ScrollerControl
</name>
<superclasses>
public Control
</superclasses>
<hIncludes><![CDATA[
#include "Control.h"
#include "Color.h"

class WindowDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
ScrollerControl(WindowDirector* directorIn)
	: director(directorIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Control virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle GetRect()
{
	Rectangle rect = director->ViewBounds();
	rect.bottom -= director->GetVMargin();
	rect.top = rect.bottom - height;
	rect.right -= (director->GetHMargin() - width) / 2;
	rect.left = rect.right - width;
	return rect;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:04:25 PST"><![CDATA[
void Draw(DisplayDirector* directorIn)
{
	int alpha = CurAlpha(director);
	if (alpha == 0)
		return;

	// set up
	View* view = director->DrawingView();
	view->PushState();
	view->SetDrawingMode(AlphaDrawingMode);
	Rectangle rect = GetRect();
	Color frameColor = controlColor;
	frameColor.alpha = alpha;

	// draw the thumb
	int scrollPos = director->GetScrollPos();
	int docHeight = director->GetDocumentHeight();
	float proportion = director->GetVisibleProportion();
	Rectangle thumbRect = rect;
	thumbRect.top += (float) scrollPos / docHeight * height;
	thumbRect.bottom = thumbRect.top + proportion * height;
	view->SetHighColor(frameColor);
	view->StrokeRect(thumbRect);
	thumbRect.InsetBy(1, 1);
	Color curThumbColor = thumbColor;
	curThumbColor.alpha = alpha;
	view->SetHighColor(curThumbColor);
	view->FillRect(thumbRect);

	// draw the frame
	view->SetHighColor(frameColor);
	view->StrokeLine(rect.LeftTop(), rect.RightTop());
	view->StrokeLine(rect.LeftBottom(), rect.RightBottom());
	int xCenter = (int) ((rect.left + rect.right) / 2);
	view->StrokeLine(CoordPoint(xCenter, rect.top), CoordPoint(xCenter, thumbRect.top - 1));
	view->StrokeLine(CoordPoint(xCenter, thumbRect.bottom + 1), CoordPoint(xCenter, rect.bottom));

	view->PopState();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:04:38 PST"><![CDATA[
void MouseDown(int x, int y, DisplayDirector* directorIn)
{
	CoordPoint mousePoint(x, y);

	// figure out how we're scrolling
	Rectangle rect = GetRect();
	int lastScrollPos = director->GetScrollPos();
	int docHeight = director->GetDocumentHeight();
	float proportion = director->GetVisibleProportion();
	float thumbTop = rect.top + lastScrollPos / docHeight * height;
	float thumbBottom = thumbTop + proportion * height;
	float offset = 0;	// default is "above thumb"
	bool inThumb = false;
	if (mousePoint.y > thumbTop && mousePoint.y < thumbBottom) {
		// in thumb
		offset = mousePoint.y - thumbTop;
		inThumb = true;
		}
	else if (mousePoint.y > thumbBottom) {
		// below thumb
		offset = proportion * height;
		}
	float lastMouseY = -60000;	// always wanna go thru the loop once

	View* view = director->WindowView();
	while (true) {
		// get the mouse
		mousePoint = view->GetMousePoint();
		int buttons = view->GetMouseButtons();
		if (buttons == 0)
			break;

		// scroll the document
		int targetScrollPos =
			(int) ceil((mousePoint.y - offset - rect.top) / height * docHeight);
		bool scrolling;
		if (lastMouseY != mousePoint.y)
			director->SetScrollTarget(targetScrollPos);
		scrolling = director->DoScrollStep();
		lastMouseY = mousePoint.y;

		// be nice while scroll isn't taking place
		if (!scrolling)
			view->MouseTrackingPause();
		}

	// user let up on mouse; stop scrolling
	director->SetScrollTarget(director->GetScrollPos());
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int width = 8;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int height = 80;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color thumbColor = { 0xD5, 0xE5, 0xFF, 255 };
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:05:07 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
FrameRateControl
</name>
<superclasses>
public Control
</superclasses>
<hIncludes><![CDATA[
#include "Control.h"

class Font;
class WindowDirector;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "View.h"
#include "Font.h"
#include <stdio.h>

// values for "displaying"
enum {
	DisplayOff,
	DisplayFrameRate,
	DisplayDrawTime,

	NumDisplayChoices
};
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
FrameRateControl(WindowDirector* directorIn)
	: director(directorIn), displaying(DisplayOff)
{
	font = new Font("Dutch801 Rm BT", 12, Font::Normal);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~FrameRateControl()
{
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Control virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle GetRect()
{
	static const char* maxString = "00.0d/0.00s/0.00b";

	Rectangle viewBounds = director->ViewBounds();
	Rectangle rect;
	rect.left = viewBounds.left + xPos;
	rect.right = rect.left + font->WidthOf(string_slice(maxString));
	rect.bottom = viewBounds.bottom - yPos;
	rect.top = rect.bottom - font->LineHeight();
	return rect;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(DisplayDirector* directorIn)
{
	if (displaying == DisplayOff)
		return;

	View* view = director->DrawingView();
	view->PushState();
	view->SetHighColor(controlColor);

	// create the string
	char str[64];
	if (displaying == DisplayFrameRate) {
		Microseconds frameTime = director->LastScrollFrameTime();
		if (frameTime == 0)
			strcpy(str, "----");
		else
			sprintf(str, "%2.1f fps", 1000000.0 / frameTime);
		}
	else /* displaying == DisplayDrawTime */ {
		sprintf(str, "%2.1fd/%2.1fb",
		        director->LastDrawTime() / 1000.0,
		        director->LastBlitTime() / 1000.0);
		}

	// draw it
	Rectangle rect = GetRect();
	view->SetFont(font);
	view->DrawString(str, rect.left, rect.top + font->Ascent());

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(int x, int y, DisplayDirector* director)
{
	displaying++;
	if (displaying >= NumDisplayChoices)
		displaying = DisplayOff;
	director->RefreshViewRect(GetRect());
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int displaying;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xPos = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yPos = 3;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:05:35 PST" wind-frame="232.000000,59.000000,872.000000,589.000000" list-views-height="0.000000">
<name>
StatusControl
</name>
<superclasses>
public Control
</superclasses>
<hIncludes><![CDATA[
#include "Control.h"

class WindowDirector;
class Font;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "MessageFileSource.h"
#include "Font.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
StatusControl(WindowDirector* directorIn)
	: director(directorIn)
{
	font = new Font("Swis721 BT", 10, Font::Bold);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~StatusControl()
{
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Control virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle GetRect()
{
	Rectangle viewBounds = director->ViewBounds();
	Rectangle rect;
	rect.right = viewBounds.right - xPos;
	rect.left = rect.right - font->WidthOf(string_slice(changedStr));
	rect.top = viewBounds.top + yPos;
	rect.bottom = rect.top + font->LineHeight();
	return rect;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:05:35 PST"><![CDATA[
void Draw(DisplayDirector* director)
{
	View* view = director->DrawingView();
	view->PushState();
	view->SetHighColor(controlColor);
	Rectangle rect = GetRect();
	view->SetFont(font);
	int y = (int) (rect.top + font->Ascent());
	int lineHeight = font->LineHeight();

	// draw changed indicator
	if (director->IsDirty())
		view->DrawString(string_slice(changedStr), rect.left, y);
	y += lineHeight;

	// draw mail indicator
	MessageFileSource* messageSource =
		dynamic_cast<MessageFileSource*>(director->GetDocSource());
	if (messageSource) {
		if (messageSource->IsNewMessage()) {
			const char* msg = (messageSource->IsSent() ? sentStr : unsentStr);
			view->DrawString(string_slice(msg), rect.left, y);
			}
		}

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(int x, int y, DisplayDirector* director)
{
	// does nothing
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xPos = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yPos = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* changedStr = "Changed";
]]></variable>

<variable access="protected" mod-time="Mon, 28 Feb 2000 00:10:16 PST"><![CDATA[
static const char* unsentStr = "Unsent";
]]></variable>

<variable access="protected" mod-time="Mon, 28 Feb 2000 00:10:22 PST"><![CDATA[
static const char* sentStr = "Sent";
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MenuControl
</name>
<superclasses>
public Control
</superclasses>
<hIncludes><![CDATA[
#include "Control.h"
#include "Color.h"

class WindowDirector;
class Font;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "MenuDirector.h"
#include "Font.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MenuControl(WindowDirector* directorIn)
	: director(directorIn)
{
	font = new Font(fontFamily, fontSize, fontStyle);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~MenuControl()
{
	delete font;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Control virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle GetRect()
{
	Rectangle rect;
	Rectangle viewBounds = director->ViewBounds();
	int lineSpill = (lineWidth + 1) / 2;
	rect.right = viewBounds.right - xPos + lineSpill;
	rect.left = rect.right - diameter - 2 * lineSpill;
	rect.top = viewBounds.top + yPos - lineSpill;
	rect.bottom = rect.top + diameter + 2 * lineSpill;
	return rect;

/***
	Rectangle viewBounds = director->ViewBounds();
	Rectangle rect;
	rect.right = viewBounds.right - xPos;
	rect.left = rect.right - font->WidthOf(string_slice(asterisk));
	rect.top = viewBounds.top + yPos;
	rect.bottom = rect.top + font->Ascent();
	return rect;
***/
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(DisplayDirector* directorIn)
{
	if (director->MenuIsVisible())
		return;
	int alpha = CurAlpha(director);
	if (alpha == 0)
		return;

	// set up
	View* view = director->DrawingView();
	view->PushState();
	view->SetDrawingMode(AlphaDrawingMode);
	view->SetPenSize(lineWidth);
	Color white = { 255, 255, 255, 255 };
	view->SetLowColor(white);	// didn't help
//***	Color alphaColor = color;
	Color alphaColor = MenuDirector::borderColor;
	alphaColor.alpha = alpha;

	// calc the ellipse
	Rectangle rect;
	Rectangle viewBounds = director->ViewBounds();
	rect.right = viewBounds.right - xPos;
	rect.left = rect.right - diameter;
	rect.top = viewBounds.top + yPos;
	rect.bottom = rect.top + diameter;

	// clear it
	view->SetHighColor(white);
	view->StrokeEllipse(rect);

	// draw it
	view->SetHighColor(alphaColor);
	view->StrokeEllipse(rect);
/***
	Rectangle rect = GetRect();
	view->SetFont(font);
	view->DrawString(string_slice(asterisk), rect.left, rect.top + font->Ascent());
***/

	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(int x, int y, DisplayDirector* directorIn)
{
	if (director->MenuIsVisible())
		director->HideMenu();
	else
		director->ShowMenu();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Font* font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int xPos = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int yPos = 30;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color color = { 128, 192, 0, 255 };
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int diameter = 12;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int lineWidth = 3;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* asterisk = "*";
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const char* fontFamily = "Dutch801 Rm BT";
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int fontSize = 28;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int fontStyle = Font::Normal;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
MarginControl
</name>
<superclasses>
public Control
</superclasses>
<hIncludes><![CDATA[
#include "Control.h"

class WindowDirector;
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
MarginControl(WindowDirector* directorIn)
	: director(directorIn)
{
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance Variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
WindowDirector* director;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float barLength = 40;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float arrowLength = 10;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float arrowXOffset = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float arrowYOffset = 6;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float minHMargin = 1;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const float minVMargin = 1;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:07:18 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
HMarginControl
</name>
<superclasses>
public MarginControl
</superclasses>
<hIncludes><![CDATA[
#include "MarginControl.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
HMarginControl(WindowDirector* directorIn)
	: MarginControl(directorIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Control virtuals"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:06:31 PST"><![CDATA[
Rectangle GetRect()
{
	int right = director->GetHMargin() - 1;
	int bottom = (int) (director->ViewBounds().bottom - director->GetVMargin());
	Rectangle rect(right - arrowLength, bottom - barLength, right, bottom);
	return rect;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:06:47 PST"><![CDATA[
void Draw(DisplayDirector* directorIn)
{
	int curAlpha = CurAlpha(director);
	if (curAlpha == 0)
		return;

	// set up view
	View* view = director->DrawingView();
	view->PushState();
	view->SetDrawingMode(AlphaDrawingMode);
	Color alphaColor = controlColor;
	alphaColor.alpha = curAlpha;
	view->SetHighColor(alphaColor);

	// draw
	Rectangle curRect = GetRect();
	// bar
	view->StrokeLine(curRect.RightTop(), curRect.RightBottom());
	// arrow
	int arrowY = (int) ceil((curRect.top + curRect.bottom) / 2);
	view->StrokeLine(CoordPoint(curRect.left, arrowY), CoordPoint(curRect.right, arrowY));
	view->StrokeLine(CoordPoint(curRect.right - arrowXOffset, arrowY - arrowYOffset),
	                 CoordPoint(curRect.right, arrowY));
	view->StrokeLine(CoordPoint(curRect.right - arrowXOffset, arrowY + arrowYOffset),
	                 CoordPoint(curRect.right, arrowY));

	// clean up
	view->PopState();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:07:18 PST"><![CDATA[
void MouseDown(int x, int y, DisplayDirector* directorIn)
{
	Rectangle rect = GetRect();
	int offset = (int) (rect.right - x);
	int lastHMargin = director->GetHMargin();
	View* view = director->WindowView();
	while (true) {
		// get the mouse
		CoordPoint mousePoint = view->GetMousePoint();
		int buttons = view->GetMouseButtons();
		if (buttons == 0)
			break;

		// see if it moved
		int newHMargin = (int) (mousePoint.x + offset);
		if (newHMargin < minHMargin)
			newHMargin = (int) minHMargin;
		if (newHMargin == lastHMargin) {
			view->MouseTrackingPause();
			continue;
			}

		// set the new HMargin
		director->SetHMargin(newHMargin);
		lastHMargin = newHMargin;
		}
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 18:08:44 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
VMarginControl
</name>
<superclasses>
public MarginControl
</superclasses>
<hIncludes><![CDATA[
#include "MarginControl.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "WindowDirector.h"
#include "View.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
VMarginControl(WindowDirector* directorIn)
	: MarginControl(directorIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Control virtuals"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:07:52 PST"><![CDATA[
Rectangle GetRect()
{
	int top = (int) (director->ViewBounds().bottom - director->GetVMargin() + 1);
	int left = director->GetHMargin();
	Rectangle rect(left, top, left + barLength, top + arrowLength);
	return rect;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:08:15 PST"><![CDATA[
void Draw(DisplayDirector* directorIn)
{
	int curAlpha = CurAlpha(director);
	if (curAlpha == 0)
		return;

	// set up view
	View* view = director->DrawingView();
	view->PushState();
	view->SetDrawingMode(AlphaDrawingMode);
	Color alphaColor = controlColor;
	alphaColor.alpha = curAlpha;
	view->SetHighColor(alphaColor);

	// draw
	Rectangle curRect = GetRect();
	// bar
	view->StrokeLine(curRect.LeftTop(), curRect.RightTop());
	// arrow
	int arrowX = (int) ceil((curRect.left + curRect.right) / 2);
	view->StrokeLine(CoordPoint(arrowX, curRect.top), CoordPoint(arrowX, curRect.bottom));
	view->StrokeLine(CoordPoint(arrowX - arrowXOffset, curRect.top + arrowYOffset),
	                 CoordPoint(arrowX, curRect.top));
	view->StrokeLine(CoordPoint(arrowX + arrowXOffset, curRect.top + arrowYOffset),
	                 CoordPoint(arrowX, curRect.top));

	// clean up
	view->PopState();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:08:44 PST"><![CDATA[
void MouseDown(int x, int y, DisplayDirector* directorIn)
{
	Rectangle rect = GetRect();
	int offset = (int) (y - rect.top);
	int lastVMargin = director->GetVMargin();
	int viewBottom = (int) director->ViewBounds().bottom;
	View* view = director->WindowView();
	while (true) {
		// get the mouse
		CoordPoint mousePoint = view->GetMousePoint();
		int buttons = view->GetMouseButtons();
		if (buttons == 0)
			break;

		// see if it moved
		float newVMargin = viewBottom - (mousePoint.y - offset);
		if (newVMargin < minVMargin)
			newVMargin = minVMargin;
		if (newVMargin == lastVMargin) {
			view->MouseTrackingPause();
			continue;
			}

		// set the new VMargin
		director->SetVMargin(newVMargin);
		lastVMargin = (int) newVMargin;
		}
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Cross-Platform"
</name>
</class>


<class mod-time="Thu, 30 Mar 2000 18:25:46 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Font
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include <Font.h>

/* BeOS version */
]]></hIncludes>
<cppIncludes><![CDATA[
#include "UTF8Utils.h"
#include <math.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:25:00 PST"><![CDATA[
Font(string_slice familyName, int size, int style)
{
	int face = 0;
	if (style & Bold)
		face |= B_BOLD_FACE;
	if (style & Italic)
		face |= B_ITALIC_FACE;
	if (face == 0)
		face = B_REGULAR_FACE;
	font_family family;
	familyName.copy(family);
	family[familyName.length()] = 0;
	font.SetFamilyAndFace(family, face);
	font.SetSize(size);

	font_height fontInfo;
	font.GetHeight(&fontInfo);
	ascent = (int) ceil(fontInfo.ascent);
	descent = (int) ceil(fontInfo.descent);
	lineHeight = (int) ceil(fontInfo.ascent + fontInfo.descent + fontInfo.leading);

	spaceWidth = WidthOf(" ");
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int LineHeight() const
{
	return lineHeight;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int Ascent() const
{
	return ascent;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline int Descent() const
{
	return descent;
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:25:28 PST"><![CDATA[
int Size() const
{
	return (int) font.Size();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:25:39 PST"><![CDATA[
int WidthOf(string_slice str) const
{
	return (int) ceil(font.StringWidth(str.begin(), str.length()));
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:25:46 PST"><![CDATA[
int CharIndexAtX(int x, string_slice str)
{
	float pixelsLeft = x;
	int numChars = UTF8Utils::CharsInString(str);
	float* escapements = new float[numChars];
	font.GetEscapements(str.begin(), numChars, escapements);
	float fontSize = font.Size();
	int whichChar = 0;
	const char* p = str.begin();
	for (; whichChar < numChars; whichChar++) {
		float charWidth = escapements[whichChar] * fontSize;
		pixelsLeft -= charWidth / 2;
		if (pixelsLeft <= 0)
			break;
		pixelsLeft -= charWidth / 2;
		p += UTF8Utils::BytesForChar(*p);
		}
	delete escapements;
	return (p - str.begin());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int SpaceWidth()
{
	return spaceWidth;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Platform-specific"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline BFont* NativeFont()
{
	return &font;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BFont font;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int ascent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int descent;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int lineHeight;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int spaceWidth;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Styles"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int Normal = 0;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int Bold = 0x01;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const int Italic = 0x02;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:29:06 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
View
</name>
<hIncludes><![CDATA[
#include "CoordPoint.h"
#include "Rectangle.h"
#include "Region.h"
#include "Color.h"
#include "string_slice.h"
#include <View.h>

class NativeView;
class Font;
class Bitmap;
class Message;
class Shape;

// drawing modes
enum {
	CopyDrawingMode = B_OP_COPY,
	AlphaDrawingMode = B_OP_ALPHA
};

// transit types
enum {
	MouseEntering = B_ENTERED_VIEW,
	MouseInside = B_INSIDE_VIEW,
	MouseExiting = B_EXITED_VIEW
};

// modifiers
enum {
	ShiftModifier = B_SHIFT_KEY,
	OptionModifier = B_OPTION_KEY,
	CommandModifier = B_COMMAND_KEY,
	ControlModifier = B_CONTROL_KEY
};

// mouse buttons
enum {
	PrimaryMouseButton = B_PRIMARY_MOUSE_BUTTON,
	SecondaryMouseButton = B_SECONDARY_MOUSE_BUTTON,
	TertiaryMouseButton = B_TERTIARY_MOUSE_BUTTON
};
]]></hIncludes>
<cppIncludes><![CDATA[
#include "NativeView.h"
#include "Font.h"
#include "Bitmap.h"
#include "Message.h"
#include "Shape.h"
#include <Window.h>
#include <Messenger.h>
#include <Screen.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View(NativeView* viewIn)
	: view(viewIn), curClicks(0), curModifiers(0)
{
	view->SetView(this);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MovePenTo(int x, int y)
{
	view->MovePenTo(x, y);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MovePenTo(CoordPoint point)
{
	view->MovePenTo(point);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetHighColor(Color color)
{
	view->SetHighColor(color);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetLowColor(Color color)
{
	view->SetLowColor(color);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetFont(Font* font)
{
	view->SetFont(font->NativeFont());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetDrawingMode(int drawingMode)
{
	view->SetDrawingMode((drawing_mode) drawingMode);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetPenSize(int penSize)
{
	view->SetPenSize(penSize);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ConstrainClippingRegion(Region* region)
{
	view->ConstrainClippingRegion(region);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PushState()
{
	view->PushState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void PopState()
{
	view->PopState();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawString(string_slice str)
{
	view->DrawString(str.begin(), str.length());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawString(string_slice str, int x, int y)
{
	view->DrawString(str.begin(), str.length(), BPoint(x, y));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void ClearRect(Rectangle rect)
{
	view->FillRect(rect, B_SOLID_LOW);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StrokeRect(Rectangle rect)
{
	view->StrokeRect(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FillRect(Rectangle rect)
{
	view->FillRect(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StrokeLine(CoordPoint startPt, CoordPoint endPt)
{
	view->StrokeLine(startPt, endPt);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StrokeBezier(CoordPoint points[4])
{
	view->StrokeBezier(points);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StrokeShape(Shape* shape)
{
	view->StrokeShape(shape->NativeShape());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FillShape(Shape* shape)
{
	view->FillShape(shape->NativeShape());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void StrokeEllipse(Rectangle rect)
{
	view->StrokeEllipse(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FillEllipse(Rectangle rect)
{
	view->FillEllipse(rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void DrawBitmap(Bitmap* bitmap, Rectangle rect)
{
	view->DrawBitmap(bitmap->NativeBitmap(), rect, rect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Sync()
{
	view->Sync();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Lock()
{
	view->Window()->Lock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Unlock()
{
	view->Window()->Unlock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SendMessage(Message* message)
{
	BMessenger(view).SendMessage(message->NativeMessage());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseTrackingPause()
{
	snooze(20 * 1000);	// BeBook recommended value: 20 ms.
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint GetMousePoint()
{
	BPoint cursor;
	uint32 buttons;
	view->GetMouse(&cursor, &buttons, false);
	return cursor;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int GetMouseButtons()
{
	BPoint cursor;
	uint32 buttons;
	view->GetMouse(&cursor, &buttons, true);
	return buttons;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtual hooks"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Draw(Rectangle updateRect)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MouseDown(int x, int y)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void KeyDown(string_slice key)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MouseMoved(int transitType)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void FrameResized(int newWidth, int newHeight)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void MessageReceived(Message* message)
{
	view->BView::MessageReceived(message->NativeMessage());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:28:53 PST"><![CDATA[
int Width()
{
	return (int) view->Bounds().Width();
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:29:06 PST"><![CDATA[
int Height()
{
	return (int) view->Bounds().Height();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Rectangle Bounds()
{
	return view->Bounds();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
long GetColorSpace()
{
	return BScreen(view->Window()).ColorSpace();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int CurClicks()
{
	return curClicks;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int CurModifiers()
{
	return curModifiers;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Platform-specific"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetCurClicks(int newCurClicks)
{
	curClicks = newCurClicks;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetCurModifiers(int newCurModifiers)
{
	curModifiers = newCurModifiers;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NativeView* view;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curClicks;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
int curModifiers;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:27:13 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
NativeView
</name>
<superclasses>
public BView
</superclasses>
<hIncludes><![CDATA[
#include <View.h>

class View;
class Message;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "View.h"
#include "Message.h"
#include <Window.h>
#include <MessageQueue.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
NativeView(BRect frame, const char* name, uint32 resizingMode, uint32 flags)
	: BView(frame, name, resizingMode, flags),
	  view(NULL)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~NativeView()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"BView virtuals--all are passed on to the View"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Draw(BRect updateRect)
{
	view->Draw(updateRect);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void FrameResized(float width, float height)
{
	view->FrameResized(width, height);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void KeyDown(const char* bytes, int32 numBytes)
{
	view->SetCurModifiers(Window()->CurrentMessage()->FindInt32("modifiers"));
	view->KeyDown(string_slice(bytes, bytes + numBytes));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseDown(BPoint point)
{
	BMessage* curMessage = Window()->CurrentMessage();
	view->SetCurClicks(curMessage->FindInt32("clicks"));
	view->SetCurModifiers(curMessage->FindInt32("modifiers"));
	view->MouseDown(point.x, point.y);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MouseMoved(BPoint point, uint32 transit, const BMessage* message)
{
	CleanMessageQueue();
	view->MouseMoved(transit);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MessageReceived(BMessage* nativeMessage)
{
	Message message(nativeMessage);
	view->MessageReceived(&message);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Connection to View object"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void SetView(View* newView)
{
	view = newView;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* GetView()
{
	return view;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void CleanMessageQueue()
{
	// remove all mouse-moved messages to avoid queue poisoning
	BMessageQueue* messageQueue = Window()->MessageQueue();
	while (true) {
		BMessage* message = messageQueue->FindMessage(B_MOUSE_MOVED, 0);
		if (message == NULL)
			break;
		messageQueue->RemoveMessage(message);
		}
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* view;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:23:15 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Bitmap
</name>
<hIncludes><![CDATA[
#include <Bitmap.h>

class View;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "View.h"
#include "NativeView.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Bitmap(int width, int height, long colorSpace)
{
	bitmap = new BBitmap(BRect(0, 0, width, height), (color_space) colorSpace, true);
	NativeView* nativeView =
		new NativeView(BRect(0, 0, width, height), "bitmap view",
	                   B_FOLLOW_ALL_SIDES, B_WILL_DRAW | B_FRAME_EVENTS);
	bitmap->AddChild(nativeView);
	view = new View(nativeView);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Bitmap()
{
	delete bitmap;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Lock()
{
	bitmap->Lock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Unlock()
{
	bitmap->Unlock();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Access"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* GetView()
{
	return view;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
long GetColorSpace()
{
	return bitmap->ColorSpace();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Platform-specific"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BBitmap* NativeBitmap()
{
	return bitmap;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BBitmap* bitmap;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
View* view;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:24:46 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
CoordPoint
</name>
<hIncludes><![CDATA[
#include <Point.h>

typedef BPoint CoordPoint;
]]></hIncludes>
</class>


<class mod-time="Thu, 30 Mar 2000 16:25:25 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Rectangle
</name>
<superclasses>
public BRect
</superclasses>
<hIncludes><![CDATA[
#include <Rect.h>
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline Rectangle(BRect rect)
	: BRect(rect)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline Rectangle()
	: BRect()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline Rectangle(int left, int top, int bottom, int right)
	: BRect(left, top, bottom, right)
{
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 16:49:34 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Region
</name>
<hIncludes><![CDATA[
#include <Region.h>

typedef BRegion Region;
]]></hIncludes>
</class>


<class mod-time="Thu, 30 Mar 2000 18:27:53 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Timing
</name>
<hIncludes><![CDATA[
#include <SupportDefs.h>

typedef bigtime_t Microseconds;
]]></hIncludes>
<cppIncludes><![CDATA[
#include <OS.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Microseconds SystemTime()
{
	return system_time();
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 18:26:02 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Message
</name>
<hIncludes><![CDATA[
#include <Message.h>
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Message(unsigned long what)
	: ownsMessage(true)
{
	message = new BMessage(what);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
~Message()
{
	if (ownsMessage)
		delete message;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
unsigned long What()
{
	return message->what;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Platform-specific"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Message(BMessage* nativeMessage)
	: message(nativeMessage), ownsMessage(false)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BMessage* NativeMessage()
{
	return message;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BMessage* message;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
bool ownsMessage;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:52:45 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Shape
</name>
<hIncludes><![CDATA[
#include "CoordPoint.h"
#include <Shape.h>

/*
	This differs a bit from the other cross-platform classes in that it's not an
	exact analog of its equivalent BeOS class (BShape)
*/
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Shape()
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Operations"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MoveTo(CoordPoint point)
{
	shape.MoveTo(point);
	curPoint = point;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void MoveTo(int x, int y)
{
	MoveTo(CoordPoint(x, y));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LineTo(CoordPoint point)
{
	shape.LineTo(point);
	curPoint = point;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void LineTo(int x, int y)
{
	LineTo(CoordPoint(x, y));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HorizontalCornerTo(CoordPoint point)
{
	BPoint controlPoints[3];
	controlPoints[0].x = (curPoint.x + point.x) / 2;
	controlPoints[0].y = curPoint.y;
	controlPoints[1].x = point.x;
	controlPoints[1].y = (curPoint.y + point.y) / 2;
	controlPoints[2] = point;
	shape.BezierTo(controlPoints);
	curPoint = point;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void HorizontalCornerTo(int x, int y)
{
	HorizontalCornerTo(CoordPoint(x, y));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void VerticalCornerTo(CoordPoint point)
{
	BPoint controlPoints[3];
	controlPoints[0].Set(curPoint.x, (curPoint.y + point.y) / 2);
	controlPoints[1].Set((curPoint.x + point.x) / 2, point.y);
	controlPoints[2] = point;
	shape.BezierTo(controlPoints);
	curPoint = point;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void VerticalCornerTo(int x, int y)
{
	VerticalCornerTo(CoordPoint(x, y));
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Close()
{
	shape.Close();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Clear()
{
	shape.Clear();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Platform-specific"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BShape* NativeShape()
{
	return &shape;
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
BShape shape;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
CoordPoint curPoint;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:49:22 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Keys
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include <InterfaceDefs.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
Keys()
{
	static const char specialKeys[] = {
		B_PAGE_UP,
		B_PAGE_DOWN,
		B_HOME,
		B_END,
		B_UP_ARROW,
		B_DOWN_ARROW,
		B_LEFT_ARROW,
		B_RIGHT_ARROW,
		B_ESCAPE,
		B_DELETE
	};

	PageUpKey = string_slice(&specialKeys[0], &specialKeys[1]);
	PageDownKey = string_slice(&specialKeys[1], &specialKeys[2]);
	HomeKey = string_slice(&specialKeys[2], &specialKeys[3]);
	EndKey = string_slice(&specialKeys[3], &specialKeys[4]);
	UpArrowKey = string_slice(&specialKeys[4], &specialKeys[5]);
	DownArrowKey = string_slice(&specialKeys[5], &specialKeys[6]);
	LeftArrowKey = string_slice(&specialKeys[6], &specialKeys[7]);
	RightArrowKey = string_slice(&specialKeys[7], &specialKeys[8]);
	EscKey = string_slice(&specialKeys[8], &specialKeys[9]);
	DelKey = string_slice(&specialKeys[9], &specialKeys[10]);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Key constants"
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice PageUpKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice PageDownKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice HomeKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice EndKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice UpArrowKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice DownArrowKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice LeftArrowKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice RightArrowKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice EscKey;
]]></variable>

<variable access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice DelKey;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Initializer"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Keys initializer;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 16:45:05 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Color
</name>
<hIncludes><![CDATA[
#include <GraphicsDefs.h>

typedef rgb_color Color;
]]></hIncludes>
</class>


<class mod-time="Thu, 30 Mar 2000 18:29:54 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Error
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<cppIncludes><![CDATA[
#include "qstring.h"
#include <Alert.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void ShowError(string_slice error)
{
	qstring errStr(error);
	BAlert* alert = new BAlert("Error", errStr.c_str(), "OK");
	alert->SetShortcut(0, B_ESCAPE);
	alert->Go();
}
]]></method>

</class>


<class mod-time="Thu, 30 Mar 2000 18:45:57 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Confirmer
</name>
<cppIncludes><![CDATA[
#include <Alert.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static int Confirm(const char* prompt, const char* buttonLabel1,
                   const char* buttonLabel2, const char* buttonLabel3)
{
	BAlert* alert =
		new BAlert("Confirmer", prompt, buttonLabel1, buttonLabel2, buttonLabel3,
		           B_WIDTH_AS_USUAL, B_OFFSET_SPACING, B_WARNING_ALERT);
	alert->SetShortcut(0, B_ESCAPE);
	if (buttonLabel2 && buttonLabel2[0]) {
		char shortcut = buttonLabel2[0];
		if (shortcut >= 'A' && shortcut <= 'Z')
			shortcut += 'a' - 'A';
		alert->SetShortcut(1, shortcut);
		}
	return alert->Go();
}
]]></method>

</class>


<class mod-time="Thu, 20 Apr 2000 00:00:04 PDT" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
System
</name>
<hIncludes><![CDATA[
#include "DOMString.h"

class EnglishEditorApp;
class Element;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "EnglishEditorApp.h"
#include "Element.h"
#include "DOMUtils.h"
#include "qstring.h"
#include "OSException.h"
#include "InternalException.h"
#include <E-mail.h>
#include <Roster.h>
#include <Directory.h>
#include <Entry.h>
#include <Path.h>
#include <NodeInfo.h>
#include <Node.h>
#include <Volume.h>
#include <VolumeRoster.h>
#include <FindDirectory.h>
#include <Query.h>
#include <fs_attr.h>
#include <memory>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Public Static"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString AppDirectory()
{
	// find out where the app lives
	app_info appInfo;
	be_app->GetAppInfo(&appInfo);
	BDirectory parentDir;
	BEntry(&appInfo.ref).GetParent(&parentDir);
	BPath parentPath(&parentDir, NULL);		// note: can't do this in the next expression, 'cause then it's destroyed before "result" has a chance to detach() itself (which happens during the "+=")
	DOMString result = parentPath.Path();
	result += "/";
	return result;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString DocumentsDirectory()
{
	static const char* docDirName = "/boot/home/Documents";
	static const DOMString docDirPath = "/boot/home/Documents/";

	// make sure it exists
	mkdir(docDirName, defaultDirPerms);

	return docDirPath;
}
]]></method>

<method access="public" mod-time="Thu, 06 Apr 2000 01:00:49 PDT"><![CDATA[
static DOMString OutgoingMailDirectory()
{
	BPath path;
	status_t result = find_directory(B_USER_DIRECTORY, &path, true);
	if (result != B_NO_ERROR)
		throw OSException("Couldn't find the outgoing mail folder.", result);
	path.Append("mail/out");

	// make sure it exists
	mkdir(path.Path(), defaultDirPerms);

	// return it
	String mailDirPath = path.Path();
	mailDirPath += "/";
	mailDirPath.detach();
	return mailDirPath;
}
]]></method>

<method access="public" mod-time="Thu, 20 Apr 2000 00:00:04 PDT"><![CDATA[
static DOMString OutgoingNewsDirectory()
{
	static const char* newsDirName = "Usenet Posts";

	// start setting up the path
	DOMString newsDirPath = DocumentsDirectory();
	newsDirPath += newsDirName;

	// make sure it exists
	mkdir(newsDirPath.c_str(), defaultDirPerms);

	// return it (with the trailing slash)
	newsDirPath += "/";
	return newsDirPath;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void SetFileMimeType(DOMString filePathIn, DOMString mimeTypeIn)
{
	qstring filePath(filePathIn);
	qstring mimeType(mimeTypeIn);
	BNode node(filePath.c_str());
	BNodeInfo(&node).SetType(mimeType.c_str());
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void OpenURL(DOMString url)
{
	// strip of beginning "URL:"
	if (url.startsWith("URL:"))
		url = url.substr(4, url.length() - 4);

	// null-terminate the URL
	static const char* nullStr = "\0\0";
	string_slice nullSlice(&nullStr[0], &nullStr[1]);
	url += nullSlice;

	BMessage msg(B_ARGV_RECEIVED);
	msg.AddString("argv", "NetPositive");
	msg.AddString("argv", url.begin());
	msg.AddInt32("argc", 2);

	BMessenger messenger("application/x-vnd.Be-NPOS", -1, NULL);
	if (messenger.IsValid())
		messenger.SendMessage(&msg);
	else
		be_roster->Launch("application/x-vnd.Be-NPOS", &msg);
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:31:36 PST"><![CDATA[
static void PostNewsMessage(String filePathIn)
{
	// launch the app and send it the message
	String filePath = filePathIn;
	BEntry fileEntry(filePath.c_str());
	if (fileEntry.InitCheck() != B_NO_ERROR)
		throw OSException("Couldn't find file to post it.", fileEntry.InitCheck());
	entry_ref fileRef;
	fileEntry.GetRef(&fileRef);
	BMessage postMessage('Post');
	postMessage.AddRef("refs", &fileRef);
	be_roster->Launch("application/x-vnd.Folta-Item", &postMessage);
}
]]></method>

<method access="public" mod-time="Thu, 13 Apr 2000 01:18:59 PDT"><![CDATA[
static void SendMailMessage(String filePathIn, Element* header)
{
	ssize_t result;

	// get ready to set up the attributes
	String filePath = filePathIn;
	BNode node(filePath.c_str());
	if (node.InitCheck() != B_OK)
		throw OSException("Couldn't find the mail message", node.InitCheck());

	// set up the info attributes the mail daemon needs
	// from
	mail_pop_account mailInfo;
	status_t err = get_pop_account(&mailInfo);
	if (err != B_NO_ERROR)
		throw InternalException("Couldn't get your email info.");
	String fromAddr = mailInfo.reply_to;
	if (fromAddr.empty())
		fromAddr = mailInfo.pop_name;
	if (fromAddr.empty())
		throw InternalException("You need to configure your email.");
	String from;
	if (mailInfo.real_name[0]) {
		from += "\"";
		from += mailInfo.real_name;
		from += "\" ";
		}
	from += "<";
	from += fromAddr;
	from += ">";
	from.c_str();
	result = node.WriteAttr(B_MAIL_ATTR_FROM, B_STRING_TYPE, 0,
	                        from.data(), from.length() + 1);
	if (result < 0)
		throw OSException("Couldn't set the \"From\" attribute of the email message.", result);
	// to
	Element* toElement = header->GetElementByTagName("to");
	String to;
	if (toElement)
		to = DOMUtils::NodeContents(toElement).trim();
	if (to.empty())
		throw InternalException("Email message has no recipient.");
	to.c_str();
	result = node.WriteAttr(B_MAIL_ATTR_TO, B_STRING_TYPE, 0,
	                        to.data(), to.length() + 1);
	if (result < 0)
		throw OSException("Couldn't set the \"To\" attribute of the email message.", result);
	// recipients
	String recipients = BuildRecipients(to);
	recipients.c_str();
	result = node.WriteAttr(B_MAIL_ATTR_RECIPIENTS, B_STRING_TYPE, 0,
	                        recipients.data(), recipients.length() + 1);
	if (result < 0)
		throw OSException("Couldn't set the \"Recipients\" attribute of the email message.", result);
	// subject
	Element* titleElement = header->GetElementByTagName("title");
	String subject;
	if (titleElement)
		subject = DOMUtils::NodeContents(titleElement).trim();
	subject.c_str();
	result = node.WriteAttr(B_MAIL_ATTR_SUBJECT, B_STRING_TYPE, 0,
	                        subject.data(), subject.length() + 1);
	// when
	time_t when = real_time_clock();
		// despite what the BeBook says, B_TIME_TYPE is a time_t, not a bigtime_t
	result = node.WriteAttr(B_MAIL_ATTR_WHEN, B_TIME_TYPE, 0, &when, sizeof(when));

	// mark the message as ready to be sent
	string_slice pendingStr = "Pending";
	result = node.WriteAttr(B_MAIL_ATTR_STATUS, B_STRING_TYPE, 0,
	                        pendingStr.begin(), pendingStr.length());
	if (result < 0)
		throw OSException("Couldn't mark mail message as Pending.", result);
	int32 flags = B_MAIL_PENDING | B_MAIL_SAVE;
	result = node.WriteAttr(B_MAIL_ATTR_FLAGS, B_INT32_TYPE, 0, &flags, sizeof(flags));
	if (result < 0)
		throw OSException("Couldn't mark mail message to be sent.", result);

	// send it
	result = send_queued_mail();
	if (result < 0)
		throw OSException("Couldn't send the email.", result);
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:31:56 PST"><![CDATA[
static void MarkMailMessageRead(String filePathIn)
{
	ssize_t result;

	// find the node
	String filePath = filePathIn;
	BNode node(filePath.c_str());
	if (node.InitCheck() != B_OK)
		throw OSException("Couldn't find the mail message", node.InitCheck());

	// check if it's read; we'll only mark "New" messages (or ones without any
	// mail-status attribute)
	attr_info attrInfo;
	status_t err = node.GetAttrInfo(B_MAIL_ATTR_STATUS, &attrInfo);
	if (err == B_NO_ERROR) {
		char* statusStr = new char[attrInfo.size];
		auto_ptr<char> statusStrDeleter(statusStr);
		result = node.ReadAttr(B_MAIL_ATTR_STATUS, B_STRING_TYPE, 0,
		                       statusStr, attrInfo.size);
		if (result < 0)
			return;
		if (string_slice(statusStr) != "New")
			return;
		}

	// mark as read
	qstring readStr = "Read";
	result = node.WriteAttr(B_MAIL_ATTR_STATUS, B_STRING_TYPE, 0,
	                        readStr.c_str(), readStr.length() + 1);
	// don't complain if it fails
}
]]></method>

<method access="public" mod-time="Thu, 30 Mar 2000 18:44:14 PST"><![CDATA[
static void TrashFile(DOMString filePathIn)
{
	String filePath = filePathIn;
	BEntry entry(filePath.c_str());
	BVolume volume;
	status_t result = entry.GetVolume(&volume);
	if (result != B_NO_ERROR)
		throw OSException("Couldn't trash the file.", result);
	BPath trashPath;
	result = find_directory(B_TRASH_DIRECTORY, &trashPath, true, &volume);
	if (result != B_NO_ERROR)
		throw OSException("Couldn't find the trash to trash the file.", result);
	BDirectory trashDir(trashPath.Path());
	result = entry.MoveTo(&trashDir, NULL, true);
	if (result != B_NO_ERROR)
		throw OSException("Couldn't trash the file.", result);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static EnglishEditorApp* GetApplication()
{
	return ((EnglishEditorApp*) be_app);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString AdjustFileName(DOMString fileNameIn)
{
	DOMString adjustedFileName;
	const char* p = fileNameIn.begin();
	const char* stopper = fileNameIn.end();
	const char* runStart = p;
	for (; p < stopper; ++p) {
		if (*p == '/') {
			if (p > runStart)
				adjustedFileName += string_slice(runStart, p);
			adjustedFileName += "\\";
			runStart = p + 1;
			}
		}
	if (p > runStart)
		adjustedFileName += string_slice(runStart, p);
	return adjustedFileName;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static void CopyToClipboard(DOMString xmlData, DOMString textData)
{
	if (!be_clipboard->Lock())
		return;
	be_clipboard->Clear();
	BMessage* clip = be_clipboard->Data();
	if (clip) {
		clip->AddData("text/xml", B_MIME_TYPE, xmlData.begin(), xmlData.length());
		clip->AddData("text/plain", B_MIME_TYPE, textData.begin(), textData.length());
		be_clipboard->Commit();
		}
	be_clipboard->Unlock();
}
]]></method>

<method access="public" mod-time="Thu, 09 Mar 2000 21:45:37 PST"><![CDATA[
static String GetClipboardText()
{
	if (!be_clipboard->Lock())
		return String();
	BMessage* clip = be_clipboard->Data();
	be_clipboard->Unlock();
	if (clip == NULL)
		return String();
	const char* text;
	int32 textLen;
	status_t result =
		clip->FindData("text/plain", B_MIME_TYPE, (const void**) &text, &textLen);
	String clipText;
	if (result == B_NO_ERROR) {
		clipText = string_slice(text, text + textLen);
		clipText.detach();
		}
	return clipText;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Private"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString BuildRecipients(DOMString toStr)
{
	// get the recipients, one-by-one
	DOMString recipients;
	const char* p = toStr.begin();
	const char* stopper = toStr.end();
	const char* recipientStart = p;
	for (;; ++p) {
		if (p >= stopper || *p == ',') {
			string_slice recipient = string_slice(recipientStart, p).trim();
			if (!recipient.empty()) {
				if (!recipients.empty())
					recipients += ", ";
				DOMString cookedRecipient = MakeRecipient(recipient);
				if (cookedRecipient.empty())
					throw InternalException("One of the recipients was invalid.");
				recipients += cookedRecipient;
				}
			recipientStart = p + 1;
			if (p >= stopper)
				break;
			}
		}
	return recipients;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DOMString MakeRecipient(DOMString address)
{
	// first, find a token with an '@' in it
	const char* p = address.begin();
	const char* stopper = address.end();
	const char* tokenStart = p;
	bool hasAt = false;
	for (;; ++p) {
		char c = (p < stopper ? *p : '\0');
		switch (c) {
			case ' ':
			case '\t':
			case '\r':
			case '\n':
			case '<':
			case '>':
			case '(':
			case ')':
			case '\0':
				// any one of these represent the end of a token
				if (hasAt) {
					// this is the token we want; return it
					return string_slice(tokenStart, p);
					}
				// set up to process the next token
				tokenStart = p + 1;
				break;

			case '@':
				hasAt = true;
				break;
			}
		if (c == '\0')
			break;
		}

	// didn't find an email address; treat it as a nickname
	BQuery query;
	query.PushAttr("META:nickname");
	query.PushString(qstring(address).c_str(), true);
	query.PushOp(B_EQ);
	BVolume bootVolume;
	BVolumeRoster().GetBootVolume(&bootVolume);
	query.SetVolume(&bootVolume);
	status_t result = query.Fetch();
	if (result != B_NO_ERROR)
		return "";
	BEntry entry;
	result = query.GetNextEntry(&entry, true);
	if (result != B_NO_ERROR)
		return "";
	BNode node(&entry);
	if (node.InitCheck() != B_NO_ERROR)
		return "";
	const int bufLen = 256;
	char email[bufLen];
	ssize_t bytesRead = node.ReadAttr("META:email", B_STRING_TYPE, 0, email, bufLen);
	if (bytesRead < 0)
		return "";
	return DOMString(email).detach();
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Tweex"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static const unsigned long defaultDirPerms = (S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP);
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Exceptions"
</name>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayableException
</name>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Virtuals"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
virtual void Display() = 0;
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
InternalException
</name>
<superclasses>
public DisplayableException
</superclasses>
<hIncludes><![CDATA[
#include "DisplayableException.h"
#include "string_slice.h"

static const bool useAssertions = true;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
InternalException(string_slice descIn)
	: desc(descIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice Description()
{
	return desc;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Display()
{
	Error::ShowError(desc);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice desc;
]]></variable>

</class>


<class mod-time="Thu, 30 Mar 2000 18:22:49 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
OSException
</name>
<superclasses>
public DisplayableException
</superclasses>
<hIncludes><![CDATA[
#include "DisplayableException.h"
#include "string_slice.h"

#include <SupportDefs.h>
]]></hIncludes>
<cppIncludes><![CDATA[
#include "Error.h"
#include "DOMString.h"
#include <string.h>
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Birth & Death"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
OSException(string_slice descriptionIn, status_t errIn)
	: description(descriptionIn), err(errIn)
{
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Reporting"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice GetDescription()
{
	return description;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
status_t GetError()
{
	return err;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
void Display()
{
	DOMString msg = description;
	if (err != 0) {
		msg += " (";
		msg += strerror(err);
		msg += ")";
		}
	Error::ShowError(msg);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Instance variables"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
string_slice description;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
status_t err;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
"Utils"
</name>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
UTF8Utils
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
]]></hIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline static unsigned int BytesForChar(unsigned char byte)
{
	return (((0xE5000000 >> ((byte >> 3) & 0x1E)) & 3) + 1);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
inline static bool IsFirstByte(char c)
{
	return ((c & 0xC0) != 0x80);
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static unsigned int CharsInString(string_slice str)
{
	unsigned int numChars = 0;
	string_slice::const_iterator stopper = str.end();
	for (string_slice::const_iterator p = str.begin(); p != stopper; numChars++)
		p += BytesForChar(*p);
	return numChars;
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static unsigned int BytesForNChars(string_slice str, unsigned int n)
{
	unsigned int numBytes = 0;
	unsigned int len = str.length();
	while (n > 0 && numBytes < len) {
		numBytes += BytesForChar(str[numBytes]);
		n -= 1;
		}
	return numBytes;
}
]]></method>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
DisplayType
</name>
<hIncludes><![CDATA[

enum DisplayType {
	Block,
	Inline
};
]]></hIncludes>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Prefs
</name>
<hIncludes><![CDATA[
#include "Preferences.h"

Preferences* Prefs();
]]></hIncludes>
<cppIncludes><![CDATA[

Preferences* Prefs()
{
	return Preferences::GetPreferences("English Editor II Prefs");
}
]]></cppIncludes>
</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Tweex
</name>
<hIncludes><![CDATA[
#include "string_slice.h"
#include "Color.h"

class DocumentSource;
class Document;
]]></hIncludes>
<cppIncludes><![CDATA[
#include "DocumentSource.h"
#include "XMLFileSource.h"
#include "Document.h"
#include "Element.h"
#include "Attr.h"
#include "Text.h"
#include "StyleParser.h"
#include "System.h"
#include "Error.h"
]]></cppIncludes>
<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static string_slice GetString(string_slice tweakName)
{
	const string_slice tweexDocName = "Tweex.xml";

	// get the document
	if (docSource == NULL) {
		try {
			DOMString filePath = System::AppDirectory();
			filePath += tweexDocName;
			docSource = new XMLFileSource(filePath);
			tweexDoc = docSource->GetDocument();
			}
		catch (...) {
			DOMString msg = "Couldn't open \"";
			msg += tweexDocName;
			msg += "\".  Make sure the program was installed correctly.";
/***
			Error::ShowError(msg);		// can't do this at init-statics time because
			                      		// the connection to the app-server isn't
			                      		// up yet (presumably)
***/
			return "";
			}
		}

	Element* element = tweexDoc->DocumentElement();
	Attr* attr = element->GetAttributeNode(tweakName);
	if (attr == NULL)
		return string_slice();
	Text* attrText = dynamic_cast<Text*>(attr->FirstChild());
	if (attrText == NULL)
		return string_slice();
	return attrText->Data();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static int GetInt(string_slice tweakName)
{
	return GetString(tweakName).asInt();
}
]]></method>

<method access="public" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Color GetColor(string_slice tweakName)
{
	string_slice colorStr = GetString(tweakName);
	return StyleParser::ParseColor(colorStr);
}
]]></method>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
"Statics"
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static DocumentSource* docSource = NULL;
]]></variable>

<variable access="protected" mod-time="Wed, 31 Dec 1969 15:59:59 PST"><![CDATA[
static Document* tweexDoc = NULL;
]]></variable>

</class>


<class mod-time="Wed, 31 Dec 1969 15:59:59 PST" wind-frame="0.000000,0.000000,-1.000000,-1.000000" list-views-height="0.000000">
<name>
Messages
</name>
<hIncludes><![CDATA[

enum {
	ScrollStepMessage = 'Scr+'
};
]]></hIncludes>
</class>


</project>
